// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `com.google.android.play.core.appupdate.AppUpdateManager`
class AppUpdateManager extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<AppUpdateManager> $type;

  @jni$_.internal
  AppUpdateManager.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/google/android/play/core/appupdate/AppUpdateManager');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $AppUpdateManager$NullableType();
  static const type = $AppUpdateManager$Type();
  static final _id_completeUpdate = _class.instanceMethodId(
    r'completeUpdate',
    r'()Lcom/google/android/gms/tasks/Task;',
  );

  static final _completeUpdate = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract com.google.android.gms.tasks.Task completeUpdate()`
  /// The returned object must be released after use, by calling the [release] method.
  Task<jni$_.JObject?> completeUpdate() {
    return _completeUpdate(
            reference.pointer, _id_completeUpdate as jni$_.JMethodIDPtr)
        .object<Task<jni$_.JObject?>>(
            const $Task$Type<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_getAppUpdateInfo = _class.instanceMethodId(
    r'getAppUpdateInfo',
    r'()Lcom/google/android/gms/tasks/Task;',
  );

  static final _getAppUpdateInfo = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract com.google.android.gms.tasks.Task getAppUpdateInfo()`
  /// The returned object must be released after use, by calling the [release] method.
  Task<AppUpdateInfo?> getAppUpdateInfo() {
    return _getAppUpdateInfo(
            reference.pointer, _id_getAppUpdateInfo as jni$_.JMethodIDPtr)
        .object<Task<AppUpdateInfo?>>(
            const $Task$Type<AppUpdateInfo?>($AppUpdateInfo$NullableType()));
  }

  static final _id_startUpdateFlow = _class.instanceMethodId(
    r'startUpdateFlow',
    r'(Lcom/google/android/play/core/appupdate/AppUpdateInfo;Landroid/app/Activity;Lcom/google/android/play/core/appupdate/AppUpdateOptions;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _startUpdateFlow = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract com.google.android.gms.tasks.Task startUpdateFlow(com.google.android.play.core.appupdate.AppUpdateInfo appUpdateInfo, android.app.Activity activity, com.google.android.play.core.appupdate.AppUpdateOptions appUpdateOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  Task<jni$_.JInteger?>? startUpdateFlow(
    AppUpdateInfo appUpdateInfo,
    jni$_.JObject activity,
    AppUpdateOptions appUpdateOptions,
  ) {
    final _$appUpdateInfo = appUpdateInfo.reference;
    final _$activity = activity.reference;
    final _$appUpdateOptions = appUpdateOptions.reference;
    return _startUpdateFlow(
            reference.pointer,
            _id_startUpdateFlow as jni$_.JMethodIDPtr,
            _$appUpdateInfo.pointer,
            _$activity.pointer,
            _$appUpdateOptions.pointer)
        .object<Task<jni$_.JInteger?>?>(
            const $Task$NullableType<jni$_.JInteger?>(
                jni$_.JIntegerNullableType()));
  }

  static final _id_registerListener = _class.instanceMethodId(
    r'registerListener',
    r'(Lcom/google/android/play/core/install/InstallStateUpdatedListener;)V',
  );

  static final _registerListener = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void registerListener(com.google.android.play.core.install.InstallStateUpdatedListener installStateUpdatedListener)`
  void registerListener(
    InstallStateUpdatedListener installStateUpdatedListener,
  ) {
    final _$installStateUpdatedListener = installStateUpdatedListener.reference;
    _registerListener(
            reference.pointer,
            _id_registerListener as jni$_.JMethodIDPtr,
            _$installStateUpdatedListener.pointer)
        .check();
  }

  static final _id_unregisterListener = _class.instanceMethodId(
    r'unregisterListener',
    r'(Lcom/google/android/play/core/install/InstallStateUpdatedListener;)V',
  );

  static final _unregisterListener = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void unregisterListener(com.google.android.play.core.install.InstallStateUpdatedListener installStateUpdatedListener)`
  void unregisterListener(
    InstallStateUpdatedListener installStateUpdatedListener,
  ) {
    final _$installStateUpdatedListener = installStateUpdatedListener.reference;
    _unregisterListener(
            reference.pointer,
            _id_unregisterListener as jni$_.JMethodIDPtr,
            _$installStateUpdatedListener.pointer)
        .check();
  }

  static final _id_startUpdateFlowForResult = _class.instanceMethodId(
    r'startUpdateFlowForResult',
    r'(Lcom/google/android/play/core/appupdate/AppUpdateInfo;Landroidx/activity/result/ActivityResultLauncher;Lcom/google/android/play/core/appupdate/AppUpdateOptions;)Z',
  );

  static final _startUpdateFlowForResult = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract boolean startUpdateFlowForResult(com.google.android.play.core.appupdate.AppUpdateInfo appUpdateInfo, androidx.activity.result.ActivityResultLauncher activityResultLauncher, com.google.android.play.core.appupdate.AppUpdateOptions appUpdateOptions)`
  bool startUpdateFlowForResult(
    AppUpdateInfo appUpdateInfo,
    jni$_.JObject activityResultLauncher,
    AppUpdateOptions appUpdateOptions,
  ) {
    final _$appUpdateInfo = appUpdateInfo.reference;
    final _$activityResultLauncher = activityResultLauncher.reference;
    final _$appUpdateOptions = appUpdateOptions.reference;
    return _startUpdateFlowForResult(
            reference.pointer,
            _id_startUpdateFlowForResult as jni$_.JMethodIDPtr,
            _$appUpdateInfo.pointer,
            _$activityResultLauncher.pointer,
            _$appUpdateOptions.pointer)
        .boolean;
  }

  static final _id_startUpdateFlowForResult$1 = _class.instanceMethodId(
    r'startUpdateFlowForResult',
    r'(Lcom/google/android/play/core/appupdate/AppUpdateInfo;ILandroid/app/Activity;I)Z',
  );

  static final _startUpdateFlowForResult$1 =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32
                          )>)>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  int,
                  jni$_.Pointer<jni$_.Void>,
                  int)>();

  /// from: `public abstract boolean startUpdateFlowForResult(com.google.android.play.core.appupdate.AppUpdateInfo appUpdateInfo, int i, android.app.Activity activity, int i1)`
  bool startUpdateFlowForResult$1(
    AppUpdateInfo appUpdateInfo,
    int i,
    jni$_.JObject activity,
    int i1,
  ) {
    final _$appUpdateInfo = appUpdateInfo.reference;
    final _$activity = activity.reference;
    return _startUpdateFlowForResult$1(
            reference.pointer,
            _id_startUpdateFlowForResult$1 as jni$_.JMethodIDPtr,
            _$appUpdateInfo.pointer,
            i,
            _$activity.pointer,
            i1)
        .boolean;
  }

  static final _id_startUpdateFlowForResult$2 = _class.instanceMethodId(
    r'startUpdateFlowForResult',
    r'(Lcom/google/android/play/core/appupdate/AppUpdateInfo;ILcom/google/android/play/core/common/IntentSenderForResultStarter;I)Z',
  );

  static final _startUpdateFlowForResult$2 =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32
                          )>)>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  int,
                  jni$_.Pointer<jni$_.Void>,
                  int)>();

  /// from: `public abstract boolean startUpdateFlowForResult(com.google.android.play.core.appupdate.AppUpdateInfo appUpdateInfo, int i, com.google.android.play.core.common.IntentSenderForResultStarter intentSenderForResultStarter, int i1)`
  bool startUpdateFlowForResult$2(
    AppUpdateInfo appUpdateInfo,
    int i,
    jni$_.JObject intentSenderForResultStarter,
    int i1,
  ) {
    final _$appUpdateInfo = appUpdateInfo.reference;
    final _$intentSenderForResultStarter =
        intentSenderForResultStarter.reference;
    return _startUpdateFlowForResult$2(
            reference.pointer,
            _id_startUpdateFlowForResult$2 as jni$_.JMethodIDPtr,
            _$appUpdateInfo.pointer,
            i,
            _$intentSenderForResultStarter.pointer,
            i1)
        .boolean;
  }

  static final _id_startUpdateFlowForResult$3 = _class.instanceMethodId(
    r'startUpdateFlowForResult',
    r'(Lcom/google/android/play/core/appupdate/AppUpdateInfo;Landroid/app/Activity;Lcom/google/android/play/core/appupdate/AppUpdateOptions;I)Z',
  );

  static final _startUpdateFlowForResult$3 =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32
                          )>)>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  int)>();

  /// from: `public abstract boolean startUpdateFlowForResult(com.google.android.play.core.appupdate.AppUpdateInfo appUpdateInfo, android.app.Activity activity, com.google.android.play.core.appupdate.AppUpdateOptions appUpdateOptions, int i)`
  bool startUpdateFlowForResult$3(
    AppUpdateInfo appUpdateInfo,
    jni$_.JObject activity,
    AppUpdateOptions appUpdateOptions,
    int i,
  ) {
    final _$appUpdateInfo = appUpdateInfo.reference;
    final _$activity = activity.reference;
    final _$appUpdateOptions = appUpdateOptions.reference;
    return _startUpdateFlowForResult$3(
            reference.pointer,
            _id_startUpdateFlowForResult$3 as jni$_.JMethodIDPtr,
            _$appUpdateInfo.pointer,
            _$activity.pointer,
            _$appUpdateOptions.pointer,
            i)
        .boolean;
  }

  static final _id_startUpdateFlowForResult$4 = _class.instanceMethodId(
    r'startUpdateFlowForResult',
    r'(Lcom/google/android/play/core/appupdate/AppUpdateInfo;Lcom/google/android/play/core/common/IntentSenderForResultStarter;Lcom/google/android/play/core/appupdate/AppUpdateOptions;I)Z',
  );

  static final _startUpdateFlowForResult$4 =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32
                          )>)>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  int)>();

  /// from: `public abstract boolean startUpdateFlowForResult(com.google.android.play.core.appupdate.AppUpdateInfo appUpdateInfo, com.google.android.play.core.common.IntentSenderForResultStarter intentSenderForResultStarter, com.google.android.play.core.appupdate.AppUpdateOptions appUpdateOptions, int i)`
  bool startUpdateFlowForResult$4(
    AppUpdateInfo appUpdateInfo,
    jni$_.JObject intentSenderForResultStarter,
    AppUpdateOptions appUpdateOptions,
    int i,
  ) {
    final _$appUpdateInfo = appUpdateInfo.reference;
    final _$intentSenderForResultStarter =
        intentSenderForResultStarter.reference;
    final _$appUpdateOptions = appUpdateOptions.reference;
    return _startUpdateFlowForResult$4(
            reference.pointer,
            _id_startUpdateFlowForResult$4 as jni$_.JMethodIDPtr,
            _$appUpdateInfo.pointer,
            _$intentSenderForResultStarter.pointer,
            _$appUpdateOptions.pointer,
            i)
        .boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $AppUpdateManager> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'completeUpdate()Lcom/google/android/gms/tasks/Task;') {
        final $r = _$impls[$p]!.completeUpdate();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'getAppUpdateInfo()Lcom/google/android/gms/tasks/Task;') {
        final $r = _$impls[$p]!.getAppUpdateInfo();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'startUpdateFlow(Lcom/google/android/play/core/appupdate/AppUpdateInfo;Landroid/app/Activity;Lcom/google/android/play/core/appupdate/AppUpdateOptions;)Lcom/google/android/gms/tasks/Task;') {
        final $r = _$impls[$p]!.startUpdateFlow(
          $a![0]!.as(const $AppUpdateInfo$Type(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![2]!.as(const $AppUpdateOptions$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'registerListener(Lcom/google/android/play/core/install/InstallStateUpdatedListener;)V') {
        _$impls[$p]!.registerListener(
          $a![0]!.as(const $InstallStateUpdatedListener$Type(),
              releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d ==
          r'unregisterListener(Lcom/google/android/play/core/install/InstallStateUpdatedListener;)V') {
        _$impls[$p]!.unregisterListener(
          $a![0]!.as(const $InstallStateUpdatedListener$Type(),
              releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d ==
          r'startUpdateFlowForResult(Lcom/google/android/play/core/appupdate/AppUpdateInfo;Landroidx/activity/result/ActivityResultLauncher;Lcom/google/android/play/core/appupdate/AppUpdateOptions;)Z') {
        final $r = _$impls[$p]!.startUpdateFlowForResult(
          $a![0]!.as(const $AppUpdateInfo$Type(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![2]!.as(const $AppUpdateOptions$Type(), releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d ==
          r'startUpdateFlowForResult(Lcom/google/android/play/core/appupdate/AppUpdateInfo;ILandroid/app/Activity;I)Z') {
        final $r = _$impls[$p]!.startUpdateFlowForResult$1(
          $a![0]!.as(const $AppUpdateInfo$Type(), releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![2]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![3]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d ==
          r'startUpdateFlowForResult(Lcom/google/android/play/core/appupdate/AppUpdateInfo;ILcom/google/android/play/core/common/IntentSenderForResultStarter;I)Z') {
        final $r = _$impls[$p]!.startUpdateFlowForResult$2(
          $a![0]!.as(const $AppUpdateInfo$Type(), releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![2]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![3]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d ==
          r'startUpdateFlowForResult(Lcom/google/android/play/core/appupdate/AppUpdateInfo;Landroid/app/Activity;Lcom/google/android/play/core/appupdate/AppUpdateOptions;I)Z') {
        final $r = _$impls[$p]!.startUpdateFlowForResult$3(
          $a![0]!.as(const $AppUpdateInfo$Type(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![2]!.as(const $AppUpdateOptions$Type(), releaseOriginal: true),
          $a![3]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d ==
          r'startUpdateFlowForResult(Lcom/google/android/play/core/appupdate/AppUpdateInfo;Lcom/google/android/play/core/common/IntentSenderForResultStarter;Lcom/google/android/play/core/appupdate/AppUpdateOptions;I)Z') {
        final $r = _$impls[$p]!.startUpdateFlowForResult$4(
          $a![0]!.as(const $AppUpdateInfo$Type(), releaseOriginal: true),
          $a![1]!.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![2]!.as(const $AppUpdateOptions$Type(), releaseOriginal: true),
          $a![3]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $AppUpdateManager $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.google.android.play.core.appupdate.AppUpdateManager',
      $p,
      _$invokePointer,
      [
        if ($impl.registerListener$async)
          r'registerListener(Lcom/google/android/play/core/install/InstallStateUpdatedListener;)V',
        if ($impl.unregisterListener$async)
          r'unregisterListener(Lcom/google/android/play/core/install/InstallStateUpdatedListener;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory AppUpdateManager.implement(
    $AppUpdateManager $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return AppUpdateManager.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $AppUpdateManager {
  factory $AppUpdateManager({
    required Task<jni$_.JObject?> Function() completeUpdate,
    required Task<AppUpdateInfo?> Function() getAppUpdateInfo,
    required Task<jni$_.JInteger?>? Function(AppUpdateInfo appUpdateInfo,
            jni$_.JObject activity, AppUpdateOptions appUpdateOptions)
        startUpdateFlow,
    required void Function(
            InstallStateUpdatedListener installStateUpdatedListener)
        registerListener,
    bool registerListener$async,
    required void Function(
            InstallStateUpdatedListener installStateUpdatedListener)
        unregisterListener,
    bool unregisterListener$async,
    required bool Function(
            AppUpdateInfo appUpdateInfo,
            jni$_.JObject activityResultLauncher,
            AppUpdateOptions appUpdateOptions)
        startUpdateFlowForResult,
    required bool Function(
            AppUpdateInfo appUpdateInfo, int i, jni$_.JObject activity, int i1)
        startUpdateFlowForResult$1,
    required bool Function(AppUpdateInfo appUpdateInfo, int i,
            jni$_.JObject intentSenderForResultStarter, int i1)
        startUpdateFlowForResult$2,
    required bool Function(AppUpdateInfo appUpdateInfo, jni$_.JObject activity,
            AppUpdateOptions appUpdateOptions, int i)
        startUpdateFlowForResult$3,
    required bool Function(
            AppUpdateInfo appUpdateInfo,
            jni$_.JObject intentSenderForResultStarter,
            AppUpdateOptions appUpdateOptions,
            int i)
        startUpdateFlowForResult$4,
  }) = _$AppUpdateManager;

  Task<jni$_.JObject?> completeUpdate();
  Task<AppUpdateInfo?> getAppUpdateInfo();
  Task<jni$_.JInteger?>? startUpdateFlow(AppUpdateInfo appUpdateInfo,
      jni$_.JObject activity, AppUpdateOptions appUpdateOptions);
  void registerListener(
      InstallStateUpdatedListener installStateUpdatedListener);
  bool get registerListener$async => false;
  void unregisterListener(
      InstallStateUpdatedListener installStateUpdatedListener);
  bool get unregisterListener$async => false;
  bool startUpdateFlowForResult(AppUpdateInfo appUpdateInfo,
      jni$_.JObject activityResultLauncher, AppUpdateOptions appUpdateOptions);
  bool startUpdateFlowForResult$1(
      AppUpdateInfo appUpdateInfo, int i, jni$_.JObject activity, int i1);
  bool startUpdateFlowForResult$2(AppUpdateInfo appUpdateInfo, int i,
      jni$_.JObject intentSenderForResultStarter, int i1);
  bool startUpdateFlowForResult$3(AppUpdateInfo appUpdateInfo,
      jni$_.JObject activity, AppUpdateOptions appUpdateOptions, int i);
  bool startUpdateFlowForResult$4(
      AppUpdateInfo appUpdateInfo,
      jni$_.JObject intentSenderForResultStarter,
      AppUpdateOptions appUpdateOptions,
      int i);
}

final class _$AppUpdateManager with $AppUpdateManager {
  _$AppUpdateManager({
    required Task<jni$_.JObject?> Function() completeUpdate,
    required Task<AppUpdateInfo?> Function() getAppUpdateInfo,
    required Task<jni$_.JInteger?>? Function(AppUpdateInfo appUpdateInfo,
            jni$_.JObject activity, AppUpdateOptions appUpdateOptions)
        startUpdateFlow,
    required void Function(
            InstallStateUpdatedListener installStateUpdatedListener)
        registerListener,
    this.registerListener$async = false,
    required void Function(
            InstallStateUpdatedListener installStateUpdatedListener)
        unregisterListener,
    this.unregisterListener$async = false,
    required bool Function(
            AppUpdateInfo appUpdateInfo,
            jni$_.JObject activityResultLauncher,
            AppUpdateOptions appUpdateOptions)
        startUpdateFlowForResult,
    required bool Function(
            AppUpdateInfo appUpdateInfo, int i, jni$_.JObject activity, int i1)
        startUpdateFlowForResult$1,
    required bool Function(AppUpdateInfo appUpdateInfo, int i,
            jni$_.JObject intentSenderForResultStarter, int i1)
        startUpdateFlowForResult$2,
    required bool Function(AppUpdateInfo appUpdateInfo, jni$_.JObject activity,
            AppUpdateOptions appUpdateOptions, int i)
        startUpdateFlowForResult$3,
    required bool Function(
            AppUpdateInfo appUpdateInfo,
            jni$_.JObject intentSenderForResultStarter,
            AppUpdateOptions appUpdateOptions,
            int i)
        startUpdateFlowForResult$4,
  })  : _completeUpdate = completeUpdate,
        _getAppUpdateInfo = getAppUpdateInfo,
        _startUpdateFlow = startUpdateFlow,
        _registerListener = registerListener,
        _unregisterListener = unregisterListener,
        _startUpdateFlowForResult = startUpdateFlowForResult,
        _startUpdateFlowForResult$1 = startUpdateFlowForResult$1,
        _startUpdateFlowForResult$2 = startUpdateFlowForResult$2,
        _startUpdateFlowForResult$3 = startUpdateFlowForResult$3,
        _startUpdateFlowForResult$4 = startUpdateFlowForResult$4;

  final Task<jni$_.JObject?> Function() _completeUpdate;
  final Task<AppUpdateInfo?> Function() _getAppUpdateInfo;
  final Task<jni$_.JInteger?>? Function(
      AppUpdateInfo appUpdateInfo,
      jni$_.JObject activity,
      AppUpdateOptions appUpdateOptions) _startUpdateFlow;
  final void Function(InstallStateUpdatedListener installStateUpdatedListener)
      _registerListener;
  final bool registerListener$async;
  final void Function(InstallStateUpdatedListener installStateUpdatedListener)
      _unregisterListener;
  final bool unregisterListener$async;
  final bool Function(
      AppUpdateInfo appUpdateInfo,
      jni$_.JObject activityResultLauncher,
      AppUpdateOptions appUpdateOptions) _startUpdateFlowForResult;
  final bool Function(
          AppUpdateInfo appUpdateInfo, int i, jni$_.JObject activity, int i1)
      _startUpdateFlowForResult$1;
  final bool Function(
      AppUpdateInfo appUpdateInfo,
      int i,
      jni$_.JObject intentSenderForResultStarter,
      int i1) _startUpdateFlowForResult$2;
  final bool Function(AppUpdateInfo appUpdateInfo, jni$_.JObject activity,
      AppUpdateOptions appUpdateOptions, int i) _startUpdateFlowForResult$3;
  final bool Function(
      AppUpdateInfo appUpdateInfo,
      jni$_.JObject intentSenderForResultStarter,
      AppUpdateOptions appUpdateOptions,
      int i) _startUpdateFlowForResult$4;

  Task<jni$_.JObject?> completeUpdate() {
    return _completeUpdate();
  }

  Task<AppUpdateInfo?> getAppUpdateInfo() {
    return _getAppUpdateInfo();
  }

  Task<jni$_.JInteger?>? startUpdateFlow(AppUpdateInfo appUpdateInfo,
      jni$_.JObject activity, AppUpdateOptions appUpdateOptions) {
    return _startUpdateFlow(appUpdateInfo, activity, appUpdateOptions);
  }

  void registerListener(
      InstallStateUpdatedListener installStateUpdatedListener) {
    return _registerListener(installStateUpdatedListener);
  }

  void unregisterListener(
      InstallStateUpdatedListener installStateUpdatedListener) {
    return _unregisterListener(installStateUpdatedListener);
  }

  bool startUpdateFlowForResult(AppUpdateInfo appUpdateInfo,
      jni$_.JObject activityResultLauncher, AppUpdateOptions appUpdateOptions) {
    return _startUpdateFlowForResult(
        appUpdateInfo, activityResultLauncher, appUpdateOptions);
  }

  bool startUpdateFlowForResult$1(
      AppUpdateInfo appUpdateInfo, int i, jni$_.JObject activity, int i1) {
    return _startUpdateFlowForResult$1(appUpdateInfo, i, activity, i1);
  }

  bool startUpdateFlowForResult$2(AppUpdateInfo appUpdateInfo, int i,
      jni$_.JObject intentSenderForResultStarter, int i1) {
    return _startUpdateFlowForResult$2(
        appUpdateInfo, i, intentSenderForResultStarter, i1);
  }

  bool startUpdateFlowForResult$3(AppUpdateInfo appUpdateInfo,
      jni$_.JObject activity, AppUpdateOptions appUpdateOptions, int i) {
    return _startUpdateFlowForResult$3(
        appUpdateInfo, activity, appUpdateOptions, i);
  }

  bool startUpdateFlowForResult$4(
      AppUpdateInfo appUpdateInfo,
      jni$_.JObject intentSenderForResultStarter,
      AppUpdateOptions appUpdateOptions,
      int i) {
    return _startUpdateFlowForResult$4(
        appUpdateInfo, intentSenderForResultStarter, appUpdateOptions, i);
  }
}

final class $AppUpdateManager$NullableType
    extends jni$_.JObjType<AppUpdateManager?> {
  @jni$_.internal
  const $AppUpdateManager$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/appupdate/AppUpdateManager;';

  @jni$_.internal
  @core$_.override
  AppUpdateManager? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : AppUpdateManager.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AppUpdateManager?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AppUpdateManager$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AppUpdateManager$NullableType) &&
        other is $AppUpdateManager$NullableType;
  }
}

final class $AppUpdateManager$Type extends jni$_.JObjType<AppUpdateManager> {
  @jni$_.internal
  const $AppUpdateManager$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/appupdate/AppUpdateManager;';

  @jni$_.internal
  @core$_.override
  AppUpdateManager fromReference(jni$_.JReference reference) =>
      AppUpdateManager.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AppUpdateManager?> get nullableType =>
      const $AppUpdateManager$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AppUpdateManager$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AppUpdateManager$Type) &&
        other is $AppUpdateManager$Type;
  }
}

/// from: `com.google.android.play.core.appupdate.AppUpdateManagerFactory`
class AppUpdateManagerFactory extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<AppUpdateManagerFactory> $type;

  @jni$_.internal
  AppUpdateManagerFactory.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/google/android/play/core/appupdate/AppUpdateManagerFactory');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $AppUpdateManagerFactory$NullableType();
  static const type = $AppUpdateManagerFactory$Type();
  static final _id_create = _class.staticMethodId(
    r'create',
    r'(Landroid/content/Context;)Lcom/google/android/play/core/appupdate/AppUpdateManager;',
  );

  static final _create = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public com.google.android.play.core.appupdate.AppUpdateManager create(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static AppUpdateManager create(
    jni$_.JObject context,
  ) {
    final _$context = context.reference;
    return _create(_class.reference.pointer, _id_create as jni$_.JMethodIDPtr,
            _$context.pointer)
        .object<AppUpdateManager>(const $AppUpdateManager$Type());
  }
}

final class $AppUpdateManagerFactory$NullableType
    extends jni$_.JObjType<AppUpdateManagerFactory?> {
  @jni$_.internal
  const $AppUpdateManagerFactory$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/appupdate/AppUpdateManagerFactory;';

  @jni$_.internal
  @core$_.override
  AppUpdateManagerFactory? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : AppUpdateManagerFactory.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AppUpdateManagerFactory?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AppUpdateManagerFactory$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AppUpdateManagerFactory$NullableType) &&
        other is $AppUpdateManagerFactory$NullableType;
  }
}

final class $AppUpdateManagerFactory$Type
    extends jni$_.JObjType<AppUpdateManagerFactory> {
  @jni$_.internal
  const $AppUpdateManagerFactory$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/appupdate/AppUpdateManagerFactory;';

  @jni$_.internal
  @core$_.override
  AppUpdateManagerFactory fromReference(jni$_.JReference reference) =>
      AppUpdateManagerFactory.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AppUpdateManagerFactory?> get nullableType =>
      const $AppUpdateManagerFactory$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AppUpdateManagerFactory$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AppUpdateManagerFactory$Type) &&
        other is $AppUpdateManagerFactory$Type;
  }
}

/// from: `com.google.android.play.core.appupdate.AppUpdateInfo`
class AppUpdateInfo extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<AppUpdateInfo> $type;

  @jni$_.internal
  AppUpdateInfo.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/google/android/play/core/appupdate/AppUpdateInfo');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $AppUpdateInfo$NullableType();
  static const type = $AppUpdateInfo$Type();
  static final _id_availableVersionCode = _class.instanceMethodId(
    r'availableVersionCode',
    r'()I',
  );

  static final _availableVersionCode = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int availableVersionCode()`
  int availableVersionCode() {
    return _availableVersionCode(
            reference.pointer, _id_availableVersionCode as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_installStatus = _class.instanceMethodId(
    r'installStatus',
    r'()I',
  );

  static final _installStatus = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int installStatus()`
  int installStatus() {
    return _installStatus(
            reference.pointer, _id_installStatus as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_updateAvailability = _class.instanceMethodId(
    r'updateAvailability',
    r'()I',
  );

  static final _updateAvailability = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int updateAvailability()`
  int updateAvailability() {
    return _updateAvailability(
            reference.pointer, _id_updateAvailability as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_updatePriority = _class.instanceMethodId(
    r'updatePriority',
    r'()I',
  );

  static final _updatePriority = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int updatePriority()`
  int updatePriority() {
    return _updatePriority(
            reference.pointer, _id_updatePriority as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_bytesDownloaded = _class.instanceMethodId(
    r'bytesDownloaded',
    r'()J',
  );

  static final _bytesDownloaded = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long bytesDownloaded()`
  int bytesDownloaded() {
    return _bytesDownloaded(
            reference.pointer, _id_bytesDownloaded as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_totalBytesToDownload = _class.instanceMethodId(
    r'totalBytesToDownload',
    r'()J',
  );

  static final _totalBytesToDownload = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long totalBytesToDownload()`
  int totalBytesToDownload() {
    return _totalBytesToDownload(
            reference.pointer, _id_totalBytesToDownload as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_clientVersionStalenessDays = _class.instanceMethodId(
    r'clientVersionStalenessDays',
    r'()Ljava/lang/Integer;',
  );

  static final _clientVersionStalenessDays =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.lang.Integer clientVersionStalenessDays()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JInteger? clientVersionStalenessDays() {
    return _clientVersionStalenessDays(reference.pointer,
            _id_clientVersionStalenessDays as jni$_.JMethodIDPtr)
        .object<jni$_.JInteger?>(const jni$_.JIntegerNullableType());
  }

  static final _id_packageName = _class.instanceMethodId(
    r'packageName',
    r'()Ljava/lang/String;',
  );

  static final _packageName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String packageName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString packageName() {
    return _packageName(
            reference.pointer, _id_packageName as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_getFailedUpdatePreconditions = _class.instanceMethodId(
    r'getFailedUpdatePreconditions',
    r'(Lcom/google/android/play/core/appupdate/AppUpdateOptions;)Ljava/util/Set;',
  );

  static final _getFailedUpdatePreconditions =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Set getFailedUpdatePreconditions(com.google.android.play.core.appupdate.AppUpdateOptions appUpdateOptions)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<jni$_.JInteger?>? getFailedUpdatePreconditions(
    AppUpdateOptions? appUpdateOptions,
  ) {
    final _$appUpdateOptions =
        appUpdateOptions?.reference ?? jni$_.jNullReference;
    return _getFailedUpdatePreconditions(
            reference.pointer,
            _id_getFailedUpdatePreconditions as jni$_.JMethodIDPtr,
            _$appUpdateOptions.pointer)
        .object<jni$_.JSet<jni$_.JInteger?>?>(
            const jni$_.JSetNullableType<jni$_.JInteger?>(
                jni$_.JIntegerNullableType()));
  }

  static final _id_isUpdateTypeAllowed = _class.instanceMethodId(
    r'isUpdateTypeAllowed',
    r'(I)Z',
  );

  static final _isUpdateTypeAllowed = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public boolean isUpdateTypeAllowed(int i)`
  bool isUpdateTypeAllowed(
    int i,
  ) {
    return _isUpdateTypeAllowed(
            reference.pointer, _id_isUpdateTypeAllowed as jni$_.JMethodIDPtr, i)
        .boolean;
  }

  static final _id_isUpdateTypeAllowed$1 = _class.instanceMethodId(
    r'isUpdateTypeAllowed',
    r'(Lcom/google/android/play/core/appupdate/AppUpdateOptions;)Z',
  );

  static final _isUpdateTypeAllowed$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean isUpdateTypeAllowed(com.google.android.play.core.appupdate.AppUpdateOptions appUpdateOptions)`
  bool isUpdateTypeAllowed$1(
    AppUpdateOptions appUpdateOptions,
  ) {
    final _$appUpdateOptions = appUpdateOptions.reference;
    return _isUpdateTypeAllowed$1(
            reference.pointer,
            _id_isUpdateTypeAllowed$1 as jni$_.JMethodIDPtr,
            _$appUpdateOptions.pointer)
        .boolean;
  }

  static final _id_zzb = _class.staticMethodId(
    r'zzb',
    r'(Ljava/lang/String;IIILjava/lang/Integer;IJJJJLandroid/app/PendingIntent;Landroid/app/PendingIntent;Landroid/app/PendingIntent;Landroid/app/PendingIntent;Ljava/util/Map;)Lcom/google/android/play/core/appupdate/AppUpdateInfo;',
  );

  static final _zzb = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public com.google.android.play.core.appupdate.AppUpdateInfo zzb(java.lang.String string, int i, int i1, int i2, java.lang.Integer integer, int i3, long j, long j1, long j2, long j3, android.app.PendingIntent pendingIntent, android.app.PendingIntent pendingIntent1, android.app.PendingIntent pendingIntent2, android.app.PendingIntent pendingIntent3, java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  static AppUpdateInfo? zzb(
    jni$_.JString string,
    int i,
    int i1,
    int i2,
    jni$_.JInteger? integer,
    int i3,
    int j,
    int j1,
    int j2,
    int j3,
    jni$_.JObject? pendingIntent,
    jni$_.JObject? pendingIntent1,
    jni$_.JObject? pendingIntent2,
    jni$_.JObject? pendingIntent3,
    jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map,
  ) {
    final _$string = string.reference;
    final _$integer = integer?.reference ?? jni$_.jNullReference;
    final _$pendingIntent = pendingIntent?.reference ?? jni$_.jNullReference;
    final _$pendingIntent1 = pendingIntent1?.reference ?? jni$_.jNullReference;
    final _$pendingIntent2 = pendingIntent2?.reference ?? jni$_.jNullReference;
    final _$pendingIntent3 = pendingIntent3?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _zzb(
            _class.reference.pointer,
            _id_zzb as jni$_.JMethodIDPtr,
            _$string.pointer,
            i,
            i1,
            i2,
            _$integer.pointer,
            i3,
            j,
            j1,
            j2,
            j3,
            _$pendingIntent.pointer,
            _$pendingIntent1.pointer,
            _$pendingIntent2.pointer,
            _$pendingIntent3.pointer,
            _$map.pointer)
        .object<AppUpdateInfo?>(const $AppUpdateInfo$NullableType());
  }
}

final class $AppUpdateInfo$NullableType extends jni$_.JObjType<AppUpdateInfo?> {
  @jni$_.internal
  const $AppUpdateInfo$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/appupdate/AppUpdateInfo;';

  @jni$_.internal
  @core$_.override
  AppUpdateInfo? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : AppUpdateInfo.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AppUpdateInfo?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AppUpdateInfo$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AppUpdateInfo$NullableType) &&
        other is $AppUpdateInfo$NullableType;
  }
}

final class $AppUpdateInfo$Type extends jni$_.JObjType<AppUpdateInfo> {
  @jni$_.internal
  const $AppUpdateInfo$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/appupdate/AppUpdateInfo;';

  @jni$_.internal
  @core$_.override
  AppUpdateInfo fromReference(jni$_.JReference reference) =>
      AppUpdateInfo.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AppUpdateInfo?> get nullableType =>
      const $AppUpdateInfo$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AppUpdateInfo$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AppUpdateInfo$Type) &&
        other is $AppUpdateInfo$Type;
  }
}

/// from: `com.google.android.play.core.appupdate.AppUpdateOptions$Builder`
class AppUpdateOptions$Builder extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<AppUpdateOptions$Builder> $type;

  @jni$_.internal
  AppUpdateOptions$Builder.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/google/android/play/core/appupdate/AppUpdateOptions$Builder');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $AppUpdateOptions$Builder$NullableType();
  static const type = $AppUpdateOptions$Builder$Type();
  static final _id_setAllowAssetPackDeletion = _class.instanceMethodId(
    r'setAllowAssetPackDeletion',
    r'(Z)Lcom/google/android/play/core/appupdate/AppUpdateOptions$Builder;',
  );

  static final _setAllowAssetPackDeletion = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract com.google.android.play.core.appupdate.AppUpdateOptions$Builder setAllowAssetPackDeletion(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  AppUpdateOptions$Builder setAllowAssetPackDeletion(
    bool z,
  ) {
    return _setAllowAssetPackDeletion(reference.pointer,
            _id_setAllowAssetPackDeletion as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<AppUpdateOptions$Builder>(
            const $AppUpdateOptions$Builder$Type());
  }

  static final _id_setAppUpdateType = _class.instanceMethodId(
    r'setAppUpdateType',
    r'(I)Lcom/google/android/play/core/appupdate/AppUpdateOptions$Builder;',
  );

  static final _setAppUpdateType = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract com.google.android.play.core.appupdate.AppUpdateOptions$Builder setAppUpdateType(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  AppUpdateOptions$Builder setAppUpdateType(
    int i,
  ) {
    return _setAppUpdateType(
            reference.pointer, _id_setAppUpdateType as jni$_.JMethodIDPtr, i)
        .object<AppUpdateOptions$Builder>(
            const $AppUpdateOptions$Builder$Type());
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Lcom/google/android/play/core/appupdate/AppUpdateOptions;',
  );

  static final _build = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract com.google.android.play.core.appupdate.AppUpdateOptions build()`
  /// The returned object must be released after use, by calling the [release] method.
  AppUpdateOptions build() {
    return _build(reference.pointer, _id_build as jni$_.JMethodIDPtr)
        .object<AppUpdateOptions>(const $AppUpdateOptions$Type());
  }
}

final class $AppUpdateOptions$Builder$NullableType
    extends jni$_.JObjType<AppUpdateOptions$Builder?> {
  @jni$_.internal
  const $AppUpdateOptions$Builder$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/appupdate/AppUpdateOptions$Builder;';

  @jni$_.internal
  @core$_.override
  AppUpdateOptions$Builder? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : AppUpdateOptions$Builder.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AppUpdateOptions$Builder?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AppUpdateOptions$Builder$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AppUpdateOptions$Builder$NullableType) &&
        other is $AppUpdateOptions$Builder$NullableType;
  }
}

final class $AppUpdateOptions$Builder$Type
    extends jni$_.JObjType<AppUpdateOptions$Builder> {
  @jni$_.internal
  const $AppUpdateOptions$Builder$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/appupdate/AppUpdateOptions$Builder;';

  @jni$_.internal
  @core$_.override
  AppUpdateOptions$Builder fromReference(jni$_.JReference reference) =>
      AppUpdateOptions$Builder.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AppUpdateOptions$Builder?> get nullableType =>
      const $AppUpdateOptions$Builder$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AppUpdateOptions$Builder$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AppUpdateOptions$Builder$Type) &&
        other is $AppUpdateOptions$Builder$Type;
  }
}

/// from: `com.google.android.play.core.appupdate.AppUpdateOptions`
class AppUpdateOptions extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<AppUpdateOptions> $type;

  @jni$_.internal
  AppUpdateOptions.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/google/android/play/core/appupdate/AppUpdateOptions');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $AppUpdateOptions$NullableType();
  static const type = $AppUpdateOptions$Type();
  static final _id_appUpdateType = _class.instanceMethodId(
    r'appUpdateType',
    r'()I',
  );

  static final _appUpdateType = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract int appUpdateType()`
  int appUpdateType() {
    return _appUpdateType(
            reference.pointer, _id_appUpdateType as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_newBuilder = _class.staticMethodId(
    r'newBuilder',
    r'(I)Lcom/google/android/play/core/appupdate/AppUpdateOptions$Builder;',
  );

  static final _newBuilder = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public com.google.android.play.core.appupdate.AppUpdateOptions$Builder newBuilder(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static AppUpdateOptions$Builder newBuilder(
    int i,
  ) {
    return _newBuilder(
            _class.reference.pointer, _id_newBuilder as jni$_.JMethodIDPtr, i)
        .object<AppUpdateOptions$Builder>(
            const $AppUpdateOptions$Builder$Type());
  }

  static final _id_defaultOptions = _class.staticMethodId(
    r'defaultOptions',
    r'(I)Lcom/google/android/play/core/appupdate/AppUpdateOptions;',
  );

  static final _defaultOptions = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public com.google.android.play.core.appupdate.AppUpdateOptions defaultOptions(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static AppUpdateOptions defaultOptions(
    int i,
  ) {
    return _defaultOptions(_class.reference.pointer,
            _id_defaultOptions as jni$_.JMethodIDPtr, i)
        .object<AppUpdateOptions>(const $AppUpdateOptions$Type());
  }

  static final _id_allowAssetPackDeletion = _class.instanceMethodId(
    r'allowAssetPackDeletion',
    r'()Z',
  );

  static final _allowAssetPackDeletion = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract boolean allowAssetPackDeletion()`
  bool allowAssetPackDeletion() {
    return _allowAssetPackDeletion(
            reference.pointer, _id_allowAssetPackDeletion as jni$_.JMethodIDPtr)
        .boolean;
  }
}

final class $AppUpdateOptions$NullableType
    extends jni$_.JObjType<AppUpdateOptions?> {
  @jni$_.internal
  const $AppUpdateOptions$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/appupdate/AppUpdateOptions;';

  @jni$_.internal
  @core$_.override
  AppUpdateOptions? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : AppUpdateOptions.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AppUpdateOptions?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AppUpdateOptions$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AppUpdateOptions$NullableType) &&
        other is $AppUpdateOptions$NullableType;
  }
}

final class $AppUpdateOptions$Type extends jni$_.JObjType<AppUpdateOptions> {
  @jni$_.internal
  const $AppUpdateOptions$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/appupdate/AppUpdateOptions;';

  @jni$_.internal
  @core$_.override
  AppUpdateOptions fromReference(jni$_.JReference reference) =>
      AppUpdateOptions.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AppUpdateOptions?> get nullableType =>
      const $AppUpdateOptions$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AppUpdateOptions$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AppUpdateOptions$Type) &&
        other is $AppUpdateOptions$Type;
  }
}

/// from: `com.google.android.play.core.install.model.AppUpdateType`
class AppUpdateType extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<AppUpdateType> $type;

  @jni$_.internal
  AppUpdateType.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/google/android/play/core/install/model/AppUpdateType');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $AppUpdateType$NullableType();
  static const type = $AppUpdateType$Type();

  /// from: `static public final int FLEXIBLE`
  static const FLEXIBLE = 0;

  /// from: `static public final int IMMEDIATE`
  static const IMMEDIATE = 1;

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $AppUpdateType> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $AppUpdateType $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.google.android.play.core.install.model.AppUpdateType',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory AppUpdateType.implement(
    $AppUpdateType $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return AppUpdateType.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $AppUpdateType {
  factory $AppUpdateType() = _$AppUpdateType;
}

final class _$AppUpdateType with $AppUpdateType {
  _$AppUpdateType();
}

final class $AppUpdateType$NullableType extends jni$_.JObjType<AppUpdateType?> {
  @jni$_.internal
  const $AppUpdateType$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/install/model/AppUpdateType;';

  @jni$_.internal
  @core$_.override
  AppUpdateType? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : AppUpdateType.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AppUpdateType?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AppUpdateType$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AppUpdateType$NullableType) &&
        other is $AppUpdateType$NullableType;
  }
}

final class $AppUpdateType$Type extends jni$_.JObjType<AppUpdateType> {
  @jni$_.internal
  const $AppUpdateType$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/install/model/AppUpdateType;';

  @jni$_.internal
  @core$_.override
  AppUpdateType fromReference(jni$_.JReference reference) =>
      AppUpdateType.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AppUpdateType?> get nullableType =>
      const $AppUpdateType$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AppUpdateType$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AppUpdateType$Type) &&
        other is $AppUpdateType$Type;
  }
}

/// from: `com.google.android.play.core.install.model.InstallStatus`
class InstallStatus extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InstallStatus> $type;

  @jni$_.internal
  InstallStatus.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/google/android/play/core/install/model/InstallStatus');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InstallStatus$NullableType();
  static const type = $InstallStatus$Type();

  /// from: `static public final int UNKNOWN`
  static const UNKNOWN = 0;

  /// from: `static public final int REQUIRES_UI_INTENT`
  static const REQUIRES_UI_INTENT = 10;

  /// from: `static public final int PENDING`
  static const PENDING = 1;

  /// from: `static public final int DOWNLOADING`
  static const DOWNLOADING = 2;

  /// from: `static public final int DOWNLOADED`
  static const DOWNLOADED = 11;

  /// from: `static public final int INSTALLING`
  static const INSTALLING = 3;

  /// from: `static public final int INSTALLED`
  static const INSTALLED = 4;

  /// from: `static public final int FAILED`
  static const FAILED = 5;

  /// from: `static public final int CANCELED`
  static const CANCELED = 6;

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $InstallStatus> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $InstallStatus $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.google.android.play.core.install.model.InstallStatus',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory InstallStatus.implement(
    $InstallStatus $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return InstallStatus.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $InstallStatus {
  factory $InstallStatus() = _$InstallStatus;
}

final class _$InstallStatus with $InstallStatus {
  _$InstallStatus();
}

final class $InstallStatus$NullableType extends jni$_.JObjType<InstallStatus?> {
  @jni$_.internal
  const $InstallStatus$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/install/model/InstallStatus;';

  @jni$_.internal
  @core$_.override
  InstallStatus? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : InstallStatus.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InstallStatus?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InstallStatus$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InstallStatus$NullableType) &&
        other is $InstallStatus$NullableType;
  }
}

final class $InstallStatus$Type extends jni$_.JObjType<InstallStatus> {
  @jni$_.internal
  const $InstallStatus$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/install/model/InstallStatus;';

  @jni$_.internal
  @core$_.override
  InstallStatus fromReference(jni$_.JReference reference) =>
      InstallStatus.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InstallStatus?> get nullableType =>
      const $InstallStatus$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InstallStatus$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InstallStatus$Type) &&
        other is $InstallStatus$Type;
  }
}

/// from: `com.google.android.play.core.install.model.InstallErrorCode`
class InstallErrorCode extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InstallErrorCode> $type;

  @jni$_.internal
  InstallErrorCode.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/google/android/play/core/install/model/InstallErrorCode');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InstallErrorCode$NullableType();
  static const type = $InstallErrorCode$Type();

  /// from: `static public final int NO_ERROR`
  static const NO_ERROR = 0;

  /// from: `static public final int NO_ERROR_PARTIALLY_ALLOWED`
  static const NO_ERROR_PARTIALLY_ALLOWED = 1;

  /// from: `static public final int ERROR_UNKNOWN`
  static const ERROR_UNKNOWN = -2;

  /// from: `static public final int ERROR_API_NOT_AVAILABLE`
  static const ERROR_API_NOT_AVAILABLE = -3;

  /// from: `static public final int ERROR_INVALID_REQUEST`
  static const ERROR_INVALID_REQUEST = -4;

  /// from: `static public final int ERROR_INSTALL_UNAVAILABLE`
  static const ERROR_INSTALL_UNAVAILABLE = -5;

  /// from: `static public final int ERROR_INSTALL_NOT_ALLOWED`
  static const ERROR_INSTALL_NOT_ALLOWED = -6;

  /// from: `static public final int ERROR_DOWNLOAD_NOT_PRESENT`
  static const ERROR_DOWNLOAD_NOT_PRESENT = -7;

  /// from: `static public final int ERROR_PLAY_STORE_NOT_FOUND`
  static const ERROR_PLAY_STORE_NOT_FOUND = -9;

  /// from: `static public final int ERROR_APP_NOT_OWNED`
  static const ERROR_APP_NOT_OWNED = -10;

  /// from: `static public final int ERROR_INTERNAL_ERROR`
  static const ERROR_INTERNAL_ERROR = -100;

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $InstallErrorCode> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $InstallErrorCode $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.google.android.play.core.install.model.InstallErrorCode',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory InstallErrorCode.implement(
    $InstallErrorCode $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return InstallErrorCode.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $InstallErrorCode {
  factory $InstallErrorCode() = _$InstallErrorCode;
}

final class _$InstallErrorCode with $InstallErrorCode {
  _$InstallErrorCode();
}

final class $InstallErrorCode$NullableType
    extends jni$_.JObjType<InstallErrorCode?> {
  @jni$_.internal
  const $InstallErrorCode$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/install/model/InstallErrorCode;';

  @jni$_.internal
  @core$_.override
  InstallErrorCode? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : InstallErrorCode.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InstallErrorCode?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InstallErrorCode$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InstallErrorCode$NullableType) &&
        other is $InstallErrorCode$NullableType;
  }
}

final class $InstallErrorCode$Type extends jni$_.JObjType<InstallErrorCode> {
  @jni$_.internal
  const $InstallErrorCode$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/install/model/InstallErrorCode;';

  @jni$_.internal
  @core$_.override
  InstallErrorCode fromReference(jni$_.JReference reference) =>
      InstallErrorCode.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InstallErrorCode?> get nullableType =>
      const $InstallErrorCode$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InstallErrorCode$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InstallErrorCode$Type) &&
        other is $InstallErrorCode$Type;
  }
}

/// from: `com.google.android.play.core.install.model.UpdateAvailability`
class UpdateAvailability extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<UpdateAvailability> $type;

  @jni$_.internal
  UpdateAvailability.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/google/android/play/core/install/model/UpdateAvailability');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $UpdateAvailability$NullableType();
  static const type = $UpdateAvailability$Type();

  /// from: `static public final int UNKNOWN`
  static const UNKNOWN = 0;

  /// from: `static public final int UPDATE_NOT_AVAILABLE`
  static const UPDATE_NOT_AVAILABLE = 1;

  /// from: `static public final int UPDATE_AVAILABLE`
  static const UPDATE_AVAILABLE = 2;

  /// from: `static public final int DEVELOPER_TRIGGERED_UPDATE_IN_PROGRESS`
  static const DEVELOPER_TRIGGERED_UPDATE_IN_PROGRESS = 3;

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $UpdateAvailability> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $UpdateAvailability $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.google.android.play.core.install.model.UpdateAvailability',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory UpdateAvailability.implement(
    $UpdateAvailability $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return UpdateAvailability.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $UpdateAvailability {
  factory $UpdateAvailability() = _$UpdateAvailability;
}

final class _$UpdateAvailability with $UpdateAvailability {
  _$UpdateAvailability();
}

final class $UpdateAvailability$NullableType
    extends jni$_.JObjType<UpdateAvailability?> {
  @jni$_.internal
  const $UpdateAvailability$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/install/model/UpdateAvailability;';

  @jni$_.internal
  @core$_.override
  UpdateAvailability? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : UpdateAvailability.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<UpdateAvailability?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UpdateAvailability$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UpdateAvailability$NullableType) &&
        other is $UpdateAvailability$NullableType;
  }
}

final class $UpdateAvailability$Type
    extends jni$_.JObjType<UpdateAvailability> {
  @jni$_.internal
  const $UpdateAvailability$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/install/model/UpdateAvailability;';

  @jni$_.internal
  @core$_.override
  UpdateAvailability fromReference(jni$_.JReference reference) =>
      UpdateAvailability.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<UpdateAvailability?> get nullableType =>
      const $UpdateAvailability$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UpdateAvailability$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UpdateAvailability$Type) &&
        other is $UpdateAvailability$Type;
  }
}

/// from: `com.google.android.play.core.install.model.UpdatePrecondition`
class UpdatePrecondition extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<UpdatePrecondition> $type;

  @jni$_.internal
  UpdatePrecondition.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/google/android/play/core/install/model/UpdatePrecondition');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $UpdatePrecondition$NullableType();
  static const type = $UpdatePrecondition$Type();

  /// from: `static public final int UNKNOWN`
  static const UNKNOWN = 0;

  /// from: `static public final int CANNOT_DISPLAY`
  static const CANNOT_DISPLAY = 1;

  /// from: `static public final int NEED_STORE_TO_PROCEED`
  static const NEED_STORE_TO_PROCEED = 2;

  /// from: `static public final int INSUFFICIENT_STORAGE`
  static const INSUFFICIENT_STORAGE = 3;

  /// from: `static public final int DEVICE_STATUS`
  static const DEVICE_STATUS = 4;

  /// from: `static public final int APP_VERSION_FRESH`
  static const APP_VERSION_FRESH = 5;

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $UpdatePrecondition> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $UpdatePrecondition $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.google.android.play.core.install.model.UpdatePrecondition',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory UpdatePrecondition.implement(
    $UpdatePrecondition $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return UpdatePrecondition.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $UpdatePrecondition {
  factory $UpdatePrecondition() = _$UpdatePrecondition;
}

final class _$UpdatePrecondition with $UpdatePrecondition {
  _$UpdatePrecondition();
}

final class $UpdatePrecondition$NullableType
    extends jni$_.JObjType<UpdatePrecondition?> {
  @jni$_.internal
  const $UpdatePrecondition$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/install/model/UpdatePrecondition;';

  @jni$_.internal
  @core$_.override
  UpdatePrecondition? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : UpdatePrecondition.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<UpdatePrecondition?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UpdatePrecondition$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UpdatePrecondition$NullableType) &&
        other is $UpdatePrecondition$NullableType;
  }
}

final class $UpdatePrecondition$Type
    extends jni$_.JObjType<UpdatePrecondition> {
  @jni$_.internal
  const $UpdatePrecondition$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/install/model/UpdatePrecondition;';

  @jni$_.internal
  @core$_.override
  UpdatePrecondition fromReference(jni$_.JReference reference) =>
      UpdatePrecondition.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<UpdatePrecondition?> get nullableType =>
      const $UpdatePrecondition$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UpdatePrecondition$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UpdatePrecondition$Type) &&
        other is $UpdatePrecondition$Type;
  }
}

/// from: `com.google.android.play.core.install.model.ActivityResult`
class ActivityResult extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ActivityResult> $type;

  @jni$_.internal
  ActivityResult.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/google/android/play/core/install/model/ActivityResult');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ActivityResult$NullableType();
  static const type = $ActivityResult$Type();

  /// from: `static public final int RESULT_IN_APP_UPDATE_FAILED`
  static const RESULT_IN_APP_UPDATE_FAILED = 1;
}

final class $ActivityResult$NullableType
    extends jni$_.JObjType<ActivityResult?> {
  @jni$_.internal
  const $ActivityResult$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/install/model/ActivityResult;';

  @jni$_.internal
  @core$_.override
  ActivityResult? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : ActivityResult.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ActivityResult?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ActivityResult$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ActivityResult$NullableType) &&
        other is $ActivityResult$NullableType;
  }
}

final class $ActivityResult$Type extends jni$_.JObjType<ActivityResult> {
  @jni$_.internal
  const $ActivityResult$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/install/model/ActivityResult;';

  @jni$_.internal
  @core$_.override
  ActivityResult fromReference(jni$_.JReference reference) =>
      ActivityResult.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ActivityResult?> get nullableType =>
      const $ActivityResult$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ActivityResult$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ActivityResult$Type) &&
        other is $ActivityResult$Type;
  }
}

/// from: `com.google.android.play.core.install.InstallStateUpdatedListener`
class InstallStateUpdatedListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InstallStateUpdatedListener> $type;

  @jni$_.internal
  InstallStateUpdatedListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/google/android/play/core/install/InstallStateUpdatedListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InstallStateUpdatedListener$NullableType();
  static const type = $InstallStateUpdatedListener$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $InstallStateUpdatedListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $InstallStateUpdatedListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.google.android.play.core.install.InstallStateUpdatedListener',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory InstallStateUpdatedListener.implement(
    $InstallStateUpdatedListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return InstallStateUpdatedListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $InstallStateUpdatedListener {
  factory $InstallStateUpdatedListener() = _$InstallStateUpdatedListener;
}

final class _$InstallStateUpdatedListener with $InstallStateUpdatedListener {
  _$InstallStateUpdatedListener();
}

final class $InstallStateUpdatedListener$NullableType
    extends jni$_.JObjType<InstallStateUpdatedListener?> {
  @jni$_.internal
  const $InstallStateUpdatedListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/install/InstallStateUpdatedListener;';

  @jni$_.internal
  @core$_.override
  InstallStateUpdatedListener? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : InstallStateUpdatedListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InstallStateUpdatedListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InstallStateUpdatedListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InstallStateUpdatedListener$NullableType) &&
        other is $InstallStateUpdatedListener$NullableType;
  }
}

final class $InstallStateUpdatedListener$Type
    extends jni$_.JObjType<InstallStateUpdatedListener> {
  @jni$_.internal
  const $InstallStateUpdatedListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/install/InstallStateUpdatedListener;';

  @jni$_.internal
  @core$_.override
  InstallStateUpdatedListener fromReference(jni$_.JReference reference) =>
      InstallStateUpdatedListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InstallStateUpdatedListener?> get nullableType =>
      const $InstallStateUpdatedListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InstallStateUpdatedListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InstallStateUpdatedListener$Type) &&
        other is $InstallStateUpdatedListener$Type;
  }
}

/// from: `com.google.android.play.core.listener.StateUpdatedListener`
class StateUpdatedListener<$StateT extends jni$_.JObject?>
    extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StateUpdatedListener<$StateT>> $type;

  @jni$_.internal
  final jni$_.JObjType<$StateT> StateT;

  @jni$_.internal
  StateUpdatedListener.fromReference(
    this.StateT,
    jni$_.JReference reference,
  )   : $type = type<$StateT>(StateT),
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/google/android/play/core/listener/StateUpdatedListener');

  /// The type which includes information such as the signature of this class.
  static $StateUpdatedListener$NullableType<$StateT>
      nullableType<$StateT extends jni$_.JObject?>(
    jni$_.JObjType<$StateT> StateT,
  ) {
    return $StateUpdatedListener$NullableType<$StateT>(
      StateT,
    );
  }

  static $StateUpdatedListener$Type<$StateT>
      type<$StateT extends jni$_.JObject?>(
    jni$_.JObjType<$StateT> StateT,
  ) {
    return $StateUpdatedListener$Type<$StateT>(
      StateT,
    );
  }

  static final _id_onStateUpdate = _class.instanceMethodId(
    r'onStateUpdate',
    r'(Ljava/lang/Object;)V',
  );

  static final _onStateUpdate = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onStateUpdate(StateT object)`
  void onStateUpdate(
    $StateT object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _onStateUpdate(reference.pointer, _id_onStateUpdate as jni$_.JMethodIDPtr,
            _$object.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $StateUpdatedListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onStateUpdate(Ljava/lang/Object;)V') {
        _$impls[$p]!.onStateUpdate(
          $a![0]?.as(_$impls[$p]!.StateT, releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn<$StateT extends jni$_.JObject?>(
    jni$_.JImplementer implementer,
    $StateUpdatedListener<$StateT> $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.google.android.play.core.listener.StateUpdatedListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onStateUpdate$async) r'onStateUpdate(Ljava/lang/Object;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory StateUpdatedListener.implement(
    $StateUpdatedListener<$StateT> $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return StateUpdatedListener<$StateT>.fromReference(
      $impl.StateT,
      $i.implementReference(),
    );
  }
}

abstract base mixin class $StateUpdatedListener<
    $StateT extends jni$_.JObject?> {
  factory $StateUpdatedListener({
    required jni$_.JObjType<$StateT> StateT,
    required void Function($StateT object) onStateUpdate,
    bool onStateUpdate$async,
  }) = _$StateUpdatedListener<$StateT>;

  jni$_.JObjType<$StateT> get StateT;

  void onStateUpdate($StateT object);
  bool get onStateUpdate$async => false;
}

final class _$StateUpdatedListener<$StateT extends jni$_.JObject?>
    with $StateUpdatedListener<$StateT> {
  _$StateUpdatedListener({
    required this.StateT,
    required void Function($StateT object) onStateUpdate,
    this.onStateUpdate$async = false,
  }) : _onStateUpdate = onStateUpdate;

  @core$_.override
  final jni$_.JObjType<$StateT> StateT;

  final void Function($StateT object) _onStateUpdate;
  final bool onStateUpdate$async;

  void onStateUpdate($StateT object) {
    return _onStateUpdate(object);
  }
}

final class $StateUpdatedListener$NullableType<$StateT extends jni$_.JObject?>
    extends jni$_.JObjType<StateUpdatedListener<$StateT>?> {
  @jni$_.internal
  final jni$_.JObjType<$StateT> StateT;

  @jni$_.internal
  const $StateUpdatedListener$NullableType(
    this.StateT,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/listener/StateUpdatedListener;';

  @jni$_.internal
  @core$_.override
  StateUpdatedListener<$StateT>? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : StateUpdatedListener<$StateT>.fromReference(
              StateT,
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StateUpdatedListener<$StateT>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($StateUpdatedListener$NullableType, StateT);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StateUpdatedListener$NullableType<$StateT>) &&
        other is $StateUpdatedListener$NullableType<$StateT> &&
        StateT == other.StateT;
  }
}

final class $StateUpdatedListener$Type<$StateT extends jni$_.JObject?>
    extends jni$_.JObjType<StateUpdatedListener<$StateT>> {
  @jni$_.internal
  final jni$_.JObjType<$StateT> StateT;

  @jni$_.internal
  const $StateUpdatedListener$Type(
    this.StateT,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/listener/StateUpdatedListener;';

  @jni$_.internal
  @core$_.override
  StateUpdatedListener<$StateT> fromReference(jni$_.JReference reference) =>
      StateUpdatedListener<$StateT>.fromReference(
        StateT,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StateUpdatedListener<$StateT>?> get nullableType =>
      $StateUpdatedListener$NullableType<$StateT>(StateT);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($StateUpdatedListener$Type, StateT);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StateUpdatedListener$Type<$StateT>) &&
        other is $StateUpdatedListener$Type<$StateT> &&
        StateT == other.StateT;
  }
}

/// from: `com.google.android.play.core.install.InstallState`
class InstallState extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InstallState> $type;

  @jni$_.internal
  InstallState.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/google/android/play/core/install/InstallState');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InstallState$NullableType();
  static const type = $InstallState$Type();
  static final _id_installErrorCode = _class.instanceMethodId(
    r'installErrorCode',
    r'()I',
  );

  static final _installErrorCode = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract int installErrorCode()`
  int installErrorCode() {
    return _installErrorCode(
            reference.pointer, _id_installErrorCode as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_installStatus = _class.instanceMethodId(
    r'installStatus',
    r'()I',
  );

  static final _installStatus = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract int installStatus()`
  int installStatus() {
    return _installStatus(
            reference.pointer, _id_installStatus as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_bytesDownloaded = _class.instanceMethodId(
    r'bytesDownloaded',
    r'()J',
  );

  static final _bytesDownloaded = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract long bytesDownloaded()`
  int bytesDownloaded() {
    return _bytesDownloaded(
            reference.pointer, _id_bytesDownloaded as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_totalBytesToDownload = _class.instanceMethodId(
    r'totalBytesToDownload',
    r'()J',
  );

  static final _totalBytesToDownload = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract long totalBytesToDownload()`
  int totalBytesToDownload() {
    return _totalBytesToDownload(
            reference.pointer, _id_totalBytesToDownload as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_packageName = _class.instanceMethodId(
    r'packageName',
    r'()Ljava/lang/String;',
  );

  static final _packageName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.String packageName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? packageName() {
    return _packageName(
            reference.pointer, _id_packageName as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_zza = _class.staticMethodId(
    r'zza',
    r'(IJJILjava/lang/String;)Lcom/google/android/play/core/install/InstallState;',
  );

  static final _zza = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public com.google.android.play.core.install.InstallState zza(int i, long j, long j1, int i1, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static InstallState? zza(
    int i,
    int j,
    int j1,
    int i1,
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _zza(_class.reference.pointer, _id_zza as jni$_.JMethodIDPtr, i, j,
            j1, i1, _$string.pointer)
        .object<InstallState?>(const $InstallState$NullableType());
  }

  static final _id_zzb = _class.staticMethodId(
    r'zzb',
    r'(Landroid/content/Intent;Lcom/google/android/play/core/appupdate/internal/zzm;)Lcom/google/android/play/core/install/InstallState;',
  );

  static final _zzb = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public com.google.android.play.core.install.InstallState zzb(android.content.Intent intent, com.google.android.play.core.appupdate.internal.zzm zzm)`
  /// The returned object must be released after use, by calling the [release] method.
  static InstallState? zzb(
    jni$_.JObject intent,
    jni$_.JObject zzm,
  ) {
    final _$intent = intent.reference;
    final _$zzm = zzm.reference;
    return _zzb(_class.reference.pointer, _id_zzb as jni$_.JMethodIDPtr,
            _$intent.pointer, _$zzm.pointer)
        .object<InstallState?>(const $InstallState$NullableType());
  }
}

final class $InstallState$NullableType extends jni$_.JObjType<InstallState?> {
  @jni$_.internal
  const $InstallState$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/install/InstallState;';

  @jni$_.internal
  @core$_.override
  InstallState? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : InstallState.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InstallState?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InstallState$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InstallState$NullableType) &&
        other is $InstallState$NullableType;
  }
}

final class $InstallState$Type extends jni$_.JObjType<InstallState> {
  @jni$_.internal
  const $InstallState$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/install/InstallState;';

  @jni$_.internal
  @core$_.override
  InstallState fromReference(jni$_.JReference reference) =>
      InstallState.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InstallState?> get nullableType =>
      const $InstallState$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InstallState$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InstallState$Type) &&
        other is $InstallState$Type;
  }
}

/// from: `com.google.android.gms.tasks.Task`
class Task<$TResult extends jni$_.JObject?> extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Task<$TResult>> $type;

  @jni$_.internal
  final jni$_.JObjType<$TResult> TResult;

  @jni$_.internal
  Task.fromReference(
    this.TResult,
    jni$_.JReference reference,
  )   : $type = type<$TResult>(TResult),
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/google/android/gms/tasks/Task');

  /// The type which includes information such as the signature of this class.
  static $Task$NullableType<$TResult>
      nullableType<$TResult extends jni$_.JObject?>(
    jni$_.JObjType<$TResult> TResult,
  ) {
    return $Task$NullableType<$TResult>(
      TResult,
    );
  }

  static $Task$Type<$TResult> type<$TResult extends jni$_.JObject?>(
    jni$_.JObjType<$TResult> TResult,
  ) {
    return $Task$Type<$TResult>(
      TResult,
    );
  }

  static final _id_addOnCanceledListener = _class.instanceMethodId(
    r'addOnCanceledListener',
    r'(Lcom/google/android/gms/tasks/OnCanceledListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnCanceledListener = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public com.google.android.gms.tasks.Task addOnCanceledListener(com.google.android.gms.tasks.OnCanceledListener onCanceledListener)`
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult?> addOnCanceledListener(
    OnCanceledListener onCanceledListener,
  ) {
    final _$onCanceledListener = onCanceledListener.reference;
    return _addOnCanceledListener(
            reference.pointer,
            _id_addOnCanceledListener as jni$_.JMethodIDPtr,
            _$onCanceledListener.pointer)
        .object<Task<$TResult?>>($Task$Type<$TResult?>(TResult.nullableType));
  }

  static final _id_addOnCanceledListener$1 = _class.instanceMethodId(
    r'addOnCanceledListener',
    r'(Landroid/app/Activity;Lcom/google/android/gms/tasks/OnCanceledListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnCanceledListener$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public com.google.android.gms.tasks.Task addOnCanceledListener(android.app.Activity activity, com.google.android.gms.tasks.OnCanceledListener onCanceledListener)`
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult?> addOnCanceledListener$1(
    jni$_.JObject activity,
    OnCanceledListener onCanceledListener,
  ) {
    final _$activity = activity.reference;
    final _$onCanceledListener = onCanceledListener.reference;
    return _addOnCanceledListener$1(
            reference.pointer,
            _id_addOnCanceledListener$1 as jni$_.JMethodIDPtr,
            _$activity.pointer,
            _$onCanceledListener.pointer)
        .object<Task<$TResult?>>($Task$Type<$TResult?>(TResult.nullableType));
  }

  static final _id_addOnCanceledListener$2 = _class.instanceMethodId(
    r'addOnCanceledListener',
    r'(Ljava/util/concurrent/Executor;Lcom/google/android/gms/tasks/OnCanceledListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnCanceledListener$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public com.google.android.gms.tasks.Task addOnCanceledListener(java.util.concurrent.Executor executor, com.google.android.gms.tasks.OnCanceledListener onCanceledListener)`
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult?> addOnCanceledListener$2(
    jni$_.JObject executor,
    OnCanceledListener onCanceledListener,
  ) {
    final _$executor = executor.reference;
    final _$onCanceledListener = onCanceledListener.reference;
    return _addOnCanceledListener$2(
            reference.pointer,
            _id_addOnCanceledListener$2 as jni$_.JMethodIDPtr,
            _$executor.pointer,
            _$onCanceledListener.pointer)
        .object<Task<$TResult?>>($Task$Type<$TResult?>(TResult.nullableType));
  }

  static final _id_addOnCompleteListener = _class.instanceMethodId(
    r'addOnCompleteListener',
    r'(Lcom/google/android/gms/tasks/OnCompleteListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnCompleteListener = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public com.google.android.gms.tasks.Task addOnCompleteListener(com.google.android.gms.tasks.OnCompleteListener onCompleteListener)`
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult?> addOnCompleteListener(
    OnCompleteListener<$TResult?> onCompleteListener,
  ) {
    final _$onCompleteListener = onCompleteListener.reference;
    return _addOnCompleteListener(
            reference.pointer,
            _id_addOnCompleteListener as jni$_.JMethodIDPtr,
            _$onCompleteListener.pointer)
        .object<Task<$TResult?>>($Task$Type<$TResult?>(TResult.nullableType));
  }

  static final _id_addOnCompleteListener$1 = _class.instanceMethodId(
    r'addOnCompleteListener',
    r'(Landroid/app/Activity;Lcom/google/android/gms/tasks/OnCompleteListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnCompleteListener$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public com.google.android.gms.tasks.Task addOnCompleteListener(android.app.Activity activity, com.google.android.gms.tasks.OnCompleteListener onCompleteListener)`
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult?> addOnCompleteListener$1(
    jni$_.JObject activity,
    OnCompleteListener<$TResult?> onCompleteListener,
  ) {
    final _$activity = activity.reference;
    final _$onCompleteListener = onCompleteListener.reference;
    return _addOnCompleteListener$1(
            reference.pointer,
            _id_addOnCompleteListener$1 as jni$_.JMethodIDPtr,
            _$activity.pointer,
            _$onCompleteListener.pointer)
        .object<Task<$TResult?>>($Task$Type<$TResult?>(TResult.nullableType));
  }

  static final _id_addOnCompleteListener$2 = _class.instanceMethodId(
    r'addOnCompleteListener',
    r'(Ljava/util/concurrent/Executor;Lcom/google/android/gms/tasks/OnCompleteListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnCompleteListener$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public com.google.android.gms.tasks.Task addOnCompleteListener(java.util.concurrent.Executor executor, com.google.android.gms.tasks.OnCompleteListener onCompleteListener)`
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult?> addOnCompleteListener$2(
    jni$_.JObject executor,
    OnCompleteListener<$TResult?> onCompleteListener,
  ) {
    final _$executor = executor.reference;
    final _$onCompleteListener = onCompleteListener.reference;
    return _addOnCompleteListener$2(
            reference.pointer,
            _id_addOnCompleteListener$2 as jni$_.JMethodIDPtr,
            _$executor.pointer,
            _$onCompleteListener.pointer)
        .object<Task<$TResult?>>($Task$Type<$TResult?>(TResult.nullableType));
  }

  static final _id_addOnFailureListener = _class.instanceMethodId(
    r'addOnFailureListener',
    r'(Lcom/google/android/gms/tasks/OnFailureListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnFailureListener = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract com.google.android.gms.tasks.Task addOnFailureListener(com.google.android.gms.tasks.OnFailureListener onFailureListener)`
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult?> addOnFailureListener(
    OnFailureListener onFailureListener,
  ) {
    final _$onFailureListener = onFailureListener.reference;
    return _addOnFailureListener(
            reference.pointer,
            _id_addOnFailureListener as jni$_.JMethodIDPtr,
            _$onFailureListener.pointer)
        .object<Task<$TResult?>>($Task$Type<$TResult?>(TResult.nullableType));
  }

  static final _id_addOnFailureListener$1 = _class.instanceMethodId(
    r'addOnFailureListener',
    r'(Landroid/app/Activity;Lcom/google/android/gms/tasks/OnFailureListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnFailureListener$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract com.google.android.gms.tasks.Task addOnFailureListener(android.app.Activity activity, com.google.android.gms.tasks.OnFailureListener onFailureListener)`
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult?> addOnFailureListener$1(
    jni$_.JObject activity,
    OnFailureListener onFailureListener,
  ) {
    final _$activity = activity.reference;
    final _$onFailureListener = onFailureListener.reference;
    return _addOnFailureListener$1(
            reference.pointer,
            _id_addOnFailureListener$1 as jni$_.JMethodIDPtr,
            _$activity.pointer,
            _$onFailureListener.pointer)
        .object<Task<$TResult?>>($Task$Type<$TResult?>(TResult.nullableType));
  }

  static final _id_addOnFailureListener$2 = _class.instanceMethodId(
    r'addOnFailureListener',
    r'(Ljava/util/concurrent/Executor;Lcom/google/android/gms/tasks/OnFailureListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnFailureListener$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract com.google.android.gms.tasks.Task addOnFailureListener(java.util.concurrent.Executor executor, com.google.android.gms.tasks.OnFailureListener onFailureListener)`
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult?> addOnFailureListener$2(
    jni$_.JObject executor,
    OnFailureListener onFailureListener,
  ) {
    final _$executor = executor.reference;
    final _$onFailureListener = onFailureListener.reference;
    return _addOnFailureListener$2(
            reference.pointer,
            _id_addOnFailureListener$2 as jni$_.JMethodIDPtr,
            _$executor.pointer,
            _$onFailureListener.pointer)
        .object<Task<$TResult?>>($Task$Type<$TResult?>(TResult.nullableType));
  }

  static final _id_addOnSuccessListener = _class.instanceMethodId(
    r'addOnSuccessListener',
    r'(Lcom/google/android/gms/tasks/OnSuccessListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnSuccessListener = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract com.google.android.gms.tasks.Task addOnSuccessListener(com.google.android.gms.tasks.OnSuccessListener onSuccessListener)`
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult?> addOnSuccessListener(
    OnSuccessListener<jni$_.JObject?> onSuccessListener,
  ) {
    final _$onSuccessListener = onSuccessListener.reference;
    return _addOnSuccessListener(
            reference.pointer,
            _id_addOnSuccessListener as jni$_.JMethodIDPtr,
            _$onSuccessListener.pointer)
        .object<Task<$TResult?>>($Task$Type<$TResult?>(TResult.nullableType));
  }

  static final _id_addOnSuccessListener$1 = _class.instanceMethodId(
    r'addOnSuccessListener',
    r'(Landroid/app/Activity;Lcom/google/android/gms/tasks/OnSuccessListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnSuccessListener$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract com.google.android.gms.tasks.Task addOnSuccessListener(android.app.Activity activity, com.google.android.gms.tasks.OnSuccessListener onSuccessListener)`
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult?> addOnSuccessListener$1(
    jni$_.JObject activity,
    OnSuccessListener<jni$_.JObject?> onSuccessListener,
  ) {
    final _$activity = activity.reference;
    final _$onSuccessListener = onSuccessListener.reference;
    return _addOnSuccessListener$1(
            reference.pointer,
            _id_addOnSuccessListener$1 as jni$_.JMethodIDPtr,
            _$activity.pointer,
            _$onSuccessListener.pointer)
        .object<Task<$TResult?>>($Task$Type<$TResult?>(TResult.nullableType));
  }

  static final _id_addOnSuccessListener$2 = _class.instanceMethodId(
    r'addOnSuccessListener',
    r'(Ljava/util/concurrent/Executor;Lcom/google/android/gms/tasks/OnSuccessListener;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _addOnSuccessListener$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract com.google.android.gms.tasks.Task addOnSuccessListener(java.util.concurrent.Executor executor, com.google.android.gms.tasks.OnSuccessListener onSuccessListener)`
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult?> addOnSuccessListener$2(
    jni$_.JObject executor,
    OnSuccessListener<jni$_.JObject?> onSuccessListener,
  ) {
    final _$executor = executor.reference;
    final _$onSuccessListener = onSuccessListener.reference;
    return _addOnSuccessListener$2(
            reference.pointer,
            _id_addOnSuccessListener$2 as jni$_.JMethodIDPtr,
            _$executor.pointer,
            _$onSuccessListener.pointer)
        .object<Task<$TResult?>>($Task$Type<$TResult?>(TResult.nullableType));
  }

  static final _id_continueWith = _class.instanceMethodId(
    r'continueWith',
    r'(Lcom/google/android/gms/tasks/Continuation;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _continueWith = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public com.google.android.gms.tasks.Task continueWith(com.google.android.gms.tasks.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult?>
      continueWith<$TContinuationResult extends jni$_.JObject?>(
    jni$_.JObject continuation, {
    required jni$_.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    final _$continuation = continuation.reference;
    return _continueWith(reference.pointer,
            _id_continueWith as jni$_.JMethodIDPtr, _$continuation.pointer)
        .object<Task<$TContinuationResult?>>($Task$Type<$TContinuationResult?>(
            TContinuationResult.nullableType));
  }

  static final _id_continueWith$1 = _class.instanceMethodId(
    r'continueWith',
    r'(Ljava/util/concurrent/Executor;Lcom/google/android/gms/tasks/Continuation;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _continueWith$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public com.google.android.gms.tasks.Task continueWith(java.util.concurrent.Executor executor, com.google.android.gms.tasks.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult?>
      continueWith$1<$TContinuationResult extends jni$_.JObject?>(
    jni$_.JObject executor,
    jni$_.JObject continuation, {
    required jni$_.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    final _$executor = executor.reference;
    final _$continuation = continuation.reference;
    return _continueWith$1(
            reference.pointer,
            _id_continueWith$1 as jni$_.JMethodIDPtr,
            _$executor.pointer,
            _$continuation.pointer)
        .object<Task<$TContinuationResult?>>($Task$Type<$TContinuationResult?>(
            TContinuationResult.nullableType));
  }

  static final _id_continueWithTask = _class.instanceMethodId(
    r'continueWithTask',
    r'(Lcom/google/android/gms/tasks/Continuation;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _continueWithTask = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public com.google.android.gms.tasks.Task continueWithTask(com.google.android.gms.tasks.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult?>
      continueWithTask<$TContinuationResult extends jni$_.JObject?>(
    jni$_.JObject continuation, {
    required jni$_.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    final _$continuation = continuation.reference;
    return _continueWithTask(reference.pointer,
            _id_continueWithTask as jni$_.JMethodIDPtr, _$continuation.pointer)
        .object<Task<$TContinuationResult?>>($Task$Type<$TContinuationResult?>(
            TContinuationResult.nullableType));
  }

  static final _id_continueWithTask$1 = _class.instanceMethodId(
    r'continueWithTask',
    r'(Ljava/util/concurrent/Executor;Lcom/google/android/gms/tasks/Continuation;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _continueWithTask$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public com.google.android.gms.tasks.Task continueWithTask(java.util.concurrent.Executor executor, com.google.android.gms.tasks.Continuation continuation)`
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult?>
      continueWithTask$1<$TContinuationResult extends jni$_.JObject?>(
    jni$_.JObject executor,
    jni$_.JObject continuation, {
    required jni$_.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    final _$executor = executor.reference;
    final _$continuation = continuation.reference;
    return _continueWithTask$1(
            reference.pointer,
            _id_continueWithTask$1 as jni$_.JMethodIDPtr,
            _$executor.pointer,
            _$continuation.pointer)
        .object<Task<$TContinuationResult?>>($Task$Type<$TContinuationResult?>(
            TContinuationResult.nullableType));
  }

  static final _id_onSuccessTask = _class.instanceMethodId(
    r'onSuccessTask',
    r'(Lcom/google/android/gms/tasks/SuccessContinuation;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _onSuccessTask = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public com.google.android.gms.tasks.Task onSuccessTask(com.google.android.gms.tasks.SuccessContinuation successContinuation)`
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult?>
      onSuccessTask<$TContinuationResult extends jni$_.JObject?>(
    jni$_.JObject successContinuation, {
    required jni$_.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    final _$successContinuation = successContinuation.reference;
    return _onSuccessTask(
            reference.pointer,
            _id_onSuccessTask as jni$_.JMethodIDPtr,
            _$successContinuation.pointer)
        .object<Task<$TContinuationResult?>>($Task$Type<$TContinuationResult?>(
            TContinuationResult.nullableType));
  }

  static final _id_onSuccessTask$1 = _class.instanceMethodId(
    r'onSuccessTask',
    r'(Ljava/util/concurrent/Executor;Lcom/google/android/gms/tasks/SuccessContinuation;)Lcom/google/android/gms/tasks/Task;',
  );

  static final _onSuccessTask$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public com.google.android.gms.tasks.Task onSuccessTask(java.util.concurrent.Executor executor, com.google.android.gms.tasks.SuccessContinuation successContinuation)`
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult?>
      onSuccessTask$1<$TContinuationResult extends jni$_.JObject?>(
    jni$_.JObject executor,
    jni$_.JObject successContinuation, {
    required jni$_.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    final _$executor = executor.reference;
    final _$successContinuation = successContinuation.reference;
    return _onSuccessTask$1(
            reference.pointer,
            _id_onSuccessTask$1 as jni$_.JMethodIDPtr,
            _$executor.pointer,
            _$successContinuation.pointer)
        .object<Task<$TContinuationResult?>>($Task$Type<$TContinuationResult?>(
            TContinuationResult.nullableType));
  }

  static final _id_getException = _class.instanceMethodId(
    r'getException',
    r'()Ljava/lang/Exception;',
  );

  static final _getException = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.Exception getException()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getException() {
    return _getException(
            reference.pointer, _id_getException as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getResult = _class.instanceMethodId(
    r'getResult',
    r'()Ljava/lang/Object;',
  );

  static final _getResult = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract TResult getResult()`
  /// The returned object must be released after use, by calling the [release] method.
  $TResult? getResult() {
    return _getResult(reference.pointer, _id_getResult as jni$_.JMethodIDPtr)
        .object<$TResult?>(TResult.nullableType);
  }

  static final _id_getResult$1 = _class.instanceMethodId(
    r'getResult',
    r'(Ljava/lang/Class;)Ljava/lang/Object;',
  );

  static final _getResult$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract TResult getResult(java.lang.Class class)`
  /// The returned object must be released after use, by calling the [release] method.
  $TResult? getResult$1<$X extends jni$_.JObject?>(
    jni$_.JObject class$, {
    required jni$_.JObjType<$X> X,
  }) {
    final _$class$ = class$.reference;
    return _getResult$1(reference.pointer,
            _id_getResult$1 as jni$_.JMethodIDPtr, _$class$.pointer)
        .object<$TResult?>(TResult.nullableType);
  }

  static final _id_isCanceled = _class.instanceMethodId(
    r'isCanceled',
    r'()Z',
  );

  static final _isCanceled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract boolean isCanceled()`
  bool isCanceled() {
    return _isCanceled(reference.pointer, _id_isCanceled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_isComplete = _class.instanceMethodId(
    r'isComplete',
    r'()Z',
  );

  static final _isComplete = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract boolean isComplete()`
  bool isComplete() {
    return _isComplete(reference.pointer, _id_isComplete as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_isSuccessful = _class.instanceMethodId(
    r'isSuccessful',
    r'()Z',
  );

  static final _isSuccessful = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract boolean isSuccessful()`
  bool isSuccessful() {
    return _isSuccessful(
            reference.pointer, _id_isSuccessful as jni$_.JMethodIDPtr)
        .boolean;
  }
}

final class $Task$NullableType<$TResult extends jni$_.JObject?>
    extends jni$_.JObjType<Task<$TResult>?> {
  @jni$_.internal
  final jni$_.JObjType<$TResult> TResult;

  @jni$_.internal
  const $Task$NullableType(
    this.TResult,
  );

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/google/android/gms/tasks/Task;';

  @jni$_.internal
  @core$_.override
  Task<$TResult>? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Task<$TResult>.fromReference(
          TResult,
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Task<$TResult>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Task$NullableType, TResult);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Task$NullableType<$TResult>) &&
        other is $Task$NullableType<$TResult> &&
        TResult == other.TResult;
  }
}

final class $Task$Type<$TResult extends jni$_.JObject?>
    extends jni$_.JObjType<Task<$TResult>> {
  @jni$_.internal
  final jni$_.JObjType<$TResult> TResult;

  @jni$_.internal
  const $Task$Type(
    this.TResult,
  );

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/google/android/gms/tasks/Task;';

  @jni$_.internal
  @core$_.override
  Task<$TResult> fromReference(jni$_.JReference reference) =>
      Task<$TResult>.fromReference(
        TResult,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Task<$TResult>?> get nullableType =>
      $Task$NullableType<$TResult>(TResult);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Task$Type, TResult);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Task$Type<$TResult>) &&
        other is $Task$Type<$TResult> &&
        TResult == other.TResult;
  }
}

/// from: `com.google.android.gms.tasks.OnSuccessListener`
class OnSuccessListener<$TResult extends jni$_.JObject?> extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OnSuccessListener<$TResult>> $type;

  @jni$_.internal
  final jni$_.JObjType<$TResult> TResult;

  @jni$_.internal
  OnSuccessListener.fromReference(
    this.TResult,
    jni$_.JReference reference,
  )   : $type = type<$TResult>(TResult),
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/google/android/gms/tasks/OnSuccessListener');

  /// The type which includes information such as the signature of this class.
  static $OnSuccessListener$NullableType<$TResult>
      nullableType<$TResult extends jni$_.JObject?>(
    jni$_.JObjType<$TResult> TResult,
  ) {
    return $OnSuccessListener$NullableType<$TResult>(
      TResult,
    );
  }

  static $OnSuccessListener$Type<$TResult>
      type<$TResult extends jni$_.JObject?>(
    jni$_.JObjType<$TResult> TResult,
  ) {
    return $OnSuccessListener$Type<$TResult>(
      TResult,
    );
  }

  static final _id_onSuccess = _class.instanceMethodId(
    r'onSuccess',
    r'(Ljava/lang/Object;)V',
  );

  static final _onSuccess = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onSuccess(TResult object)`
  void onSuccess(
    $TResult? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _onSuccess(reference.pointer, _id_onSuccess as jni$_.JMethodIDPtr,
            _$object.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $OnSuccessListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onSuccess(Ljava/lang/Object;)V') {
        _$impls[$p]!.onSuccess(
          $a![0]?.as(_$impls[$p]!.TResult, releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn<$TResult extends jni$_.JObject?>(
    jni$_.JImplementer implementer,
    $OnSuccessListener<$TResult> $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.google.android.gms.tasks.OnSuccessListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onSuccess$async) r'onSuccess(Ljava/lang/Object;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory OnSuccessListener.implement(
    $OnSuccessListener<$TResult> $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return OnSuccessListener<$TResult>.fromReference(
      $impl.TResult,
      $i.implementReference(),
    );
  }
}

abstract base mixin class $OnSuccessListener<$TResult extends jni$_.JObject?> {
  factory $OnSuccessListener({
    required jni$_.JObjType<$TResult> TResult,
    required void Function($TResult? object) onSuccess,
    bool onSuccess$async,
  }) = _$OnSuccessListener<$TResult>;

  jni$_.JObjType<$TResult> get TResult;

  void onSuccess($TResult? object);
  bool get onSuccess$async => false;
}

final class _$OnSuccessListener<$TResult extends jni$_.JObject?>
    with $OnSuccessListener<$TResult> {
  _$OnSuccessListener({
    required this.TResult,
    required void Function($TResult? object) onSuccess,
    this.onSuccess$async = false,
  }) : _onSuccess = onSuccess;

  @core$_.override
  final jni$_.JObjType<$TResult> TResult;

  final void Function($TResult? object) _onSuccess;
  final bool onSuccess$async;

  void onSuccess($TResult? object) {
    return _onSuccess(object);
  }
}

final class $OnSuccessListener$NullableType<$TResult extends jni$_.JObject?>
    extends jni$_.JObjType<OnSuccessListener<$TResult>?> {
  @jni$_.internal
  final jni$_.JObjType<$TResult> TResult;

  @jni$_.internal
  const $OnSuccessListener$NullableType(
    this.TResult,
  );

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/google/android/gms/tasks/OnSuccessListener;';

  @jni$_.internal
  @core$_.override
  OnSuccessListener<$TResult>? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : OnSuccessListener<$TResult>.fromReference(
              TResult,
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OnSuccessListener<$TResult>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($OnSuccessListener$NullableType, TResult);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OnSuccessListener$NullableType<$TResult>) &&
        other is $OnSuccessListener$NullableType<$TResult> &&
        TResult == other.TResult;
  }
}

final class $OnSuccessListener$Type<$TResult extends jni$_.JObject?>
    extends jni$_.JObjType<OnSuccessListener<$TResult>> {
  @jni$_.internal
  final jni$_.JObjType<$TResult> TResult;

  @jni$_.internal
  const $OnSuccessListener$Type(
    this.TResult,
  );

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/google/android/gms/tasks/OnSuccessListener;';

  @jni$_.internal
  @core$_.override
  OnSuccessListener<$TResult> fromReference(jni$_.JReference reference) =>
      OnSuccessListener<$TResult>.fromReference(
        TResult,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OnSuccessListener<$TResult>?> get nullableType =>
      $OnSuccessListener$NullableType<$TResult>(TResult);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($OnSuccessListener$Type, TResult);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OnSuccessListener$Type<$TResult>) &&
        other is $OnSuccessListener$Type<$TResult> &&
        TResult == other.TResult;
  }
}

/// from: `com.google.android.gms.tasks.OnFailureListener`
class OnFailureListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OnFailureListener> $type;

  @jni$_.internal
  OnFailureListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/google/android/gms/tasks/OnFailureListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $OnFailureListener$NullableType();
  static const type = $OnFailureListener$Type();
  static final _id_onFailure = _class.instanceMethodId(
    r'onFailure',
    r'(Ljava/lang/Exception;)V',
  );

  static final _onFailure = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onFailure(java.lang.Exception exception)`
  void onFailure(
    jni$_.JObject exception,
  ) {
    final _$exception = exception.reference;
    _onFailure(reference.pointer, _id_onFailure as jni$_.JMethodIDPtr,
            _$exception.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $OnFailureListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onFailure(Ljava/lang/Exception;)V') {
        _$impls[$p]!.onFailure(
          $a![0]!.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $OnFailureListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.google.android.gms.tasks.OnFailureListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onFailure$async) r'onFailure(Ljava/lang/Exception;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory OnFailureListener.implement(
    $OnFailureListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return OnFailureListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $OnFailureListener {
  factory $OnFailureListener({
    required void Function(jni$_.JObject exception) onFailure,
    bool onFailure$async,
  }) = _$OnFailureListener;

  void onFailure(jni$_.JObject exception);
  bool get onFailure$async => false;
}

final class _$OnFailureListener with $OnFailureListener {
  _$OnFailureListener({
    required void Function(jni$_.JObject exception) onFailure,
    this.onFailure$async = false,
  }) : _onFailure = onFailure;

  final void Function(jni$_.JObject exception) _onFailure;
  final bool onFailure$async;

  void onFailure(jni$_.JObject exception) {
    return _onFailure(exception);
  }
}

final class $OnFailureListener$NullableType
    extends jni$_.JObjType<OnFailureListener?> {
  @jni$_.internal
  const $OnFailureListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/google/android/gms/tasks/OnFailureListener;';

  @jni$_.internal
  @core$_.override
  OnFailureListener? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : OnFailureListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OnFailureListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OnFailureListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OnFailureListener$NullableType) &&
        other is $OnFailureListener$NullableType;
  }
}

final class $OnFailureListener$Type extends jni$_.JObjType<OnFailureListener> {
  @jni$_.internal
  const $OnFailureListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/google/android/gms/tasks/OnFailureListener;';

  @jni$_.internal
  @core$_.override
  OnFailureListener fromReference(jni$_.JReference reference) =>
      OnFailureListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OnFailureListener?> get nullableType =>
      const $OnFailureListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OnFailureListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OnFailureListener$Type) &&
        other is $OnFailureListener$Type;
  }
}

/// from: `com.google.android.gms.tasks.OnCompleteListener`
class OnCompleteListener<$TResult extends jni$_.JObject?>
    extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OnCompleteListener<$TResult>> $type;

  @jni$_.internal
  final jni$_.JObjType<$TResult> TResult;

  @jni$_.internal
  OnCompleteListener.fromReference(
    this.TResult,
    jni$_.JReference reference,
  )   : $type = type<$TResult>(TResult),
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/google/android/gms/tasks/OnCompleteListener');

  /// The type which includes information such as the signature of this class.
  static $OnCompleteListener$NullableType<$TResult>
      nullableType<$TResult extends jni$_.JObject?>(
    jni$_.JObjType<$TResult> TResult,
  ) {
    return $OnCompleteListener$NullableType<$TResult>(
      TResult,
    );
  }

  static $OnCompleteListener$Type<$TResult>
      type<$TResult extends jni$_.JObject?>(
    jni$_.JObjType<$TResult> TResult,
  ) {
    return $OnCompleteListener$Type<$TResult>(
      TResult,
    );
  }

  static final _id_onComplete = _class.instanceMethodId(
    r'onComplete',
    r'(Lcom/google/android/gms/tasks/Task;)V',
  );

  static final _onComplete = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onComplete(com.google.android.gms.tasks.Task task)`
  void onComplete(
    Task<$TResult?> task,
  ) {
    final _$task = task.reference;
    _onComplete(reference.pointer, _id_onComplete as jni$_.JMethodIDPtr,
            _$task.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $OnCompleteListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onComplete(Lcom/google/android/gms/tasks/Task;)V') {
        _$impls[$p]!.onComplete(
          $a![0]!.as(
              const $Task$Type<jni$_.JObject?>(jni$_.JObjectNullableType()),
              releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn<$TResult extends jni$_.JObject?>(
    jni$_.JImplementer implementer,
    $OnCompleteListener<$TResult> $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.google.android.gms.tasks.OnCompleteListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onComplete$async)
          r'onComplete(Lcom/google/android/gms/tasks/Task;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory OnCompleteListener.implement(
    $OnCompleteListener<$TResult> $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return OnCompleteListener<$TResult>.fromReference(
      $impl.TResult,
      $i.implementReference(),
    );
  }
}

abstract base mixin class $OnCompleteListener<$TResult extends jni$_.JObject?> {
  factory $OnCompleteListener({
    required jni$_.JObjType<$TResult> TResult,
    required void Function(Task<jni$_.JObject?> task) onComplete,
    bool onComplete$async,
  }) = _$OnCompleteListener<$TResult>;

  jni$_.JObjType<$TResult> get TResult;

  void onComplete(Task<jni$_.JObject?> task);
  bool get onComplete$async => false;
}

final class _$OnCompleteListener<$TResult extends jni$_.JObject?>
    with $OnCompleteListener<$TResult> {
  _$OnCompleteListener({
    required this.TResult,
    required void Function(Task<jni$_.JObject?> task) onComplete,
    this.onComplete$async = false,
  }) : _onComplete = onComplete;

  @core$_.override
  final jni$_.JObjType<$TResult> TResult;

  final void Function(Task<jni$_.JObject?> task) _onComplete;
  final bool onComplete$async;

  void onComplete(Task<jni$_.JObject?> task) {
    return _onComplete(task);
  }
}

final class $OnCompleteListener$NullableType<$TResult extends jni$_.JObject?>
    extends jni$_.JObjType<OnCompleteListener<$TResult>?> {
  @jni$_.internal
  final jni$_.JObjType<$TResult> TResult;

  @jni$_.internal
  const $OnCompleteListener$NullableType(
    this.TResult,
  );

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/google/android/gms/tasks/OnCompleteListener;';

  @jni$_.internal
  @core$_.override
  OnCompleteListener<$TResult>? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : OnCompleteListener<$TResult>.fromReference(
              TResult,
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OnCompleteListener<$TResult>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($OnCompleteListener$NullableType, TResult);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OnCompleteListener$NullableType<$TResult>) &&
        other is $OnCompleteListener$NullableType<$TResult> &&
        TResult == other.TResult;
  }
}

final class $OnCompleteListener$Type<$TResult extends jni$_.JObject?>
    extends jni$_.JObjType<OnCompleteListener<$TResult>> {
  @jni$_.internal
  final jni$_.JObjType<$TResult> TResult;

  @jni$_.internal
  const $OnCompleteListener$Type(
    this.TResult,
  );

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/google/android/gms/tasks/OnCompleteListener;';

  @jni$_.internal
  @core$_.override
  OnCompleteListener<$TResult> fromReference(jni$_.JReference reference) =>
      OnCompleteListener<$TResult>.fromReference(
        TResult,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OnCompleteListener<$TResult>?> get nullableType =>
      $OnCompleteListener$NullableType<$TResult>(TResult);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($OnCompleteListener$Type, TResult);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OnCompleteListener$Type<$TResult>) &&
        other is $OnCompleteListener$Type<$TResult> &&
        TResult == other.TResult;
  }
}

/// from: `com.google.android.gms.tasks.OnCanceledListener`
class OnCanceledListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OnCanceledListener> $type;

  @jni$_.internal
  OnCanceledListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/google/android/gms/tasks/OnCanceledListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $OnCanceledListener$NullableType();
  static const type = $OnCanceledListener$Type();
  static final _id_onCanceled = _class.instanceMethodId(
    r'onCanceled',
    r'()V',
  );

  static final _onCanceled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void onCanceled()`
  void onCanceled() {
    _onCanceled(reference.pointer, _id_onCanceled as jni$_.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $OnCanceledListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCanceled()V') {
        _$impls[$p]!.onCanceled();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $OnCanceledListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.google.android.gms.tasks.OnCanceledListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onCanceled$async) r'onCanceled()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory OnCanceledListener.implement(
    $OnCanceledListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return OnCanceledListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $OnCanceledListener {
  factory $OnCanceledListener({
    required void Function() onCanceled,
    bool onCanceled$async,
  }) = _$OnCanceledListener;

  void onCanceled();
  bool get onCanceled$async => false;
}

final class _$OnCanceledListener with $OnCanceledListener {
  _$OnCanceledListener({
    required void Function() onCanceled,
    this.onCanceled$async = false,
  }) : _onCanceled = onCanceled;

  final void Function() _onCanceled;
  final bool onCanceled$async;

  void onCanceled() {
    return _onCanceled();
  }
}

final class $OnCanceledListener$NullableType
    extends jni$_.JObjType<OnCanceledListener?> {
  @jni$_.internal
  const $OnCanceledListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/google/android/gms/tasks/OnCanceledListener;';

  @jni$_.internal
  @core$_.override
  OnCanceledListener? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : OnCanceledListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OnCanceledListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OnCanceledListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OnCanceledListener$NullableType) &&
        other is $OnCanceledListener$NullableType;
  }
}

final class $OnCanceledListener$Type
    extends jni$_.JObjType<OnCanceledListener> {
  @jni$_.internal
  const $OnCanceledListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/google/android/gms/tasks/OnCanceledListener;';

  @jni$_.internal
  @core$_.override
  OnCanceledListener fromReference(jni$_.JReference reference) =>
      OnCanceledListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OnCanceledListener?> get nullableType =>
      const $OnCanceledListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OnCanceledListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OnCanceledListener$Type) &&
        other is $OnCanceledListener$Type;
  }
}

/// from: `com.google.android.gms.tasks.OnTokenCanceledListener`
class OnTokenCanceledListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OnTokenCanceledListener> $type;

  @jni$_.internal
  OnTokenCanceledListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/google/android/gms/tasks/OnTokenCanceledListener');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $OnTokenCanceledListener$NullableType();
  static const type = $OnTokenCanceledListener$Type();
  static final _id_onCanceled = _class.instanceMethodId(
    r'onCanceled',
    r'()V',
  );

  static final _onCanceled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void onCanceled()`
  void onCanceled() {
    _onCanceled(reference.pointer, _id_onCanceled as jni$_.JMethodIDPtr)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $OnTokenCanceledListener> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onCanceled()V') {
        _$impls[$p]!.onCanceled();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $OnTokenCanceledListener $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.google.android.gms.tasks.OnTokenCanceledListener',
      $p,
      _$invokePointer,
      [
        if ($impl.onCanceled$async) r'onCanceled()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory OnTokenCanceledListener.implement(
    $OnTokenCanceledListener $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return OnTokenCanceledListener.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $OnTokenCanceledListener {
  factory $OnTokenCanceledListener({
    required void Function() onCanceled,
    bool onCanceled$async,
  }) = _$OnTokenCanceledListener;

  void onCanceled();
  bool get onCanceled$async => false;
}

final class _$OnTokenCanceledListener with $OnTokenCanceledListener {
  _$OnTokenCanceledListener({
    required void Function() onCanceled,
    this.onCanceled$async = false,
  }) : _onCanceled = onCanceled;

  final void Function() _onCanceled;
  final bool onCanceled$async;

  void onCanceled() {
    return _onCanceled();
  }
}

final class $OnTokenCanceledListener$NullableType
    extends jni$_.JObjType<OnTokenCanceledListener?> {
  @jni$_.internal
  const $OnTokenCanceledListener$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/gms/tasks/OnTokenCanceledListener;';

  @jni$_.internal
  @core$_.override
  OnTokenCanceledListener? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : OnTokenCanceledListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OnTokenCanceledListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OnTokenCanceledListener$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OnTokenCanceledListener$NullableType) &&
        other is $OnTokenCanceledListener$NullableType;
  }
}

final class $OnTokenCanceledListener$Type
    extends jni$_.JObjType<OnTokenCanceledListener> {
  @jni$_.internal
  const $OnTokenCanceledListener$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/gms/tasks/OnTokenCanceledListener;';

  @jni$_.internal
  @core$_.override
  OnTokenCanceledListener fromReference(jni$_.JReference reference) =>
      OnTokenCanceledListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OnTokenCanceledListener?> get nullableType =>
      const $OnTokenCanceledListener$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OnTokenCanceledListener$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OnTokenCanceledListener$Type) &&
        other is $OnTokenCanceledListener$Type;
  }
}

/// from: `com.google.android.play.core.install.InstallException`
class InstallException extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InstallException> $type;

  @jni$_.internal
  InstallException.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/google/android/play/core/install/InstallException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InstallException$NullableType();
  static const type = $InstallException$Type();
  static final _id_getErrorCode = _class.instanceMethodId(
    r'getErrorCode',
    r'()I',
  );

  static final _getErrorCode = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getErrorCode()`
  int getErrorCode() {
    return _getErrorCode(
            reference.pointer, _id_getErrorCode as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_new$ = _class.constructorId(
    r'(I)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory InstallException(
    int i,
  ) {
    return InstallException.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr, i)
            .reference);
  }
}

final class $InstallException$NullableType
    extends jni$_.JObjType<InstallException?> {
  @jni$_.internal
  const $InstallException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/install/InstallException;';

  @jni$_.internal
  @core$_.override
  InstallException? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : InstallException.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InstallException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InstallException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InstallException$NullableType) &&
        other is $InstallException$NullableType;
  }
}

final class $InstallException$Type extends jni$_.JObjType<InstallException> {
  @jni$_.internal
  const $InstallException$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/play/core/install/InstallException;';

  @jni$_.internal
  @core$_.override
  InstallException fromReference(jni$_.JReference reference) =>
      InstallException.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InstallException?> get nullableType =>
      const $InstallException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InstallException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InstallException$Type) &&
        other is $InstallException$Type;
  }
}

/// from: `com.google.android.gms.tasks.RuntimeExecutionException`
class RuntimeExecutionException extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<RuntimeExecutionException> $type;

  @jni$_.internal
  RuntimeExecutionException.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/google/android/gms/tasks/RuntimeExecutionException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $RuntimeExecutionException$NullableType();
  static const type = $RuntimeExecutionException$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Throwable;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.Throwable throwable)`
  /// The returned object must be released after use, by calling the [release] method.
  factory RuntimeExecutionException(
    jni$_.JObject throwable,
  ) {
    final _$throwable = throwable.reference;
    return RuntimeExecutionException.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$throwable.pointer)
        .reference);
  }
}

final class $RuntimeExecutionException$NullableType
    extends jni$_.JObjType<RuntimeExecutionException?> {
  @jni$_.internal
  const $RuntimeExecutionException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/gms/tasks/RuntimeExecutionException;';

  @jni$_.internal
  @core$_.override
  RuntimeExecutionException? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : RuntimeExecutionException.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RuntimeExecutionException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RuntimeExecutionException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RuntimeExecutionException$NullableType) &&
        other is $RuntimeExecutionException$NullableType;
  }
}

final class $RuntimeExecutionException$Type
    extends jni$_.JObjType<RuntimeExecutionException> {
  @jni$_.internal
  const $RuntimeExecutionException$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/google/android/gms/tasks/RuntimeExecutionException;';

  @jni$_.internal
  @core$_.override
  RuntimeExecutionException fromReference(jni$_.JReference reference) =>
      RuntimeExecutionException.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RuntimeExecutionException?> get nullableType =>
      const $RuntimeExecutionException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RuntimeExecutionException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RuntimeExecutionException$Type) &&
        other is $RuntimeExecutionException$Type;
  }
}
