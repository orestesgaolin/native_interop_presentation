// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;

@ffi.Native<instancetype Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()
external instancetype _UIKit_protocolTrampoline_xr62hr(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external bool _UIKit_protocolTrampoline_e3qsqz(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapListenerBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapBlockingBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()
external void _UIKit_protocolTrampoline_18v1jvf(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external ffi.Pointer<objc.ObjCObject> _UIKit_protocolTrampoline_1mbt9g9(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCObject> Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>()
external ffi.Pointer<objc.ObjCObject> _UIKit_protocolTrampoline_zi5eed(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
);

@ffi.Native<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()
external int _UIKit_protocolTrampoline_1ldqghh(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapListenerBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapBlockingBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCObject> Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCBlockImpl>,
  )
>()
external ffi.Pointer<objc.ObjCObject> _UIKit_protocolTrampoline_1q0i84(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCBlockImpl> arg2,
);

@ffi.Native<
  instancetype Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
  )
>()
external instancetype _UIKit_protocolTrampoline_10z9f5k(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapListenerBlock_1pl9qdv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapBlockingBlock_1pl9qdv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapListenerBlock_1s56lr9(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapBlockingBlock_1s56lr9(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<objc.CGPoint Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external objc.CGPoint _UIKit_protocolTrampoline_7ohnx8(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapListenerBlock_1bktu2(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapBlockingBlock_1bktu2(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, objc.CGPoint)>()
external void _UIKit_protocolTrampoline_1bktu2(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGPoint arg1,
);

@ffi.Native<objc.CGSize Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external objc.CGSize _UIKit_protocolTrampoline_1j20mp(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, objc.CGRect)>()
external ffi.Pointer<objc.ObjCObject> _UIKit_protocolTrampoline_12thpau(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGRect arg1,
);

@ffi.Native<
  objc.CGSize Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize)
>()
external objc.CGSize _UIKit_protocolTrampoline_gnbb7x(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  objc.CGSize arg2,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapListenerBlock_1rn6eap(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapBlockingBlock_1rn6eap(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)
>()
external void _UIKit_protocolTrampoline_1rn6eap(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGSize arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapListenerBlock_fjrv01(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapBlockingBlock_fjrv01(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>()
external void _UIKit_protocolTrampoline_fjrv01(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapListenerBlock_ovsamd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapBlockingBlock_ovsamd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external void _UIKit_protocolTrampoline_ovsamd(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()
external bool _UIKit_protocolTrampoline_3su7tt(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<objc.CGRect Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external objc.CGRect _UIKit_protocolTrampoline_1c3uc0w(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<CGAffineTransform Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external CGAffineTransform _UIKit_protocolTrampoline_8o6he9(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapListenerBlock_1lznlw3(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapBlockingBlock_1lznlw3(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, CGAffineTransform)>()
external void _UIKit_protocolTrampoline_1lznlw3(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  CGAffineTransform arg1,
);

@ffi.Native<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external int _UIKit_protocolTrampoline_ku69ws(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  objc.CGPoint Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)
>()
external objc.CGPoint _UIKit_protocolTrampoline_17ipln5(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGPoint arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
);

@ffi.Native<
  objc.CGRect Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)
>()
external objc.CGRect _UIKit_protocolTrampoline_1sh7l9z(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGRect arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapListenerBlock_qvcerx(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapBlockingBlock_qvcerx(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<CGContext>,
  )
>()
external void _UIKit_protocolTrampoline_qvcerx(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<CGContext> arg2,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapListenerBlock_1l4hxwm(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapBlockingBlock_1l4hxwm(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>)>()
external void _UIKit_protocolTrampoline_1l4hxwm(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCBlockImpl> arg1,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapListenerBlock_1cxqo1i(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapBlockingBlock_1cxqo1i(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapListenerBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapBlockingBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapListenerBlock_10lndml(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _UIKit_wrapBlockingBlock_10lndml(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, ffi.Bool)>()
external void _UIKit_protocolTrampoline_10lndml(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  bool arg1,
);

final class CGVector extends ffi.Struct {
  @ffi.Double()
  external double dx;

  @ffi.Double()
  external double dy;
}

final class CGAffineTransform extends ffi.Struct {
  @ffi.Double()
  external double a;

  @ffi.Double()
  external double b;

  @ffi.Double()
  external double c;

  @ffi.Double()
  external double d;

  @ffi.Double()
  external double tx;

  @ffi.Double()
  external double ty;
}

/// WARNING: NSBundle is a stub. To generate bindings for this class, include
/// NSBundle in your config's objc-interfaces list.
///
/// NSBundle
class NSBundle extends objc.NSObject {
  NSBundle._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSBundle] that points to the same underlying object as [other].
  NSBundle.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSBundle] that wraps the given raw object pointer.
  NSBundle.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: NSAttributedString is a stub. To generate bindings for this class, include
/// NSAttributedString in your config's objc-interfaces list.
///
/// NSAttributedString
class NSAttributedString extends objc.NSObject implements objc.NSCopying, objc.NSMutableCopying, objc.NSSecureCoding {
  NSAttributedString._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSAttributedString', iOS: (false, (3, 2, 0)), macOS: (false, (10, 0, 0)));
  }

  /// Constructs a [NSAttributedString] that points to the same underlying object as [other].
  NSAttributedString.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSAttributedString] that wraps the given raw object pointer.
  NSAttributedString.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

enum NSAttributedStringEnumerationOptions {
  NSAttributedStringEnumerationReverse(2),
  NSAttributedStringEnumerationLongestEffectiveRangeNotRequired(1048576);

  final int value;
  const NSAttributedStringEnumerationOptions(this.value);

  static NSAttributedStringEnumerationOptions fromValue(int value) => switch (value) {
    2 => NSAttributedStringEnumerationReverse,
    1048576 => NSAttributedStringEnumerationLongestEffectiveRangeNotRequired,
    _ => throw ArgumentError('Unknown value for NSAttributedStringEnumerationOptions: $value'),
  };
}

enum NSAttributedStringMarkdownParsingFailurePolicy {
  NSAttributedStringMarkdownParsingFailureReturnError(0),
  NSAttributedStringMarkdownParsingFailureReturnPartiallyParsedIfPossible(1);

  final int value;
  const NSAttributedStringMarkdownParsingFailurePolicy(this.value);

  static NSAttributedStringMarkdownParsingFailurePolicy fromValue(int value) => switch (value) {
    0 => NSAttributedStringMarkdownParsingFailureReturnError,
    1 => NSAttributedStringMarkdownParsingFailureReturnPartiallyParsedIfPossible,
    _ => throw ArgumentError('Unknown value for NSAttributedStringMarkdownParsingFailurePolicy: $value'),
  };
}

enum NSAttributedStringMarkdownInterpretedSyntax {
  NSAttributedStringMarkdownInterpretedSyntaxFull(0),
  NSAttributedStringMarkdownInterpretedSyntaxInlineOnly(1),
  NSAttributedStringMarkdownInterpretedSyntaxInlineOnlyPreservingWhitespace(2);

  final int value;
  const NSAttributedStringMarkdownInterpretedSyntax(this.value);

  static NSAttributedStringMarkdownInterpretedSyntax fromValue(int value) => switch (value) {
    0 => NSAttributedStringMarkdownInterpretedSyntaxFull,
    1 => NSAttributedStringMarkdownInterpretedSyntaxInlineOnly,
    2 => NSAttributedStringMarkdownInterpretedSyntaxInlineOnlyPreservingWhitespace,
    _ => throw ArgumentError('Unknown value for NSAttributedStringMarkdownInterpretedSyntax: $value'),
  };
}

enum NSAttributedStringFormattingOptions {
  NSAttributedStringFormattingInsertArgumentAttributesWithoutMerging(1),
  NSAttributedStringFormattingApplyReplacementIndexAttribute(2);

  final int value;
  const NSAttributedStringFormattingOptions(this.value);

  static NSAttributedStringFormattingOptions fromValue(int value) => switch (value) {
    1 => NSAttributedStringFormattingInsertArgumentAttributesWithoutMerging,
    2 => NSAttributedStringFormattingApplyReplacementIndexAttribute,
    _ => throw ArgumentError('Unknown value for NSAttributedStringFormattingOptions: $value'),
  };
}

enum NSSearchPathDirectory {
  NSApplicationDirectory(1),
  NSDemoApplicationDirectory(2),
  NSDeveloperApplicationDirectory(3),
  NSAdminApplicationDirectory(4),
  NSLibraryDirectory(5),
  NSDeveloperDirectory(6),
  NSUserDirectory(7),
  NSDocumentationDirectory(8),
  NSDocumentDirectory(9),
  NSCoreServiceDirectory(10),
  NSAutosavedInformationDirectory(11),
  NSDesktopDirectory(12),
  NSCachesDirectory(13),
  NSApplicationSupportDirectory(14),
  NSDownloadsDirectory(15),
  NSInputMethodsDirectory(16),
  NSMoviesDirectory(17),
  NSMusicDirectory(18),
  NSPicturesDirectory(19),
  NSPrinterDescriptionDirectory(20),
  NSSharedPublicDirectory(21),
  NSPreferencePanesDirectory(22),
  NSApplicationScriptsDirectory(23),
  NSItemReplacementDirectory(99),
  NSAllApplicationsDirectory(100),
  NSAllLibrariesDirectory(101),
  NSTrashDirectory(102);

  final int value;
  const NSSearchPathDirectory(this.value);

  static NSSearchPathDirectory fromValue(int value) => switch (value) {
    1 => NSApplicationDirectory,
    2 => NSDemoApplicationDirectory,
    3 => NSDeveloperApplicationDirectory,
    4 => NSAdminApplicationDirectory,
    5 => NSLibraryDirectory,
    6 => NSDeveloperDirectory,
    7 => NSUserDirectory,
    8 => NSDocumentationDirectory,
    9 => NSDocumentDirectory,
    10 => NSCoreServiceDirectory,
    11 => NSAutosavedInformationDirectory,
    12 => NSDesktopDirectory,
    13 => NSCachesDirectory,
    14 => NSApplicationSupportDirectory,
    15 => NSDownloadsDirectory,
    16 => NSInputMethodsDirectory,
    17 => NSMoviesDirectory,
    18 => NSMusicDirectory,
    19 => NSPicturesDirectory,
    20 => NSPrinterDescriptionDirectory,
    21 => NSSharedPublicDirectory,
    22 => NSPreferencePanesDirectory,
    23 => NSApplicationScriptsDirectory,
    99 => NSItemReplacementDirectory,
    100 => NSAllApplicationsDirectory,
    101 => NSAllLibrariesDirectory,
    102 => NSTrashDirectory,
    _ => throw ArgumentError('Unknown value for NSSearchPathDirectory: $value'),
  };
}

enum NSSearchPathDomainMask {
  NSUserDomainMask(1),
  NSLocalDomainMask(2),
  NSNetworkDomainMask(4),
  NSSystemDomainMask(8),
  NSAllDomainsMask(65535);

  final int value;
  const NSSearchPathDomainMask(this.value);

  static NSSearchPathDomainMask fromValue(int value) => switch (value) {
    1 => NSUserDomainMask,
    2 => NSLocalDomainMask,
    4 => NSNetworkDomainMask,
    8 => NSSystemDomainMask,
    65535 => NSAllDomainsMask,
    _ => throw ArgumentError('Unknown value for NSSearchPathDomainMask: $value'),
  };
}

enum NSVolumeEnumerationOptions {
  NSVolumeEnumerationSkipHiddenVolumes(2),
  NSVolumeEnumerationProduceFileReferenceURLs(4);

  final int value;
  const NSVolumeEnumerationOptions(this.value);

  static NSVolumeEnumerationOptions fromValue(int value) => switch (value) {
    2 => NSVolumeEnumerationSkipHiddenVolumes,
    4 => NSVolumeEnumerationProduceFileReferenceURLs,
    _ => throw ArgumentError('Unknown value for NSVolumeEnumerationOptions: $value'),
  };
}

enum NSDirectoryEnumerationOptions {
  NSDirectoryEnumerationSkipsSubdirectoryDescendants(1),
  NSDirectoryEnumerationSkipsPackageDescendants(2),
  NSDirectoryEnumerationSkipsHiddenFiles(4),
  NSDirectoryEnumerationIncludesDirectoriesPostOrder(8),
  NSDirectoryEnumerationProducesRelativePathURLs(16);

  final int value;
  const NSDirectoryEnumerationOptions(this.value);

  static NSDirectoryEnumerationOptions fromValue(int value) => switch (value) {
    1 => NSDirectoryEnumerationSkipsSubdirectoryDescendants,
    2 => NSDirectoryEnumerationSkipsPackageDescendants,
    4 => NSDirectoryEnumerationSkipsHiddenFiles,
    8 => NSDirectoryEnumerationIncludesDirectoriesPostOrder,
    16 => NSDirectoryEnumerationProducesRelativePathURLs,
    _ => throw ArgumentError('Unknown value for NSDirectoryEnumerationOptions: $value'),
  };
}

enum NSFileManagerItemReplacementOptions {
  NSFileManagerItemReplacementUsingNewMetadataOnly(1),
  NSFileManagerItemReplacementWithoutDeletingBackupItem(2);

  final int value;
  const NSFileManagerItemReplacementOptions(this.value);

  static NSFileManagerItemReplacementOptions fromValue(int value) => switch (value) {
    1 => NSFileManagerItemReplacementUsingNewMetadataOnly,
    2 => NSFileManagerItemReplacementWithoutDeletingBackupItem,
    _ => throw ArgumentError('Unknown value for NSFileManagerItemReplacementOptions: $value'),
  };
}

enum NSURLRelationship {
  NSURLRelationshipContains(0),
  NSURLRelationshipSame(1),
  NSURLRelationshipOther(2);

  final int value;
  const NSURLRelationship(this.value);

  static NSURLRelationship fromValue(int value) => switch (value) {
    0 => NSURLRelationshipContains,
    1 => NSURLRelationshipSame,
    2 => NSURLRelationshipOther,
    _ => throw ArgumentError('Unknown value for NSURLRelationship: $value'),
  };
}

enum NSFileManagerUnmountOptions {
  NSFileManagerUnmountAllPartitionsAndEjectDisk(1),
  NSFileManagerUnmountWithoutUI(2);

  final int value;
  const NSFileManagerUnmountOptions(this.value);

  static NSFileManagerUnmountOptions fromValue(int value) => switch (value) {
    1 => NSFileManagerUnmountAllPartitionsAndEjectDisk,
    2 => NSFileManagerUnmountWithoutUI,
    _ => throw ArgumentError('Unknown value for NSFileManagerUnmountOptions: $value'),
  };
}

enum NSFileManagerResumeSyncBehavior {
  NSFileManagerResumeSyncBehaviorPreserveLocalChanges(0),
  NSFileManagerResumeSyncBehaviorAfterUploadWithFailOnConflict(1),
  NSFileManagerResumeSyncBehaviorDropLocalChanges(2);

  final int value;
  const NSFileManagerResumeSyncBehavior(this.value);

  static NSFileManagerResumeSyncBehavior fromValue(int value) => switch (value) {
    0 => NSFileManagerResumeSyncBehaviorPreserveLocalChanges,
    1 => NSFileManagerResumeSyncBehaviorAfterUploadWithFailOnConflict,
    2 => NSFileManagerResumeSyncBehaviorDropLocalChanges,
    _ => throw ArgumentError('Unknown value for NSFileManagerResumeSyncBehavior: $value'),
  };
}

enum NSFileManagerUploadLocalVersionConflictPolicy {
  NSFileManagerUploadConflictPolicyDefault(0),
  NSFileManagerUploadConflictPolicyFailOnConflict(1);

  final int value;
  const NSFileManagerUploadLocalVersionConflictPolicy(this.value);

  static NSFileManagerUploadLocalVersionConflictPolicy fromValue(int value) => switch (value) {
    0 => NSFileManagerUploadConflictPolicyDefault,
    1 => NSFileManagerUploadConflictPolicyFailOnConflict,
    _ => throw ArgumentError('Unknown value for NSFileManagerUploadLocalVersionConflictPolicy: $value'),
  };
}

enum NSHTTPCookieAcceptPolicy {
  NSHTTPCookieAcceptPolicyAlways(0),
  NSHTTPCookieAcceptPolicyNever(1),
  NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain(2);

  final int value;
  const NSHTTPCookieAcceptPolicy(this.value);

  static NSHTTPCookieAcceptPolicy fromValue(int value) => switch (value) {
    0 => NSHTTPCookieAcceptPolicyAlways,
    1 => NSHTTPCookieAcceptPolicyNever,
    2 => NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain,
    _ => throw ArgumentError('Unknown value for NSHTTPCookieAcceptPolicy: $value'),
  };
}

final class __IOSurface extends ffi.Opaque {}

enum NSAlignmentOptions {
  NSAlignMinXInward(1),
  NSAlignMinYInward(2),
  NSAlignMaxXInward(4),
  NSAlignMaxYInward(8),
  NSAlignWidthInward(16),
  NSAlignHeightInward(32),
  NSAlignMinXOutward(256),
  NSAlignMinYOutward(512),
  NSAlignMaxXOutward(1024),
  NSAlignMaxYOutward(2048),
  NSAlignWidthOutward(4096),
  NSAlignHeightOutward(8192),
  NSAlignMinXNearest(65536),
  NSAlignMinYNearest(131072),
  NSAlignMaxXNearest(262144),
  NSAlignMaxYNearest(524288),
  NSAlignWidthNearest(1048576),
  NSAlignHeightNearest(2097152),
  NSAlignRectFlipped(-9223372036854775808),
  NSAlignAllEdgesInward(15),
  NSAlignAllEdgesOutward(3840),
  NSAlignAllEdgesNearest(983040);

  final int value;
  const NSAlignmentOptions(this.value);

  static NSAlignmentOptions fromValue(int value) => switch (value) {
    1 => NSAlignMinXInward,
    2 => NSAlignMinYInward,
    4 => NSAlignMaxXInward,
    8 => NSAlignMaxYInward,
    16 => NSAlignWidthInward,
    32 => NSAlignHeightInward,
    256 => NSAlignMinXOutward,
    512 => NSAlignMinYOutward,
    1024 => NSAlignMaxXOutward,
    2048 => NSAlignMaxYOutward,
    4096 => NSAlignWidthOutward,
    8192 => NSAlignHeightOutward,
    65536 => NSAlignMinXNearest,
    131072 => NSAlignMinYNearest,
    262144 => NSAlignMaxXNearest,
    524288 => NSAlignMaxYNearest,
    1048576 => NSAlignWidthNearest,
    2097152 => NSAlignHeightNearest,
    -9223372036854775808 => NSAlignRectFlipped,
    15 => NSAlignAllEdgesInward,
    3840 => NSAlignAllEdgesOutward,
    983040 => NSAlignAllEdgesNearest,
    _ => throw ArgumentError('Unknown value for NSAlignmentOptions: $value'),
  };
}

enum NSOperationQueuePriority {
  NSOperationQueuePriorityVeryLow(-8),
  NSOperationQueuePriorityLow(-4),
  NSOperationQueuePriorityNormal(0),
  NSOperationQueuePriorityHigh(4),
  NSOperationQueuePriorityVeryHigh(8);

  final int value;
  const NSOperationQueuePriority(this.value);

  static NSOperationQueuePriority fromValue(int value) => switch (value) {
    -8 => NSOperationQueuePriorityVeryLow,
    -4 => NSOperationQueuePriorityLow,
    0 => NSOperationQueuePriorityNormal,
    4 => NSOperationQueuePriorityHigh,
    8 => NSOperationQueuePriorityVeryHigh,
    _ => throw ArgumentError('Unknown value for NSOperationQueuePriority: $value'),
  };
}

enum NSURLCacheStoragePolicy {
  NSURLCacheStorageAllowed(0),
  NSURLCacheStorageAllowedInMemoryOnly(1),
  NSURLCacheStorageNotAllowed(2);

  final int value;
  const NSURLCacheStoragePolicy(this.value);

  static NSURLCacheStoragePolicy fromValue(int value) => switch (value) {
    0 => NSURLCacheStorageAllowed,
    1 => NSURLCacheStorageAllowedInMemoryOnly,
    2 => NSURLCacheStorageNotAllowed,
    _ => throw ArgumentError('Unknown value for NSURLCacheStoragePolicy: $value'),
  };
}

final class __SecIdentity extends ffi.Opaque {}

final class __SecTrust extends ffi.Opaque {}

enum tls_protocol_version_t {
  tls_protocol_version_TLSv10(769),
  tls_protocol_version_TLSv11(770),
  tls_protocol_version_TLSv12(771),
  tls_protocol_version_TLSv13(772),
  tls_protocol_version_DTLSv10(-257),
  tls_protocol_version_DTLSv12(-259);

  final int value;
  const tls_protocol_version_t(this.value);

  static tls_protocol_version_t fromValue(int value) => switch (value) {
    769 => tls_protocol_version_TLSv10,
    770 => tls_protocol_version_TLSv11,
    771 => tls_protocol_version_TLSv12,
    772 => tls_protocol_version_TLSv13,
    -257 => tls_protocol_version_DTLSv10,
    -259 => tls_protocol_version_DTLSv12,
    _ => throw ArgumentError('Unknown value for tls_protocol_version_t: $value'),
  };
}

enum SSLProtocol {
  kSSLProtocolUnknown(0),
  kTLSProtocol1(4),
  kTLSProtocol11(7),
  kTLSProtocol12(8),
  kDTLSProtocol1(9),
  kTLSProtocol13(10),
  kDTLSProtocol12(11),
  kTLSProtocolMaxSupported(999),
  kSSLProtocol2(1),
  kSSLProtocol3(2),
  kSSLProtocol3Only(3),
  kTLSProtocol1Only(5),
  kSSLProtocolAll(6);

  final int value;
  const SSLProtocol(this.value);

  static SSLProtocol fromValue(int value) => switch (value) {
    0 => kSSLProtocolUnknown,
    4 => kTLSProtocol1,
    7 => kTLSProtocol11,
    8 => kTLSProtocol12,
    9 => kDTLSProtocol1,
    10 => kTLSProtocol13,
    11 => kDTLSProtocol12,
    999 => kTLSProtocolMaxSupported,
    1 => kSSLProtocol2,
    2 => kSSLProtocol3,
    3 => kSSLProtocol3Only,
    5 => kTLSProtocol1Only,
    6 => kSSLProtocolAll,
    _ => throw ArgumentError('Unknown value for SSLProtocol: $value'),
  };
}

enum NSURLCredentialPersistence {
  NSURLCredentialPersistenceNone(0),
  NSURLCredentialPersistenceForSession(1),
  NSURLCredentialPersistencePermanent(2),
  NSURLCredentialPersistenceSynchronizable(3);

  final int value;
  const NSURLCredentialPersistence(this.value);

  static NSURLCredentialPersistence fromValue(int value) => switch (value) {
    0 => NSURLCredentialPersistenceNone,
    1 => NSURLCredentialPersistenceForSession,
    2 => NSURLCredentialPersistencePermanent,
    3 => NSURLCredentialPersistenceSynchronizable,
    _ => throw ArgumentError('Unknown value for NSURLCredentialPersistence: $value'),
  };
}

enum NSURLRequestCachePolicy {
  NSURLRequestUseProtocolCachePolicy(0),
  NSURLRequestReloadIgnoringLocalCacheData(1),
  NSURLRequestReloadIgnoringLocalAndRemoteCacheData(4),
  NSURLRequestReturnCacheDataElseLoad(2),
  NSURLRequestReturnCacheDataDontLoad(3),
  NSURLRequestReloadRevalidatingCacheData(5);

  static const NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData;

  final int value;
  const NSURLRequestCachePolicy(this.value);

  static NSURLRequestCachePolicy fromValue(int value) => switch (value) {
    0 => NSURLRequestUseProtocolCachePolicy,
    1 => NSURLRequestReloadIgnoringLocalCacheData,
    4 => NSURLRequestReloadIgnoringLocalAndRemoteCacheData,
    2 => NSURLRequestReturnCacheDataElseLoad,
    3 => NSURLRequestReturnCacheDataDontLoad,
    5 => NSURLRequestReloadRevalidatingCacheData,
    _ => throw ArgumentError('Unknown value for NSURLRequestCachePolicy: $value'),
  };

  @override
  String toString() {
    if (this == NSURLRequestReloadIgnoringLocalCacheData)
      return "NSURLRequestCachePolicy.NSURLRequestReloadIgnoringLocalCacheData, NSURLRequestCachePolicy.NSURLRequestReloadIgnoringCacheData";
    return super.toString();
  }
}

enum NSURLRequestNetworkServiceType {
  NSURLNetworkServiceTypeDefault(0),
  NSURLNetworkServiceTypeVoIP(1),
  NSURLNetworkServiceTypeVideo(2),
  NSURLNetworkServiceTypeBackground(3),
  NSURLNetworkServiceTypeVoice(4),
  NSURLNetworkServiceTypeResponsiveData(6),
  NSURLNetworkServiceTypeAVStreaming(8),
  NSURLNetworkServiceTypeResponsiveAV(9),
  NSURLNetworkServiceTypeCallSignaling(11);

  final int value;
  const NSURLRequestNetworkServiceType(this.value);

  static NSURLRequestNetworkServiceType fromValue(int value) => switch (value) {
    0 => NSURLNetworkServiceTypeDefault,
    1 => NSURLNetworkServiceTypeVoIP,
    2 => NSURLNetworkServiceTypeVideo,
    3 => NSURLNetworkServiceTypeBackground,
    4 => NSURLNetworkServiceTypeVoice,
    6 => NSURLNetworkServiceTypeResponsiveData,
    8 => NSURLNetworkServiceTypeAVStreaming,
    9 => NSURLNetworkServiceTypeResponsiveAV,
    11 => NSURLNetworkServiceTypeCallSignaling,
    _ => throw ArgumentError('Unknown value for NSURLRequestNetworkServiceType: $value'),
  };
}

enum NSURLRequestAttribution {
  NSURLRequestAttributionDeveloper(0),
  NSURLRequestAttributionUser(1);

  final int value;
  const NSURLRequestAttribution(this.value);

  static NSURLRequestAttribution fromValue(int value) => switch (value) {
    0 => NSURLRequestAttributionDeveloper,
    1 => NSURLRequestAttributionUser,
    _ => throw ArgumentError('Unknown value for NSURLRequestAttribution: $value'),
  };
}

/// WARNING: NSExtensionContext is a stub. To generate bindings for this class, include
/// NSExtensionContext in your config's objc-interfaces list.
///
/// NSExtensionContext
class NSExtensionContext extends objc.NSObject {
  NSExtensionContext._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSExtensionContext', iOS: (false, (8, 0, 0)), macOS: (false, (10, 10, 0)));
  }

  /// Constructs a [NSExtensionContext] that points to the same underlying object as [other].
  NSExtensionContext.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSExtensionContext] that wraps the given raw object pointer.
  NSExtensionContext.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: NSExtensionRequestHandling is a stub. To generate bindings for this class, include
/// NSExtensionRequestHandling in your config's objc-protocols list.
///
/// NSExtensionRequestHandling
interface class NSExtensionRequestHandling extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  NSExtensionRequestHandling._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [NSExtensionRequestHandling] that points to the same underlying object as [other].
  NSExtensionRequestHandling.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSExtensionRequestHandling] that wraps the given raw object pointer.
  NSExtensionRequestHandling.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

enum NSFileVersionAddingOptions {
  NSFileVersionAddingByMoving(1);

  final int value;
  const NSFileVersionAddingOptions(this.value);

  static NSFileVersionAddingOptions fromValue(int value) => switch (value) {
    1 => NSFileVersionAddingByMoving,
    _ => throw ArgumentError('Unknown value for NSFileVersionAddingOptions: $value'),
  };
}

enum NSFileVersionReplacingOptions {
  NSFileVersionReplacingByMoving(1);

  final int value;
  const NSFileVersionReplacingOptions(this.value);

  static NSFileVersionReplacingOptions fromValue(int value) => switch (value) {
    1 => NSFileVersionReplacingByMoving,
    _ => throw ArgumentError('Unknown value for NSFileVersionReplacingOptions: $value'),
  };
}

enum NSFileWrapperReadingOptions {
  NSFileWrapperReadingImmediate(1),
  NSFileWrapperReadingWithoutMapping(2);

  final int value;
  const NSFileWrapperReadingOptions(this.value);

  static NSFileWrapperReadingOptions fromValue(int value) => switch (value) {
    1 => NSFileWrapperReadingImmediate,
    2 => NSFileWrapperReadingWithoutMapping,
    _ => throw ArgumentError('Unknown value for NSFileWrapperReadingOptions: $value'),
  };
}

enum NSFileWrapperWritingOptions {
  NSFileWrapperWritingAtomic(1),
  NSFileWrapperWritingWithNameUpdating(2);

  final int value;
  const NSFileWrapperWritingOptions(this.value);

  static NSFileWrapperWritingOptions fromValue(int value) => switch (value) {
    1 => NSFileWrapperWritingAtomic,
    2 => NSFileWrapperWritingWithNameUpdating,
    _ => throw ArgumentError('Unknown value for NSFileWrapperWritingOptions: $value'),
  };
}

enum NSNetServiceOptions {
  NSNetServiceNoAutoRename(1),
  NSNetServiceListenForConnections(2);

  final int value;
  const NSNetServiceOptions(this.value);

  static NSNetServiceOptions fromValue(int value) => switch (value) {
    1 => NSNetServiceNoAutoRename,
    2 => NSNetServiceListenForConnections,
    _ => throw ArgumentError('Unknown value for NSNetServiceOptions: $value'),
  };
}

/// WARNING: NSUndoManager is a stub. To generate bindings for this class, include
/// NSUndoManager in your config's objc-interfaces list.
///
/// NSUndoManager
class NSUndoManager extends objc.NSObject {
  NSUndoManager._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSUndoManager', iOS: (false, (3, 0, 0)), macOS: (false, (10, 0, 0)));
  }

  /// Constructs a [NSUndoManager] that points to the same underlying object as [other].
  NSUndoManager.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSUndoManager] that wraps the given raw object pointer.
  NSUndoManager.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

enum NSURLSessionTaskState {
  NSURLSessionTaskStateRunning(0),
  NSURLSessionTaskStateSuspended(1),
  NSURLSessionTaskStateCanceling(2),
  NSURLSessionTaskStateCompleted(3);

  final int value;
  const NSURLSessionTaskState(this.value);

  static NSURLSessionTaskState fromValue(int value) => switch (value) {
    0 => NSURLSessionTaskStateRunning,
    1 => NSURLSessionTaskStateSuspended,
    2 => NSURLSessionTaskStateCanceling,
    3 => NSURLSessionTaskStateCompleted,
    _ => throw ArgumentError('Unknown value for NSURLSessionTaskState: $value'),
  };
}

enum NSURLSessionWebSocketMessageType {
  NSURLSessionWebSocketMessageTypeData(0),
  NSURLSessionWebSocketMessageTypeString(1);

  final int value;
  const NSURLSessionWebSocketMessageType(this.value);

  static NSURLSessionWebSocketMessageType fromValue(int value) => switch (value) {
    0 => NSURLSessionWebSocketMessageTypeData,
    1 => NSURLSessionWebSocketMessageTypeString,
    _ => throw ArgumentError('Unknown value for NSURLSessionWebSocketMessageType: $value'),
  };
}

enum NSURLSessionWebSocketCloseCode {
  NSURLSessionWebSocketCloseCodeInvalid(0),
  NSURLSessionWebSocketCloseCodeNormalClosure(1000),
  NSURLSessionWebSocketCloseCodeGoingAway(1001),
  NSURLSessionWebSocketCloseCodeProtocolError(1002),
  NSURLSessionWebSocketCloseCodeUnsupportedData(1003),
  NSURLSessionWebSocketCloseCodeNoStatusReceived(1005),
  NSURLSessionWebSocketCloseCodeAbnormalClosure(1006),
  NSURLSessionWebSocketCloseCodeInvalidFramePayloadData(1007),
  NSURLSessionWebSocketCloseCodePolicyViolation(1008),
  NSURLSessionWebSocketCloseCodeMessageTooBig(1009),
  NSURLSessionWebSocketCloseCodeMandatoryExtensionMissing(1010),
  NSURLSessionWebSocketCloseCodeInternalServerError(1011),
  NSURLSessionWebSocketCloseCodeTLSHandshakeFailure(1015);

  final int value;
  const NSURLSessionWebSocketCloseCode(this.value);

  static NSURLSessionWebSocketCloseCode fromValue(int value) => switch (value) {
    0 => NSURLSessionWebSocketCloseCodeInvalid,
    1000 => NSURLSessionWebSocketCloseCodeNormalClosure,
    1001 => NSURLSessionWebSocketCloseCodeGoingAway,
    1002 => NSURLSessionWebSocketCloseCodeProtocolError,
    1003 => NSURLSessionWebSocketCloseCodeUnsupportedData,
    1005 => NSURLSessionWebSocketCloseCodeNoStatusReceived,
    1006 => NSURLSessionWebSocketCloseCodeAbnormalClosure,
    1007 => NSURLSessionWebSocketCloseCodeInvalidFramePayloadData,
    1008 => NSURLSessionWebSocketCloseCodePolicyViolation,
    1009 => NSURLSessionWebSocketCloseCodeMessageTooBig,
    1010 => NSURLSessionWebSocketCloseCodeMandatoryExtensionMissing,
    1011 => NSURLSessionWebSocketCloseCodeInternalServerError,
    1015 => NSURLSessionWebSocketCloseCodeTLSHandshakeFailure,
    _ => throw ArgumentError('Unknown value for NSURLSessionWebSocketCloseCode: $value'),
  };
}

enum NSURLSessionMultipathServiceType {
  NSURLSessionMultipathServiceTypeNone(0),
  NSURLSessionMultipathServiceTypeHandover(1),
  NSURLSessionMultipathServiceTypeInteractive(2),
  NSURLSessionMultipathServiceTypeAggregate(3);

  final int value;
  const NSURLSessionMultipathServiceType(this.value);

  static NSURLSessionMultipathServiceType fromValue(int value) => switch (value) {
    0 => NSURLSessionMultipathServiceTypeNone,
    1 => NSURLSessionMultipathServiceTypeHandover,
    2 => NSURLSessionMultipathServiceTypeInteractive,
    3 => NSURLSessionMultipathServiceTypeAggregate,
    _ => throw ArgumentError('Unknown value for NSURLSessionMultipathServiceType: $value'),
  };
}

enum NSURLSessionDelayedRequestDisposition {
  NSURLSessionDelayedRequestContinueLoading(0),
  NSURLSessionDelayedRequestUseNewRequest(1),
  NSURLSessionDelayedRequestCancel(2);

  final int value;
  const NSURLSessionDelayedRequestDisposition(this.value);

  static NSURLSessionDelayedRequestDisposition fromValue(int value) => switch (value) {
    0 => NSURLSessionDelayedRequestContinueLoading,
    1 => NSURLSessionDelayedRequestUseNewRequest,
    2 => NSURLSessionDelayedRequestCancel,
    _ => throw ArgumentError('Unknown value for NSURLSessionDelayedRequestDisposition: $value'),
  };
}

enum NSURLSessionAuthChallengeDisposition {
  NSURLSessionAuthChallengeUseCredential(0),
  NSURLSessionAuthChallengePerformDefaultHandling(1),
  NSURLSessionAuthChallengeCancelAuthenticationChallenge(2),
  NSURLSessionAuthChallengeRejectProtectionSpace(3);

  final int value;
  const NSURLSessionAuthChallengeDisposition(this.value);

  static NSURLSessionAuthChallengeDisposition fromValue(int value) => switch (value) {
    0 => NSURLSessionAuthChallengeUseCredential,
    1 => NSURLSessionAuthChallengePerformDefaultHandling,
    2 => NSURLSessionAuthChallengeCancelAuthenticationChallenge,
    3 => NSURLSessionAuthChallengeRejectProtectionSpace,
    _ => throw ArgumentError('Unknown value for NSURLSessionAuthChallengeDisposition: $value'),
  };
}

/// WARNING: NSUserActivity is a stub. To generate bindings for this class, include
/// NSUserActivity in your config's objc-interfaces list.
///
/// NSUserActivity
class NSUserActivity extends objc.NSObject {
  NSUserActivity._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSUserActivity', iOS: (false, (8, 0, 0)), macOS: (false, (10, 10, 0)));
  }

  /// Constructs a [NSUserActivity] that points to the same underlying object as [other].
  NSUserActivity.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSUserActivity] that wraps the given raw object pointer.
  NSUserActivity.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

enum UISceneActivationState {
  UISceneActivationStateUnattached(-1),
  UISceneActivationStateForegroundActive(0),
  UISceneActivationStateForegroundInactive(1),
  UISceneActivationStateBackground(2);

  final int value;
  const UISceneActivationState(this.value);

  static UISceneActivationState fromValue(int value) => switch (value) {
    -1 => UISceneActivationStateUnattached,
    0 => UISceneActivationStateForegroundActive,
    1 => UISceneActivationStateForegroundInactive,
    2 => UISceneActivationStateBackground,
    _ => throw ArgumentError('Unknown value for UISceneActivationState: $value'),
  };
}

final class CGContext extends ffi.Opaque {}

final class CGColor extends ffi.Opaque {}

final class CGColorSpace extends ffi.Opaque {}

final class CGImage extends ffi.Opaque {}

final class CGPath extends ffi.Opaque {}

final class CGLayer extends ffi.Opaque {}

final class __CGEvent extends ffi.Opaque {}

enum UIMenuElementState {
  UIMenuElementStateOff(0),
  UIMenuElementStateOn(1),
  UIMenuElementStateMixed(2);

  final int value;
  const UIMenuElementState(this.value);

  static UIMenuElementState fromValue(int value) => switch (value) {
    0 => UIMenuElementStateOff,
    1 => UIMenuElementStateOn,
    2 => UIMenuElementStateMixed,
    _ => throw ArgumentError('Unknown value for UIMenuElementState: $value'),
  };
}

enum UIMenuElementAttributes {
  UIMenuElementAttributesDisabled(1),
  UIMenuElementAttributesDestructive(2),
  UIMenuElementAttributesHidden(4);

  final int value;
  const UIMenuElementAttributes(this.value);

  static UIMenuElementAttributes fromValue(int value) => switch (value) {
    1 => UIMenuElementAttributesDisabled,
    2 => UIMenuElementAttributesDestructive,
    4 => UIMenuElementAttributesHidden,
    _ => throw ArgumentError('Unknown value for UIMenuElementAttributes: $value'),
  };
}

late final _class_UIMenuElement = objc.getClass("UIMenuElement");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)
      >
    >()
    .asFunction<
      bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)
    >();
late final _sel_title = objc.registerName("title");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_subtitle = objc.registerName("subtitle");
late final _sel_setSubtitle_ = objc.registerName("setSubtitle:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)
    >();
late final _class_UIImage = objc.getClass("UIImage");

/// UIImage
class UIImage extends objc.ObjCObjectBase {
  UIImage._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIImage] that points to the same underlying object as [other].
  UIImage.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIImage] that wraps the given raw object pointer.
  UIImage.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIImage].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIImage);
  }
}

extension UIImage$Methods on UIImage {}

late final _sel_image = objc.registerName("image");
typedef instancetype = ffi.Pointer<objc.ObjCObject>;
typedef Dartinstancetype = objc.ObjCObjectBase;
late final _sel_initWithCoder_ = objc.registerName("initWithCoder:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
instancetype _ObjCBlock_instancetype_ffiVoid_NSCoder_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => block.ref.target
    .cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
    .asFunction<instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_NSCoder_fnPtrCallable =
    ffi.Pointer.fromFunction<
          instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_instancetype_ffiVoid_NSCoder_fnPtrTrampoline)
        .cast();
instancetype _ObjCBlock_instancetype_ffiVoid_NSCoder_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => (objc.getBlockClosure(block) as instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(
  arg0,
  arg1,
);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_NSCoder_closureCallable =
    ffi.Pointer.fromFunction<
          instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_instancetype_ffiVoid_NSCoder_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>
    >
    ptr,
  ) => objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    objc.newPointerBlock(_ObjCBlock_instancetype_ffiVoid_NSCoder_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  fromFunction(Dartinstancetype? Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
        objc.newClosureBlock(
          _ObjCBlock_instancetype_ffiVoid_NSCoder_closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
              fn(arg0, objc.NSCoder.castFromPointer(arg1, retain: true, release: true))?.ref.retainAndReturnPointer() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_instancetype_ffiVoid_NSCoder_CallExtension
    on objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> {
  Dartinstancetype? call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer)
              .address ==
          0
      ? null
      : objc.ObjCObjectBase(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer),
          retain: false,
          release: true,
        );
}

late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.NSZone>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.NSZone>,
      )
    >();
late final _sel_alloc = objc.registerName("alloc");
late final _sel_supportsSecureCoding = objc.registerName("supportsSecureCoding");
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
bool _ObjCBlock_bool_ffiVoid_fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) => block
    .ref
    .target
    .cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>()
    .asFunction<bool Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
      _ObjCBlock_bool_ffiVoid_fnPtrTrampoline,
      false,
    ).cast();
bool _ObjCBlock_bool_ffiVoid_closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
      _ObjCBlock_bool_ffiVoid_closureTrampoline,
      false,
    ).cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_bool_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_ObjCBlock_bool_ffiVoid_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunction(
    bool Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _ObjCBlock_bool_ffiVoid_closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_bool_ffiVoid_CallExtension on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> {
  bool call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_encodeWithCoder_ = objc.registerName("encodeWithCoder:");
void _ObjCBlock_ffiVoid_ffiVoid_NSCoder_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
    .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSCoder_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_ffiVoid_ffiVoid_NSCoder_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSCoder_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSCoder_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_ffiVoid_ffiVoid_NSCoder_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSCoder_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
>
_ObjCBlock_ffiVoid_ffiVoid_NSCoder_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_NSCoder_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.isolateLocal(_ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSCoder_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_NSCoder_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, objc.NSCoder.castFromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> listener(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_NSCoder_listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, objc.NSCoder.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, objc.NSCoder.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, objc.NSCoder.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
      wrapper,
      retain: false,
      release: true,
    );
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSCoder_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// UIMenuElement
class UIMenuElement extends objc.NSObject implements objc.NSCopying, objc.NSSecureCoding {
  UIMenuElement._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIMenuElement', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIMenuElement] that points to the same underlying object as [other].
  UIMenuElement.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIMenuElement] that wraps the given raw object pointer.
  UIMenuElement.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIMenuElement].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIMenuElement);
  }

  /// new
  static UIMenuElement new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIMenuElement, _sel_new);
    return UIMenuElement.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIMenuElement allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(_class_UIMenuElement, _sel_allocWithZone_, zone);
    return UIMenuElement.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UIMenuElement alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UIMenuElement, _sel_alloc);
    return UIMenuElement.castFromPointer(_ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UIMenuElement, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of UIMenuElement constructed with the default `new` method.
  factory UIMenuElement() => new$();
}

extension UIMenuElement$Methods on UIMenuElement {
  /// The element's title.
  objc.NSString get title {
    objc.checkOsVersionInternal('UIMenuElement.title', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The element's subtitle.
  objc.NSString? get subtitle {
    objc.checkOsVersionInternal('UIMenuElement.subtitle', iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subtitle);
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The element's subtitle.
  set subtitle(objc.NSString? value) {
    objc.checkOsVersionInternal('UIMenuElement.setSubtitle:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setSubtitle_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Image to be displayed alongside the element's title.
  UIImage? get image {
    objc.checkOsVersionInternal('UIMenuElement.image', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_image);
    return _ret.address == 0 ? null : UIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithCoder:
  UIMenuElement? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0 ? null : UIMenuElement.castFromPointer(_ret, retain: false, release: true);
  }

  /// init
  UIMenuElement init() {
    objc.checkOsVersionInternal('UIMenuElement.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIMenuElement.castFromPointer(_ret, retain: false, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }
}

enum UIMenuOptions {
  /// Show children inline in parent, instead of hierarchically
  UIMenuOptionsDisplayInline(1),

  /// Indicates whether the menu should be rendered with a destructive appearance in its parent
  UIMenuOptionsDestructive(2),

  /// Indicates whether the menu (and any submenus) should only allow a single "on" menu item.
  UIMenuOptionsSingleSelection(32);

  final int value;
  const UIMenuOptions(this.value);

  static UIMenuOptions fromValue(int value) => switch (value) {
    1 => UIMenuOptionsDisplayInline,
    2 => UIMenuOptionsDestructive,
    32 => UIMenuOptionsSingleSelection,
    _ => throw ArgumentError('Unknown value for UIMenuOptions: $value'),
  };
}

late final _class_UIMenu = objc.getClass("UIMenu");
late final _sel_identifier = objc.registerName("identifier");
late final _sel_options = objc.registerName("options");
final _objc_msgSend_1cz0z8u = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_children = objc.registerName("children");
late final _sel_selectedElements = objc.registerName("selectedElements");
late final _sel_menuWithChildren_ = objc.registerName("menuWithChildren:");
late final _sel_menuWithTitle_children_ = objc.registerName("menuWithTitle:children:");
final _objc_msgSend_15qeuct = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_menuWithTitle_image_identifier_options_children_ = objc.registerName(
  "menuWithTitle:image:identifier:options:children:",
);
final _objc_msgSend_zjuvxo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_menuByReplacingChildren_ = objc.registerName("menuByReplacingChildren:");

/// UIMenu
class UIMenu extends UIMenuElement {
  UIMenu._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIMenu', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIMenu] that points to the same underlying object as [other].
  UIMenu.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIMenu] that wraps the given raw object pointer.
  UIMenu.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIMenu].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIMenu);
  }

  /// !
  /// @abstract Creates a UIMenu with an empty title, nil image, automatically generated identifier, and default options.
  ///
  /// @param children    The menu's action-based sub-elements and sub-menus.
  ///
  /// @return A new UIMenu.
  static UIMenu menuWithChildren(objc.NSArray children) {
    objc.checkOsVersionInternal('UIMenu.menuWithChildren:', iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_UIMenu, _sel_menuWithChildren_, children.ref.pointer);
    return UIMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @abstract Creates a UIMenu with the given arguments.
  ///
  /// @param title       The menu's title.
  /// @param children    The menu's action-based sub-elements and sub-menus.
  ///
  /// @return A new UIMenu.
  static UIMenu menuWithTitle(objc.NSString title, {required objc.NSArray children}) {
    final _ret = _objc_msgSend_15qeuct(
      _class_UIMenu,
      _sel_menuWithTitle_children_,
      title.ref.pointer,
      children.ref.pointer,
    );
    return UIMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @abstract Creates a UIMenu with the given arguments.
  ///
  /// @param title       The menu's title.
  /// @param image       Image to be displayed alongside the menu's title.
  /// @param identifier  The menu's unique identifier. Pass nil to use an auto-generated identifier.
  /// @param options     The menu's options.
  /// @param children    The menu's action-based sub-elements and sub-menus.
  ///
  /// @return A new UIMenu.
  static UIMenu menuWithTitle$1(
    objc.NSString title, {
    UIImage? image,
    objc.NSString? identifier,
    required UIMenuOptions options,
    required objc.NSArray children,
  }) {
    final _ret = _objc_msgSend_zjuvxo(
      _class_UIMenu,
      _sel_menuWithTitle_image_identifier_options_children_,
      title.ref.pointer,
      image?.ref.pointer ?? ffi.nullptr,
      identifier?.ref.pointer ?? ffi.nullptr,
      options.value,
      children.ref.pointer,
    );
    return UIMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static UIMenu new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIMenu, _sel_new);
    return UIMenu.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIMenu allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(_class_UIMenu, _sel_allocWithZone_, zone);
    return UIMenu.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UIMenu alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UIMenu, _sel_alloc);
    return UIMenu.castFromPointer(_ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UIMenu, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of UIMenu constructed with the default `new` method.
  factory UIMenu() => new$();
}

extension UIMenu$Methods on UIMenu {
  /// Unique identifier.
  objc.NSString get identifier {
    objc.checkOsVersionInternal('UIMenu.identifier', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_identifier);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Options.
  UIMenuOptions get options {
    objc.checkOsVersionInternal('UIMenu.options', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_1cz0z8u(this.ref.pointer, _sel_options);
    return UIMenuOptions.fromValue(_ret);
  }

  /// The menu's sub-elements and sub-menus. On iOS 14.0, elements of your own menus are mutable, -copying a menu will produce mutable elements, and UIKit will take immutable copies of menus it receives. Prior to iOS 14.0, menus are always fully immutable.
  objc.NSArray get children {
    objc.checkOsVersionInternal('UIMenu.children', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_children);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// The element(s) in the menu and sub-menus that have an "on" menu item state.
  objc.NSArray get selectedElements {
    objc.checkOsVersionInternal('UIMenu.selectedElements', iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_selectedElements);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithCoder:
  UIMenu? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0 ? null : UIMenu.castFromPointer(_ret, retain: false, release: true);
  }

  /// init
  UIMenu init() {
    objc.checkOsVersionInternal('UIMenu.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIMenu.castFromPointer(_ret, retain: false, release: true);
  }

  /// !
  /// @abstract Copies this menu and replaces its children.
  ///
  /// @param newChildren  The replacement children.
  ///
  /// @return A copy of this menu with updated children.
  UIMenu menuByReplacingChildren(objc.NSArray newChildren) {
    objc.checkOsVersionInternal('UIMenu.menuByReplacingChildren:', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer, _sel_menuByReplacingChildren_, newChildren.ref.pointer);
    return UIMenu.castFromPointer(_ret, retain: true, release: true);
  }
}

enum UIKeyModifierFlags {
  UIKeyModifierAlphaShift(65536),
  UIKeyModifierShift(131072),
  UIKeyModifierControl(262144),
  UIKeyModifierAlternate(524288),
  UIKeyModifierCommand(1048576),
  UIKeyModifierNumericPad(2097152);

  final int value;
  const UIKeyModifierFlags(this.value);

  static UIKeyModifierFlags fromValue(int value) => switch (value) {
    65536 => UIKeyModifierAlphaShift,
    131072 => UIKeyModifierShift,
    262144 => UIKeyModifierControl,
    524288 => UIKeyModifierAlternate,
    1048576 => UIKeyModifierCommand,
    2097152 => UIKeyModifierNumericPad,
    _ => throw ArgumentError('Unknown value for UIKeyModifierFlags: $value'),
  };
}

/// WARNING: UICommand is a stub. To generate bindings for this class, include
/// UICommand in your config's objc-interfaces list.
///
/// Represents an action to take.
class UICommand extends UIMenuElement {
  UICommand._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UICommand', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UICommand] that points to the same underlying object as [other].
  UICommand.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UICommand] that wraps the given raw object pointer.
  UICommand.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

enum UIEventType {
  UIEventTypeTouches(0),
  UIEventTypeMotion(1),
  UIEventTypeRemoteControl(2),
  UIEventTypePresses(3),
  UIEventTypeScroll(10),
  UIEventTypeHover(11),
  UIEventTypeTransform(14);

  final int value;
  const UIEventType(this.value);

  static UIEventType fromValue(int value) => switch (value) {
    0 => UIEventTypeTouches,
    1 => UIEventTypeMotion,
    2 => UIEventTypeRemoteControl,
    3 => UIEventTypePresses,
    10 => UIEventTypeScroll,
    11 => UIEventTypeHover,
    14 => UIEventTypeTransform,
    _ => throw ArgumentError('Unknown value for UIEventType: $value'),
  };
}

enum UIEventSubtype {
  UIEventSubtypeNone(0),
  UIEventSubtypeMotionShake(1),
  UIEventSubtypeRemoteControlPlay(100),
  UIEventSubtypeRemoteControlPause(101),
  UIEventSubtypeRemoteControlStop(102),
  UIEventSubtypeRemoteControlTogglePlayPause(103),
  UIEventSubtypeRemoteControlNextTrack(104),
  UIEventSubtypeRemoteControlPreviousTrack(105),
  UIEventSubtypeRemoteControlBeginSeekingBackward(106),
  UIEventSubtypeRemoteControlEndSeekingBackward(107),
  UIEventSubtypeRemoteControlBeginSeekingForward(108),
  UIEventSubtypeRemoteControlEndSeekingForward(109);

  final int value;
  const UIEventSubtype(this.value);

  static UIEventSubtype fromValue(int value) => switch (value) {
    0 => UIEventSubtypeNone,
    1 => UIEventSubtypeMotionShake,
    100 => UIEventSubtypeRemoteControlPlay,
    101 => UIEventSubtypeRemoteControlPause,
    102 => UIEventSubtypeRemoteControlStop,
    103 => UIEventSubtypeRemoteControlTogglePlayPause,
    104 => UIEventSubtypeRemoteControlNextTrack,
    105 => UIEventSubtypeRemoteControlPreviousTrack,
    106 => UIEventSubtypeRemoteControlBeginSeekingBackward,
    107 => UIEventSubtypeRemoteControlEndSeekingBackward,
    108 => UIEventSubtypeRemoteControlBeginSeekingForward,
    109 => UIEventSubtypeRemoteControlEndSeekingForward,
    _ => throw ArgumentError('Unknown value for UIEventSubtype: $value'),
  };
}

/// Set of buttons pressed for the current event
/// Raw format of: 1 << (buttonNumber - 1)
/// UIEventButtonMaskPrimary = 1 << 0
enum UIEventButtonMask {
  UIEventButtonMaskPrimary(1),
  UIEventButtonMaskSecondary(2);

  final int value;
  const UIEventButtonMask(this.value);

  static UIEventButtonMask fromValue(int value) => switch (value) {
    1 => UIEventButtonMaskPrimary,
    2 => UIEventButtonMaskSecondary,
    _ => throw ArgumentError('Unknown value for UIEventButtonMask: $value'),
  };
}

/// WARNING: UIEvent is a stub. To generate bindings for this class, include
/// UIEvent in your config's objc-interfaces list.
///
/// UIEvent
class UIEvent extends objc.NSObject {
  UIEvent._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIEvent', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIEvent] that points to the same underlying object as [other].
  UIEvent.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIEvent] that wraps the given raw object pointer.
  UIEvent.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: UIKeyCommand is a stub. To generate bindings for this class, include
/// UIKeyCommand in your config's objc-interfaces list.
///
/// UIKeyCommand
class UIKeyCommand extends UICommand {
  UIKeyCommand._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIKeyCommand', iOS: (false, (7, 0, 0)));
  }

  /// Constructs a [UIKeyCommand] that points to the same underlying object as [other].
  UIKeyCommand.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIKeyCommand] that wraps the given raw object pointer.
  UIKeyCommand.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: UIUserActivityRestoring is a stub. To generate bindings for this class, include
/// UIUserActivityRestoring in your config's objc-protocols list.
///
/// UIUserActivityRestoring
interface class UIUserActivityRestoring extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIUserActivityRestoring._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIUserActivityRestoring] that points to the same underlying object as [other].
  UIUserActivityRestoring.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIUserActivityRestoring] that wraps the given raw object pointer.
  UIUserActivityRestoring.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSDictionary_NSDictionary_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
    .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSDictionary_NSDictionary_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_NSDictionary_NSDictionary_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSDictionary_NSDictionary_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSDictionary_NSDictionary_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_NSDictionary_NSDictionary_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>`.
abstract final class ObjCBlock_NSDictionary_NSDictionary {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject> arg0)>> ptr,
  ) => objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>(
    objc.newPointerBlock(_ObjCBlock_NSDictionary_NSDictionary_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> fromFunction(
    objc.NSDictionary Function(objc.NSDictionary) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>(
    objc.newClosureBlock(
      _ObjCBlock_NSDictionary_NSDictionary_closureCallable,
      (ffi.Pointer<objc.ObjCObject> arg0) =>
          fn(objc.NSDictionary.castFromPointer(arg0, retain: true, release: true)).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>`.
extension ObjCBlock_NSDictionary_NSDictionary_CallExtension
    on objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> {
  objc.NSDictionary call(objc.NSDictionary arg0) => objc.NSDictionary.castFromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<objc.ObjCObject> arg0,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
        >()(ref.pointer, arg0.ref.pointer),
    retain: true,
    release: true,
  );
}

enum UIEditingInteractionConfiguration {
  UIEditingInteractionConfigurationNone(0),
  UIEditingInteractionConfigurationDefault(1);

  final int value;
  const UIEditingInteractionConfiguration(this.value);

  static UIEditingInteractionConfiguration fromValue(int value) => switch (value) {
    0 => UIEditingInteractionConfigurationNone,
    1 => UIEditingInteractionConfigurationDefault,
    _ => throw ArgumentError('Unknown value for UIEditingInteractionConfiguration: $value'),
  };
}

/// WARNING: UIResponderStandardEditActions is a stub. To generate bindings for this class, include
/// UIResponderStandardEditActions in your config's objc-protocols list.
///
/// UIResponderStandardEditActions
interface class UIResponderStandardEditActions extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIResponderStandardEditActions._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIResponderStandardEditActions] that points to the same underlying object as [other].
  UIResponderStandardEditActions.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIResponderStandardEditActions] that wraps the given raw object pointer.
  UIResponderStandardEditActions.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _class_UIResponder = objc.getClass("UIResponder");
late final _sel_keyCommands = objc.registerName("keyCommands");

/// UIResponderKeyCommands
extension UIResponderKeyCommands on UIResponder {
  /// keyCommands
  objc.NSArray? get keyCommands {
    objc.checkOsVersionInternal('UIResponder.keyCommands', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_keyCommands);
    return _ret.address == 0 ? null : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _class_UIView = objc.getClass("UIView");

/// WARNING: UIAppearance is a stub. To generate bindings for this class, include
/// UIAppearance in your config's objc-protocols list.
///
/// UIAppearance
interface class UIAppearance extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIAppearance._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIAppearance] that points to the same underlying object as [other].
  UIAppearance.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIAppearance] that wraps the given raw object pointer.
  UIAppearance.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: UIAppearanceContainer is a stub. To generate bindings for this class, include
/// UIAppearanceContainer in your config's objc-protocols list.
///
/// UIAppearanceContainer
interface class UIAppearanceContainer extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIAppearanceContainer._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIAppearanceContainer] that points to the same underlying object as [other].
  UIAppearanceContainer.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIAppearanceContainer] that wraps the given raw object pointer.
  UIAppearanceContainer.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: UIDynamicItem is a stub. To generate bindings for this class, include
/// UIDynamicItem in your config's objc-protocols list.
///
/// UIDynamicItem
interface class UIDynamicItem extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIDynamicItem._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIDynamicItem] that points to the same underlying object as [other].
  UIDynamicItem.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIDynamicItem] that wraps the given raw object pointer.
  UIDynamicItem.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: UITraitEnvironment is a stub. To generate bindings for this class, include
/// UITraitEnvironment in your config's objc-protocols list.
///
/// ! Trait environments expose a trait collection that describes their environment.
interface class UITraitEnvironment extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UITraitEnvironment._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UITraitEnvironment] that points to the same underlying object as [other].
  UITraitEnvironment.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITraitEnvironment] that wraps the given raw object pointer.
  UITraitEnvironment.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: UICoordinateSpace is a stub. To generate bindings for this class, include
/// UICoordinateSpace in your config's objc-protocols list.
///
/// UICoordinateSpace
interface class UICoordinateSpace extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UICoordinateSpace._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UICoordinateSpace] that points to the same underlying object as [other].
  UICoordinateSpace.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UICoordinateSpace] that wraps the given raw object pointer.
  UICoordinateSpace.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: UIFocusItem is a stub. To generate bindings for this class, include
/// UIFocusItem in your config's objc-protocols list.
///
/// Objects conforming to UIFocusItem are considered capable of participating in focus. Only UIFocusItems can ever be focused.
interface class UIFocusItem extends objc.ObjCProtocolBase implements UIFocusEnvironment {
  UIFocusItem._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIFocusItem] that points to the same underlying object as [other].
  UIFocusItem.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusItem] that wraps the given raw object pointer.
  UIFocusItem.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: UIFocusItemContainer is a stub. To generate bindings for this class, include
/// UIFocusItemContainer in your config's objc-protocols list.
///
/// Objects conforming to UIFocusItemContainer are responsible for providing which focus items they
/// contain and where they are.
interface class UIFocusItemContainer extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIFocusItemContainer._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIFocusItemContainer] that points to the same underlying object as [other].
  UIFocusItemContainer.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusItemContainer] that wraps the given raw object pointer.
  UIFocusItemContainer.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: CALayerDelegate is a stub. To generate bindings for this class, include
/// CALayerDelegate in your config's objc-protocols list.
///
/// CALayerDelegate
interface class CALayerDelegate extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  CALayerDelegate._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [CALayerDelegate] that points to the same underlying object as [other].
  CALayerDelegate.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CALayerDelegate] that wraps the given raw object pointer.
  CALayerDelegate.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_frame = objc.registerName("frame");
final _objc_msgSend_bu1hbw = objc.msgSendPointer
    .cast<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_bu1hbwStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.CGRect>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.CGRect>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
late final _sel_setFrame_ = objc.registerName("setFrame:");
final _objc_msgSend_1okkq16 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect)>();
late final _sel_bounds = objc.registerName("bounds");
late final _sel_setBounds_ = objc.registerName("setBounds:");
late final _sel_center = objc.registerName("center");
final _objc_msgSend_1uwdhlk = objc.msgSendPointer
    .cast<ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1uwdhlkStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.CGPoint>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.CGPoint>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
late final _sel_setCenter_ = objc.registerName("setCenter:");
final _objc_msgSend_iy8iz6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGPoint)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGPoint)>();
late final _sel_transform = objc.registerName("transform");
final _objc_msgSend_5qswvj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<CGAffineTransform Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>
    >()
    .asFunction<CGAffineTransform Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_5qswvjStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<CGAffineTransform>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<CGAffineTransform>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
late final _sel_setTransform_ = objc.registerName("setTransform:");
final _objc_msgSend_qgt66z = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, CGAffineTransform)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, CGAffineTransform)>();

final class CATransform3D extends ffi.Struct {
  @ffi.Double()
  external double m11;

  @ffi.Double()
  external double m12;

  @ffi.Double()
  external double m13;

  @ffi.Double()
  external double m14;

  @ffi.Double()
  external double m21;

  @ffi.Double()
  external double m22;

  @ffi.Double()
  external double m23;

  @ffi.Double()
  external double m24;

  @ffi.Double()
  external double m31;

  @ffi.Double()
  external double m32;

  @ffi.Double()
  external double m33;

  @ffi.Double()
  external double m34;

  @ffi.Double()
  external double m41;

  @ffi.Double()
  external double m42;

  @ffi.Double()
  external double m43;

  @ffi.Double()
  external double m44;
}

late final _sel_transform3D = objc.registerName("transform3D");
final _objc_msgSend_5qlg3j = objc.msgSendPointer
    .cast<ffi.NativeFunction<CATransform3D Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<CATransform3D Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_5qlg3jStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<CATransform3D>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<CATransform3D>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
late final _sel_setTransform3D_ = objc.registerName("setTransform3D:");
final _objc_msgSend_1s50tpz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, CATransform3D)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, CATransform3D)>();
late final _sel_contentScaleFactor = objc.registerName("contentScaleFactor");
final _objc_msgSend_1ukqyt8 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<double Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1ukqyt8Fpret = objc.msgSendFpretPointer
    .cast<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<double Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setContentScaleFactor_ = objc.registerName("setContentScaleFactor:");
final _objc_msgSend_hwm8nu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Double)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, double)>();
late final _sel_isMultipleTouchEnabled = objc.registerName("isMultipleTouchEnabled");
late final _sel_setMultipleTouchEnabled_ = objc.registerName("setMultipleTouchEnabled:");
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, bool)>();
late final _sel_isExclusiveTouch = objc.registerName("isExclusiveTouch");
late final _sel_setExclusiveTouch_ = objc.registerName("setExclusiveTouch:");
late final _sel_hitTest_withEvent_ = objc.registerName("hitTest:withEvent:");
final _objc_msgSend_u7nfz8 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_pointInside_withEvent_ = objc.registerName("pointInside:withEvent:");
final _objc_msgSend_yvwe5y = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_convertPoint_toView_ = objc.registerName("convertPoint:toView:");
final _objc_msgSend_3l1tu1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGPoint Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      objc.CGPoint Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_3l1tu1Stret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGPoint>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGPoint>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_convertPoint_fromView_ = objc.registerName("convertPoint:fromView:");
late final _sel_convertRect_toView_ = objc.registerName("convertRect:toView:");
final _objc_msgSend_2olghr = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_2olghrStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_convertRect_fromView_ = objc.registerName("convertRect:fromView:");
late final _sel_autoresizesSubviews = objc.registerName("autoresizesSubviews");
late final _sel_setAutoresizesSubviews_ = objc.registerName("setAutoresizesSubviews:");

enum UIViewAutoresizing {
  UIViewAutoresizingNone(0),
  UIViewAutoresizingFlexibleLeftMargin(1),
  UIViewAutoresizingFlexibleWidth(2),
  UIViewAutoresizingFlexibleRightMargin(4),
  UIViewAutoresizingFlexibleTopMargin(8),
  UIViewAutoresizingFlexibleHeight(16),
  UIViewAutoresizingFlexibleBottomMargin(32);

  final int value;
  const UIViewAutoresizing(this.value);

  static UIViewAutoresizing fromValue(int value) => switch (value) {
    0 => UIViewAutoresizingNone,
    1 => UIViewAutoresizingFlexibleLeftMargin,
    2 => UIViewAutoresizingFlexibleWidth,
    4 => UIViewAutoresizingFlexibleRightMargin,
    8 => UIViewAutoresizingFlexibleTopMargin,
    16 => UIViewAutoresizingFlexibleHeight,
    32 => UIViewAutoresizingFlexibleBottomMargin,
    _ => throw ArgumentError('Unknown value for UIViewAutoresizing: $value'),
  };
}

late final _sel_autoresizingMask = objc.registerName("autoresizingMask");
final _objc_msgSend_sq30wq = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setAutoresizingMask_ = objc.registerName("setAutoresizingMask:");
final _objc_msgSend_qjq6uk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_sizeThatFits_ = objc.registerName("sizeThatFits:");
final _objc_msgSend_1owrp3b = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGSize Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGSize)
      >
    >()
    .asFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGSize)>();
final _objc_msgSend_1owrp3bStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGSize>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGSize,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.CGSize>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGSize)
    >();
late final _sel_sizeToFit = objc.registerName("sizeToFit");
final _objc_msgSend_1pl9qdv = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// UIViewGeometry
extension UIViewGeometry on UIView {
  /// frame
  objc.CGRect get frame {
    objc.checkOsVersionInternal('UIView.frame', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(_ptr, this.ref.pointer, _sel_frame)
        : _ptr.ref = _objc_msgSend_bu1hbw(this.ref.pointer, _sel_frame);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// setFrame:
  set frame(objc.CGRect value) {
    objc.checkOsVersionInternal('UIView.setFrame:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1okkq16(this.ref.pointer, _sel_setFrame_, value);
  }

  /// bounds
  objc.CGRect get bounds {
    objc.checkOsVersionInternal('UIView.bounds', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(_ptr, this.ref.pointer, _sel_bounds)
        : _ptr.ref = _objc_msgSend_bu1hbw(this.ref.pointer, _sel_bounds);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// setBounds:
  set bounds(objc.CGRect value) {
    objc.checkOsVersionInternal('UIView.setBounds:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1okkq16(this.ref.pointer, _sel_setBounds_, value);
  }

  /// center
  objc.CGPoint get center {
    objc.checkOsVersionInternal('UIView.center', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret(_ptr, this.ref.pointer, _sel_center)
        : _ptr.ref = _objc_msgSend_1uwdhlk(this.ref.pointer, _sel_center);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// setCenter:
  set center(objc.CGPoint value) {
    objc.checkOsVersionInternal('UIView.setCenter:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_iy8iz6(this.ref.pointer, _sel_setCenter_, value);
  }

  /// transform
  CGAffineTransform get transform {
    objc.checkOsVersionInternal('UIView.transform', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<CGAffineTransform>();
    objc.useMsgSendVariants
        ? _objc_msgSend_5qswvjStret(_ptr, this.ref.pointer, _sel_transform)
        : _ptr.ref = _objc_msgSend_5qswvj(this.ref.pointer, _sel_transform);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<CGAffineTransform>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<CGAffineTransform>(_finalizable);
  }

  /// setTransform:
  set transform(CGAffineTransform value) {
    objc.checkOsVersionInternal('UIView.setTransform:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_qgt66z(this.ref.pointer, _sel_setTransform_, value);
  }

  /// transform3D
  CATransform3D get transform3D {
    objc.checkOsVersionInternal('UIView.transform3D', iOS: (false, (13, 0, 0)));
    final _ptr = pkg_ffi.calloc<CATransform3D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_5qlg3jStret(_ptr, this.ref.pointer, _sel_transform3D)
        : _ptr.ref = _objc_msgSend_5qlg3j(this.ref.pointer, _sel_transform3D);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<CATransform3D>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<CATransform3D>(_finalizable);
  }

  /// setTransform3D:
  set transform3D(CATransform3D value) {
    objc.checkOsVersionInternal('UIView.setTransform3D:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_1s50tpz(this.ref.pointer, _sel_setTransform3D_, value);
  }

  /// contentScaleFactor
  double get contentScaleFactor {
    objc.checkOsVersionInternal('UIView.contentScaleFactor', iOS: (false, (4, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_contentScaleFactor)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_contentScaleFactor);
  }

  /// setContentScaleFactor:
  set contentScaleFactor(double value) {
    objc.checkOsVersionInternal('UIView.setContentScaleFactor:', iOS: (false, (4, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setContentScaleFactor_, value);
  }

  /// isMultipleTouchEnabled
  bool get multipleTouchEnabled {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isMultipleTouchEnabled);
  }

  /// setMultipleTouchEnabled:
  set multipleTouchEnabled(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setMultipleTouchEnabled_, value);
  }

  /// isExclusiveTouch
  bool get exclusiveTouch {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isExclusiveTouch);
  }

  /// setExclusiveTouch:
  set exclusiveTouch(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setExclusiveTouch_, value);
  }

  /// hitTest:withEvent:
  UIView? hitTest(objc.CGPoint point, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIView.hitTest:withEvent:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_u7nfz8(
      this.ref.pointer,
      _sel_hitTest_withEvent_,
      point,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
    return _ret.address == 0 ? null : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// pointInside:withEvent:
  bool pointInside(objc.CGPoint point, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIView.pointInside:withEvent:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_yvwe5y(
      this.ref.pointer,
      _sel_pointInside_withEvent_,
      point,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// convertPoint:toView:
  objc.CGPoint convertPoint(objc.CGPoint point, {UIView? toView}) {
    objc.checkOsVersionInternal('UIView.convertPoint:toView:', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            _ptr,
            this.ref.pointer,
            _sel_convertPoint_toView_,
            point,
            toView?.ref.pointer ?? ffi.nullptr,
          )
        : _ptr.ref = _objc_msgSend_3l1tu1(
            this.ref.pointer,
            _sel_convertPoint_toView_,
            point,
            toView?.ref.pointer ?? ffi.nullptr,
          );
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// convertPoint:fromView:
  objc.CGPoint convertPoint$1(objc.CGPoint point, {UIView? fromView}) {
    objc.checkOsVersionInternal('UIView.convertPoint:fromView:', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            _ptr,
            this.ref.pointer,
            _sel_convertPoint_fromView_,
            point,
            fromView?.ref.pointer ?? ffi.nullptr,
          )
        : _ptr.ref = _objc_msgSend_3l1tu1(
            this.ref.pointer,
            _sel_convertPoint_fromView_,
            point,
            fromView?.ref.pointer ?? ffi.nullptr,
          );
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// convertRect:toView:
  objc.CGRect convertRect(objc.CGRect rect, {UIView? toView}) {
    objc.checkOsVersionInternal('UIView.convertRect:toView:', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            _ptr,
            this.ref.pointer,
            _sel_convertRect_toView_,
            rect,
            toView?.ref.pointer ?? ffi.nullptr,
          )
        : _ptr.ref = _objc_msgSend_2olghr(
            this.ref.pointer,
            _sel_convertRect_toView_,
            rect,
            toView?.ref.pointer ?? ffi.nullptr,
          );
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// convertRect:fromView:
  objc.CGRect convertRect$1(objc.CGRect rect, {UIView? fromView}) {
    objc.checkOsVersionInternal('UIView.convertRect:fromView:', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            _ptr,
            this.ref.pointer,
            _sel_convertRect_fromView_,
            rect,
            fromView?.ref.pointer ?? ffi.nullptr,
          )
        : _ptr.ref = _objc_msgSend_2olghr(
            this.ref.pointer,
            _sel_convertRect_fromView_,
            rect,
            fromView?.ref.pointer ?? ffi.nullptr,
          );
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// autoresizesSubviews
  bool get autoresizesSubviews {
    objc.checkOsVersionInternal('UIView.autoresizesSubviews', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_autoresizesSubviews);
  }

  /// setAutoresizesSubviews:
  set autoresizesSubviews(bool value) {
    objc.checkOsVersionInternal('UIView.setAutoresizesSubviews:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setAutoresizesSubviews_, value);
  }

  /// autoresizingMask
  UIViewAutoresizing get autoresizingMask {
    objc.checkOsVersionInternal('UIView.autoresizingMask', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_sq30wq(this.ref.pointer, _sel_autoresizingMask);
    return UIViewAutoresizing.fromValue(_ret);
  }

  /// setAutoresizingMask:
  set autoresizingMask(UIViewAutoresizing value) {
    objc.checkOsVersionInternal('UIView.setAutoresizingMask:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_qjq6uk(this.ref.pointer, _sel_setAutoresizingMask_, value.value);
  }

  /// sizeThatFits:
  objc.CGSize sizeThatFits(objc.CGSize size) {
    objc.checkOsVersionInternal('UIView.sizeThatFits:', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1owrp3bStret(_ptr, this.ref.pointer, _sel_sizeThatFits_, size)
        : _ptr.ref = _objc_msgSend_1owrp3b(this.ref.pointer, _sel_sizeThatFits_, size);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// sizeToFit
  void sizeToFit() {
    objc.checkOsVersionInternal('UIView.sizeToFit', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_sizeToFit);
  }
}

late final _sel_superview = objc.registerName("superview");
late final _sel_subviews = objc.registerName("subviews");
late final _class_UIWindow = objc.getClass("UIWindow");

/// WARNING: UIWindowScene is a stub. To generate bindings for this class, include
/// UIWindowScene in your config's objc-interfaces list.
///
/// UIWindowScene
class UIWindowScene extends UIScene {
  UIWindowScene._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIWindowScene', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIWindowScene] that points to the same underlying object as [other].
  UIWindowScene.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIWindowScene] that wraps the given raw object pointer.
  UIWindowScene.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_initWithWindowScene_ = objc.registerName("initWithWindowScene:");
late final _sel_windowScene = objc.registerName("windowScene");
late final _sel_setWindowScene_ = objc.registerName("setWindowScene:");
late final _sel_canResizeToFitContent = objc.registerName("canResizeToFitContent");
late final _sel_setCanResizeToFitContent_ = objc.registerName("setCanResizeToFitContent:");

/// WARNING: UIScreen is a stub. To generate bindings for this class, include
/// UIScreen in your config's objc-interfaces list.
///
/// UIScreen
class UIScreen extends objc.ObjCObjectBase {
  UIScreen._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIScreen] that points to the same underlying object as [other].
  UIScreen.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIScreen] that wraps the given raw object pointer.
  UIScreen.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_screen = objc.registerName("screen");
late final _sel_setScreen_ = objc.registerName("setScreen:");
late final _sel_windowLevel = objc.registerName("windowLevel");
late final _sel_setWindowLevel_ = objc.registerName("setWindowLevel:");
late final _sel_isKeyWindow = objc.registerName("isKeyWindow");
late final _sel_canBecomeKeyWindow = objc.registerName("canBecomeKeyWindow");
late final _sel_becomeKeyWindow = objc.registerName("becomeKeyWindow");
late final _sel_resignKeyWindow = objc.registerName("resignKeyWindow");
late final _sel_makeKeyWindow = objc.registerName("makeKeyWindow");
late final _sel_makeKeyAndVisible = objc.registerName("makeKeyAndVisible");
late final _class_UIViewController = objc.getClass("UIViewController");

/// WARNING: UIContentContainer is a stub. To generate bindings for this class, include
/// UIContentContainer in your config's objc-protocols list.
///
/// UIContentContainer
interface class UIContentContainer extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIContentContainer._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIContentContainer] that points to the same underlying object as [other].
  UIContentContainer.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIContentContainer] that wraps the given raw object pointer.
  UIContentContainer.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: UIFocusEnvironment is a stub. To generate bindings for this class, include
/// UIFocusEnvironment in your config's objc-protocols list.
///
/// Objects conforming to UIFocusEnvironment influence and respond to focus behavior within a specific area of the screen that they control.
interface class UIFocusEnvironment extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIFocusEnvironment._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIFocusEnvironment] that points to the same underlying object as [other].
  UIFocusEnvironment.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusEnvironment] that wraps the given raw object pointer.
  UIFocusEnvironment.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_attemptRotationToDeviceOrientation = objc.registerName("attemptRotationToDeviceOrientation");

enum UIInterfaceOrientation {
  UIInterfaceOrientationUnknown(0),
  UIInterfaceOrientationPortrait(1),
  UIInterfaceOrientationPortraitUpsideDown(2),
  UIInterfaceOrientationLandscapeLeft(4),
  UIInterfaceOrientationLandscapeRight(3);

  final int value;
  const UIInterfaceOrientation(this.value);

  static UIInterfaceOrientation fromValue(int value) => switch (value) {
    0 => UIInterfaceOrientationUnknown,
    1 => UIInterfaceOrientationPortrait,
    2 => UIInterfaceOrientationPortraitUpsideDown,
    4 => UIInterfaceOrientationLandscapeLeft,
    3 => UIInterfaceOrientationLandscapeRight,
    _ => throw ArgumentError('Unknown value for UIInterfaceOrientation: $value'),
  };
}

late final _sel_shouldAutorotateToInterfaceOrientation_ = objc.registerName("shouldAutorotateToInterfaceOrientation:");
final _objc_msgSend_1p4s9xc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_shouldAutorotate = objc.registerName("shouldAutorotate");

enum UIInterfaceOrientationMask {
  UIInterfaceOrientationMaskPortrait(2),
  UIInterfaceOrientationMaskLandscapeLeft(16),
  UIInterfaceOrientationMaskLandscapeRight(8),
  UIInterfaceOrientationMaskPortraitUpsideDown(4),
  UIInterfaceOrientationMaskLandscape(24),
  UIInterfaceOrientationMaskAll(30),
  UIInterfaceOrientationMaskAllButUpsideDown(26);

  final int value;
  const UIInterfaceOrientationMask(this.value);

  static UIInterfaceOrientationMask fromValue(int value) => switch (value) {
    2 => UIInterfaceOrientationMaskPortrait,
    16 => UIInterfaceOrientationMaskLandscapeLeft,
    8 => UIInterfaceOrientationMaskLandscapeRight,
    4 => UIInterfaceOrientationMaskPortraitUpsideDown,
    24 => UIInterfaceOrientationMaskLandscape,
    30 => UIInterfaceOrientationMaskAll,
    26 => UIInterfaceOrientationMaskAllButUpsideDown,
    _ => throw ArgumentError('Unknown value for UIInterfaceOrientationMask: $value'),
  };
}

late final _sel_supportedInterfaceOrientations = objc.registerName("supportedInterfaceOrientations");
final _objc_msgSend_1yyvh1k = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_preferredInterfaceOrientationForPresentation = objc.registerName(
  "preferredInterfaceOrientationForPresentation",
);
final _objc_msgSend_14s25dk = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_rotatingHeaderView = objc.registerName("rotatingHeaderView");
late final _sel_rotatingFooterView = objc.registerName("rotatingFooterView");
late final _sel_interfaceOrientation = objc.registerName("interfaceOrientation");
late final _sel_willRotateToInterfaceOrientation_duration_ = objc.registerName(
  "willRotateToInterfaceOrientation:duration:",
);
final _objc_msgSend_vscdhh = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long, ffi.Double)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int, double)>();
late final _sel_didRotateFromInterfaceOrientation_ = objc.registerName("didRotateFromInterfaceOrientation:");
final _objc_msgSend_13bsfjm = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_willAnimateRotationToInterfaceOrientation_duration_ = objc.registerName(
  "willAnimateRotationToInterfaceOrientation:duration:",
);
late final _sel_willAnimateFirstHalfOfRotationToInterfaceOrientation_duration_ = objc.registerName(
  "willAnimateFirstHalfOfRotationToInterfaceOrientation:duration:",
);
late final _sel_didAnimateFirstHalfOfRotationToInterfaceOrientation_ = objc.registerName(
  "didAnimateFirstHalfOfRotationToInterfaceOrientation:",
);
late final _sel_willAnimateSecondHalfOfRotationFromInterfaceOrientation_duration_ = objc.registerName(
  "willAnimateSecondHalfOfRotationFromInterfaceOrientation:duration:",
);

/// UIViewControllerRotation
extension UIViewControllerRotation on UIViewController {
  /// attemptRotationToDeviceOrientation
  static void attemptRotationToDeviceOrientation() {
    objc.checkOsVersionInternal('UIViewController.attemptRotationToDeviceOrientation', iOS: (false, (5, 0, 0)));
    _objc_msgSend_1pl9qdv(_class_UIViewController, _sel_attemptRotationToDeviceOrientation);
  }

  /// shouldAutorotateToInterfaceOrientation:
  bool shouldAutorotateToInterfaceOrientation(UIInterfaceOrientation toInterfaceOrientation) {
    objc.checkOsVersionInternal('UIViewController.shouldAutorotateToInterfaceOrientation:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1p4s9xc(
      this.ref.pointer,
      _sel_shouldAutorotateToInterfaceOrientation_,
      toInterfaceOrientation.value,
    );
  }

  /// shouldAutorotate
  bool get shouldAutorotate {
    objc.checkOsVersionInternal('UIViewController.shouldAutorotate', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_shouldAutorotate);
  }

  /// supportedInterfaceOrientations
  UIInterfaceOrientationMask get supportedInterfaceOrientations {
    objc.checkOsVersionInternal('UIViewController.supportedInterfaceOrientations', iOS: (false, (6, 0, 0)));
    final _ret = _objc_msgSend_1yyvh1k(this.ref.pointer, _sel_supportedInterfaceOrientations);
    return UIInterfaceOrientationMask.fromValue(_ret);
  }

  /// preferredInterfaceOrientationForPresentation
  UIInterfaceOrientation get preferredInterfaceOrientationForPresentation {
    objc.checkOsVersionInternal(
      'UIViewController.preferredInterfaceOrientationForPresentation',
      iOS: (false, (6, 0, 0)),
    );
    final _ret = _objc_msgSend_14s25dk(this.ref.pointer, _sel_preferredInterfaceOrientationForPresentation);
    return UIInterfaceOrientation.fromValue(_ret);
  }

  /// rotatingHeaderView
  UIView? rotatingHeaderView() {
    objc.checkOsVersionInternal('UIViewController.rotatingHeaderView', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_rotatingHeaderView);
    return _ret.address == 0 ? null : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// rotatingFooterView
  UIView? rotatingFooterView() {
    objc.checkOsVersionInternal('UIViewController.rotatingFooterView', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_rotatingFooterView);
    return _ret.address == 0 ? null : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// interfaceOrientation
  UIInterfaceOrientation get interfaceOrientation {
    objc.checkOsVersionInternal('UIViewController.interfaceOrientation', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_14s25dk(this.ref.pointer, _sel_interfaceOrientation);
    return UIInterfaceOrientation.fromValue(_ret);
  }

  /// willRotateToInterfaceOrientation:duration:
  void willRotateToInterfaceOrientation(UIInterfaceOrientation toInterfaceOrientation, {required double duration}) {
    objc.checkOsVersionInternal('UIViewController.willRotateToInterfaceOrientation:duration:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_vscdhh(
      this.ref.pointer,
      _sel_willRotateToInterfaceOrientation_duration_,
      toInterfaceOrientation.value,
      duration,
    );
  }

  /// didRotateFromInterfaceOrientation:
  void didRotateFromInterfaceOrientation(UIInterfaceOrientation fromInterfaceOrientation) {
    objc.checkOsVersionInternal('UIViewController.didRotateFromInterfaceOrientation:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_13bsfjm(this.ref.pointer, _sel_didRotateFromInterfaceOrientation_, fromInterfaceOrientation.value);
  }

  /// willAnimateRotationToInterfaceOrientation:duration:
  void willAnimateRotationToInterfaceOrientation(
    UIInterfaceOrientation toInterfaceOrientation, {
    required double duration,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.willAnimateRotationToInterfaceOrientation:duration:',
      iOS: (false, (3, 0, 0)),
    );
    _objc_msgSend_vscdhh(
      this.ref.pointer,
      _sel_willAnimateRotationToInterfaceOrientation_duration_,
      toInterfaceOrientation.value,
      duration,
    );
  }

  /// willAnimateFirstHalfOfRotationToInterfaceOrientation:duration:
  void willAnimateFirstHalfOfRotationToInterfaceOrientation(
    UIInterfaceOrientation toInterfaceOrientation, {
    required double duration,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.willAnimateFirstHalfOfRotationToInterfaceOrientation:duration:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_vscdhh(
      this.ref.pointer,
      _sel_willAnimateFirstHalfOfRotationToInterfaceOrientation_duration_,
      toInterfaceOrientation.value,
      duration,
    );
  }

  /// didAnimateFirstHalfOfRotationToInterfaceOrientation:
  void didAnimateFirstHalfOfRotationToInterfaceOrientation(UIInterfaceOrientation toInterfaceOrientation) {
    objc.checkOsVersionInternal(
      'UIViewController.didAnimateFirstHalfOfRotationToInterfaceOrientation:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_13bsfjm(
      this.ref.pointer,
      _sel_didAnimateFirstHalfOfRotationToInterfaceOrientation_,
      toInterfaceOrientation.value,
    );
  }

  /// willAnimateSecondHalfOfRotationFromInterfaceOrientation:duration:
  void willAnimateSecondHalfOfRotationFromInterfaceOrientation(
    UIInterfaceOrientation fromInterfaceOrientation, {
    required double duration,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.willAnimateSecondHalfOfRotationFromInterfaceOrientation:duration:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_vscdhh(
      this.ref.pointer,
      _sel_willAnimateSecondHalfOfRotationFromInterfaceOrientation_duration_,
      fromInterfaceOrientation.value,
      duration,
    );
  }
}

late final _sel_isEditing = objc.registerName("isEditing");
late final _sel_setEditing_ = objc.registerName("setEditing:");
late final _sel_setEditing_animated_ = objc.registerName("setEditing:animated:");
final _objc_msgSend_14iqu8t = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Bool, ffi.Bool)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, bool, bool)>();
late final _class_UIBarItem = objc.getClass("UIBarItem");
late final _sel_isEnabled = objc.registerName("isEnabled");
late final _sel_setEnabled_ = objc.registerName("setEnabled:");
late final _sel_setTitle_ = objc.registerName("setTitle:");
late final _sel_setImage_ = objc.registerName("setImage:");
late final _sel_landscapeImagePhone = objc.registerName("landscapeImagePhone");
late final _sel_setLandscapeImagePhone_ = objc.registerName("setLandscapeImagePhone:");
late final _sel_largeContentSizeImage = objc.registerName("largeContentSizeImage");
late final _sel_setLargeContentSizeImage_ = objc.registerName("setLargeContentSizeImage:");

final class UIEdgeInsets extends ffi.Struct {
  @ffi.Double()
  external double top;

  @ffi.Double()
  external double left;

  @ffi.Double()
  external double bottom;

  @ffi.Double()
  external double right;
}

late final _sel_imageInsets = objc.registerName("imageInsets");
final _objc_msgSend_ct4cu5 = objc.msgSendPointer
    .cast<ffi.NativeFunction<UIEdgeInsets Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<UIEdgeInsets Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_ct4cu5Stret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<UIEdgeInsets>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<UIEdgeInsets>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
late final _sel_setImageInsets_ = objc.registerName("setImageInsets:");
final _objc_msgSend_1g8fos5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, UIEdgeInsets)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, UIEdgeInsets)>();
late final _sel_landscapeImagePhoneInsets = objc.registerName("landscapeImagePhoneInsets");
late final _sel_setLandscapeImagePhoneInsets_ = objc.registerName("setLandscapeImagePhoneInsets:");
late final _sel_largeContentSizeImageInsets = objc.registerName("largeContentSizeImageInsets");
late final _sel_setLargeContentSizeImageInsets_ = objc.registerName("setLargeContentSizeImageInsets:");
late final _sel_tag = objc.registerName("tag");
final _objc_msgSend_1hz7y9r = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTag_ = objc.registerName("setTag:");
final _objc_msgSend_4sp4xj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();

enum UIControlState {
  UIControlStateNormal(0),
  UIControlStateHighlighted(1),
  UIControlStateDisabled(2),
  UIControlStateSelected(4),
  UIControlStateFocused(8),
  UIControlStateApplication(16711680),
  UIControlStateReserved(4278190080);

  final int value;
  const UIControlState(this.value);

  static UIControlState fromValue(int value) => switch (value) {
    0 => UIControlStateNormal,
    1 => UIControlStateHighlighted,
    2 => UIControlStateDisabled,
    4 => UIControlStateSelected,
    8 => UIControlStateFocused,
    16711680 => UIControlStateApplication,
    4278190080 => UIControlStateReserved,
    _ => throw ArgumentError('Unknown value for UIControlState: $value'),
  };
}

late final _sel_setTitleTextAttributes_forState_ = objc.registerName("setTitleTextAttributes:forState:");
final _objc_msgSend_dldayz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>, int)
    >();
late final _sel_titleTextAttributesForState_ = objc.registerName("titleTextAttributesForState:");
final _objc_msgSend_1g2zxsx = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)
    >();
late final _sel_appearance = objc.registerName("appearance");
instancetype _ObjCBlock_instancetype_ffiVoid_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => block.ref.target
    .cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0)>>()
    .asFunction<instancetype Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
      _ObjCBlock_instancetype_ffiVoid_fnPtrTrampoline,
    ).cast();
instancetype _ObjCBlock_instancetype_ffiVoid_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => (objc.getBlockClosure(block) as instancetype Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
      _ObjCBlock_instancetype_ffiVoid_closureTrampoline,
    ).cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_instancetype_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_ObjCBlock_instancetype_ffiVoid_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> fromFunction(
    Dartinstancetype Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _ObjCBlock_instancetype_ffiVoid_closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_instancetype_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0) => objc.ObjCObjectBase(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>
        >()
        .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
    retain: true,
    release: true,
  );
}

late final _sel_appearanceWhenContainedIn_ = objc.registerName("appearanceWhenContainedIn:");
instancetype _ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => block.ref.target
    .cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
    .asFunction<instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer_fnPtrCallable =
    ffi.Pointer.fromFunction<
          instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer_fnPtrTrampoline)
        .cast();
instancetype _ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => (objc.getBlockClosure(block) as instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(
  arg0,
  arg1,
);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer_closureCallable =
    ffi.Pointer.fromFunction<
          instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
    objc.newPointerBlock(_ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
  fromFunction(
    Dartinstancetype Function(ffi.Pointer<ffi.Void>, UIAppearanceContainer?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
    objc.newClosureBlock(
      _ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
        arg0,
        arg1.address == 0 ? null : UIAppearanceContainer.castFromPointer(arg1, retain: true, release: true),
      ).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>`.
extension ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer_CallExtension
    on objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, UIAppearanceContainer? arg1) => objc.ObjCObjectBase(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
              ffi.Pointer<objc.ObjCObject> arg1,
            )
          >
        >()
        .asFunction<
          instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr),
    retain: true,
    release: true,
  );
}

late final _sel_appearanceWhenContainedInInstancesOfClasses_ = objc.registerName(
  "appearanceWhenContainedInInstancesOfClasses:",
);
instancetype _ObjCBlock_instancetype_ffiVoid_NSArray_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => block.ref.target
    .cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
    .asFunction<instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_NSArray_fnPtrCallable =
    ffi.Pointer.fromFunction<
          instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_instancetype_ffiVoid_NSArray_fnPtrTrampoline)
        .cast();
instancetype _ObjCBlock_instancetype_ffiVoid_NSArray_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => (objc.getBlockClosure(block) as instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(
  arg0,
  arg1,
);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_NSArray_closureCallable =
    ffi.Pointer.fromFunction<
          instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_instancetype_ffiVoid_NSArray_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
    objc.newPointerBlock(_ObjCBlock_instancetype_ffiVoid_NSArray_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)> fromFunction(
    Dartinstancetype Function(ffi.Pointer<ffi.Void>, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
    objc.newClosureBlock(
      _ObjCBlock_instancetype_ffiVoid_NSArray_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, objc.NSArray.castFromPointer(arg1, retain: true, release: true)).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
extension ObjCBlock_instancetype_ffiVoid_NSArray_CallExtension
    on objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, objc.NSArray arg1) => objc.ObjCObjectBase(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
              ffi.Pointer<objc.ObjCObject> arg1,
            )
          >
        >()
        .asFunction<
          instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >()(ref.pointer, arg0, arg1.ref.pointer),
    retain: true,
    release: true,
  );
}

/// WARNING: UITraitCollection is a stub. To generate bindings for this class, include
/// UITraitCollection in your config's objc-interfaces list.
///
/// ! A trait collection encapsulates the system traits of an interface's environment.
class UITraitCollection extends objc.NSObject implements objc.NSCopying, objc.NSSecureCoding {
  UITraitCollection._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITraitCollection', iOS: (false, (8, 0, 0)));
  }

  /// Constructs a [UITraitCollection] that points to the same underlying object as [other].
  UITraitCollection.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITraitCollection] that wraps the given raw object pointer.
  UITraitCollection.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_appearanceForTraitCollection_ = objc.registerName("appearanceForTraitCollection:");
instancetype _ObjCBlock_instancetype_ffiVoid_UITraitCollection_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => block.ref.target
    .cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
    .asFunction<instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_UITraitCollection_fnPtrCallable =
    ffi.Pointer.fromFunction<
          instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_instancetype_ffiVoid_UITraitCollection_fnPtrTrampoline)
        .cast();
instancetype _ObjCBlock_instancetype_ffiVoid_UITraitCollection_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => (objc.getBlockClosure(block) as instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(
  arg0,
  arg1,
);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_UITraitCollection_closureCallable =
    ffi.Pointer.fromFunction<
          instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_instancetype_ffiVoid_UITraitCollection_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_UITraitCollection {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>(
    objc.newPointerBlock(_ObjCBlock_instancetype_ffiVoid_UITraitCollection_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection)> fromFunction(
    Dartinstancetype Function(ffi.Pointer<ffi.Void>, UITraitCollection) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>(
    objc.newClosureBlock(
      _ObjCBlock_instancetype_ffiVoid_UITraitCollection_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, UITraitCollection.castFromPointer(arg1, retain: true, release: true)).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>`.
extension ObjCBlock_instancetype_ffiVoid_UITraitCollection_CallExtension
    on objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, UITraitCollection arg1) => objc.ObjCObjectBase(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
              ffi.Pointer<objc.ObjCObject> arg1,
            )
          >
        >()
        .asFunction<
          instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >()(ref.pointer, arg0, arg1.ref.pointer),
    retain: true,
    release: true,
  );
}

late final _sel_appearanceForTraitCollection_whenContainedIn_ = objc.registerName(
  "appearanceForTraitCollection:whenContainedIn:",
);
instancetype _ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) => block.ref.target
    .cast<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >()
    .asFunction<
      instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)
    >()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer_fnPtrCallable =
    ffi.Pointer.fromFunction<
          instancetype Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer_fnPtrTrampoline)
        .cast();
instancetype _ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) =>
    (objc.getBlockClosure(block)
        as instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
      arg0,
      arg1,
      arg2,
    );
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer_closureCallable =
    ffi.Pointer.fromFunction<
          instancetype Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>?)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>?)
  >
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>?)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>?)
      >(
        objc.newPointerBlock(
          _ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer_fnPtrCallable,
          ptr.cast(),
        ),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>?)
  >
  fromFunction(
    Dartinstancetype Function(ffi.Pointer<ffi.Void>, UITraitCollection, UIAppearanceContainer?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>?)
      >(
        objc.newClosureBlock(
          _ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer_closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
            arg0,
            UITraitCollection.castFromPointer(arg1, retain: true, release: true),
            arg2.address == 0 ? null : UIAppearanceContainer.castFromPointer(arg2, retain: true, release: true),
          ).ref.retainAndAutorelease(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>?)>`.
extension ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer_CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>?)
        > {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, UITraitCollection arg1, UIAppearanceContainer? arg2) =>
      objc.ObjCObjectBase(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0,
                  ffi.Pointer<objc.ObjCObject> arg1,
                  ffi.Pointer<objc.ObjCObject> arg2,
                )
              >
            >()
            .asFunction<
              instancetype Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
              )
            >()(ref.pointer, arg0, arg1.ref.pointer, arg2?.ref.pointer ?? ffi.nullptr),
        retain: true,
        release: true,
      );
}

late final _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_ = objc.registerName(
  "appearanceForTraitCollection:whenContainedInInstancesOfClasses:",
);
instancetype _ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) => block.ref.target
    .cast<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >()
    .asFunction<
      instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)
    >()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray_fnPtrCallable =
    ffi.Pointer.fromFunction<
          instancetype Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray_fnPtrTrampoline)
        .cast();
instancetype _ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) =>
    (objc.getBlockClosure(block)
        as instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
      arg0,
      arg1,
      arg2,
    );
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray_closureCallable =
    ffi.Pointer.fromFunction<
          instancetype Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>(
    objc.newPointerBlock(_ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>
  fromFunction(
    Dartinstancetype Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>(
    objc.newClosureBlock(
      _ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UITraitCollection.castFromPointer(arg1, retain: true, release: true),
        objc.NSArray.castFromPointer(arg2, retain: true, release: true),
      ).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>`.
extension ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray_CallExtension
    on objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, UITraitCollection arg1, objc.NSArray arg2) => objc.ObjCObjectBase(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
              ffi.Pointer<objc.ObjCObject> arg1,
              ffi.Pointer<objc.ObjCObject> arg2,
            )
          >
        >()
        .asFunction<
          instancetype Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer),
    retain: true,
    release: true,
  );
}

/// UIBarItem
class UIBarItem extends objc.NSObject implements objc.NSCoding, UIAppearance {
  UIBarItem._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIBarItem', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIBarItem] that points to the same underlying object as [other].
  UIBarItem.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIBarItem] that wraps the given raw object pointer.
  UIBarItem.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIBarItem].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIBarItem);
  }

  /// new
  static UIBarItem new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIBarItem, _sel_new);
    return UIBarItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIBarItem allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(_class_UIBarItem, _sel_allocWithZone_, zone);
    return UIBarItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UIBarItem alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UIBarItem, _sel_alloc);
    return UIBarItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// appearance
  static UIBarItem appearance() {
    final _ret = _objc_msgSend_151sglz(_class_UIBarItem, _sel_appearance);
    return UIBarItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceWhenContainedIn:
  static UIBarItem appearanceWhenContainedIn(UIAppearanceContainer? ContainerClass) {
    objc.checkOsVersionInternal('UIBarItem.appearanceWhenContainedIn:', iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
      _class_UIBarItem,
      _sel_appearanceWhenContainedIn_,
      ContainerClass?.ref.pointer ?? ffi.nullptr,
    );
    return UIBarItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceWhenContainedInInstancesOfClasses:
  static UIBarItem appearanceWhenContainedInInstancesOfClasses(objc.NSArray containerTypes) {
    objc.checkOsVersionInternal('UIBarItem.appearanceWhenContainedInInstancesOfClasses:', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
      _class_UIBarItem,
      _sel_appearanceWhenContainedInInstancesOfClasses_,
      containerTypes.ref.pointer,
    );
    return UIBarItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:
  static UIBarItem appearanceForTraitCollection(UITraitCollection trait) {
    objc.checkOsVersionInternal('UIBarItem.appearanceForTraitCollection:', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_UIBarItem, _sel_appearanceForTraitCollection_, trait.ref.pointer);
    return UIBarItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedIn:
  static UIBarItem appearanceForTraitCollection$1(UITraitCollection trait, {UIAppearanceContainer? whenContainedIn}) {
    objc.checkOsVersionInternal('UIBarItem.appearanceForTraitCollection:whenContainedIn:', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_15qeuct(
      _class_UIBarItem,
      _sel_appearanceForTraitCollection_whenContainedIn_,
      trait.ref.pointer,
      whenContainedIn?.ref.pointer ?? ffi.nullptr,
    );
    return UIBarItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedInInstancesOfClasses:
  static UIBarItem appearanceForTraitCollection$2(
    UITraitCollection trait, {
    required objc.NSArray whenContainedInInstancesOfClasses,
  }) {
    objc.checkOsVersionInternal(
      'UIBarItem.appearanceForTraitCollection:whenContainedInInstancesOfClasses:',
      iOS: (false, (9, 0, 0)),
    );
    final _ret = _objc_msgSend_15qeuct(
      _class_UIBarItem,
      _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_,
      trait.ref.pointer,
      whenContainedInInstancesOfClasses.ref.pointer,
    );
    return UIBarItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of UIBarItem constructed with the default `new` method.
  factory UIBarItem() => new$();
}

extension UIBarItem$Methods on UIBarItem {
  /// init
  UIBarItem init() {
    objc.checkOsVersionInternal('UIBarItem.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIBarItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIBarItem? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0 ? null : UIBarItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// isEnabled
  bool get enabled {
    objc.checkOsVersionInternal('UIBarItem.isEnabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isEnabled);
  }

  /// setEnabled:
  set enabled(bool value) {
    objc.checkOsVersionInternal('UIBarItem.setEnabled:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setEnabled_, value);
  }

  /// title
  objc.NSString? get title {
    objc.checkOsVersionInternal('UIBarItem.title', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTitle:
  set title(objc.NSString? value) {
    objc.checkOsVersionInternal('UIBarItem.setTitle:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTitle_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// image
  UIImage? get image {
    objc.checkOsVersionInternal('UIBarItem.image', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_image);
    return _ret.address == 0 ? null : UIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// setImage:
  set image(UIImage? value) {
    objc.checkOsVersionInternal('UIBarItem.setImage:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setImage_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// landscapeImagePhone
  UIImage? get landscapeImagePhone {
    objc.checkOsVersionInternal('UIBarItem.landscapeImagePhone', iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_landscapeImagePhone);
    return _ret.address == 0 ? null : UIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// setLandscapeImagePhone:
  set landscapeImagePhone(UIImage? value) {
    objc.checkOsVersionInternal('UIBarItem.setLandscapeImagePhone:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setLandscapeImagePhone_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// largeContentSizeImage
  UIImage? get largeContentSizeImage {
    objc.checkOsVersionInternal('UIBarItem.largeContentSizeImage', iOS: (false, (11, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_largeContentSizeImage);
    return _ret.address == 0 ? null : UIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// setLargeContentSizeImage:
  set largeContentSizeImage(UIImage? value) {
    objc.checkOsVersionInternal('UIBarItem.setLargeContentSizeImage:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setLargeContentSizeImage_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// imageInsets
  UIEdgeInsets get imageInsets {
    objc.checkOsVersionInternal('UIBarItem.imageInsets', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(_ptr, this.ref.pointer, _sel_imageInsets)
        : _ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_imageInsets);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>(_finalizable);
  }

  /// setImageInsets:
  set imageInsets(UIEdgeInsets value) {
    objc.checkOsVersionInternal('UIBarItem.setImageInsets:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1g8fos5(this.ref.pointer, _sel_setImageInsets_, value);
  }

  /// landscapeImagePhoneInsets
  UIEdgeInsets get landscapeImagePhoneInsets {
    objc.checkOsVersionInternal('UIBarItem.landscapeImagePhoneInsets', iOS: (false, (5, 0, 0)));
    final _ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(_ptr, this.ref.pointer, _sel_landscapeImagePhoneInsets)
        : _ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_landscapeImagePhoneInsets);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>(_finalizable);
  }

  /// setLandscapeImagePhoneInsets:
  set landscapeImagePhoneInsets(UIEdgeInsets value) {
    objc.checkOsVersionInternal('UIBarItem.setLandscapeImagePhoneInsets:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_1g8fos5(this.ref.pointer, _sel_setLandscapeImagePhoneInsets_, value);
  }

  /// largeContentSizeImageInsets
  UIEdgeInsets get largeContentSizeImageInsets {
    objc.checkOsVersionInternal('UIBarItem.largeContentSizeImageInsets', iOS: (false, (11, 0, 0)));
    final _ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(_ptr, this.ref.pointer, _sel_largeContentSizeImageInsets)
        : _ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_largeContentSizeImageInsets);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>(_finalizable);
  }

  /// setLargeContentSizeImageInsets:
  set largeContentSizeImageInsets(UIEdgeInsets value) {
    objc.checkOsVersionInternal('UIBarItem.setLargeContentSizeImageInsets:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_1g8fos5(this.ref.pointer, _sel_setLargeContentSizeImageInsets_, value);
  }

  /// tag
  int get tag {
    objc.checkOsVersionInternal('UIBarItem.tag', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_tag);
  }

  /// setTag:
  set tag(int value) {
    objc.checkOsVersionInternal('UIBarItem.setTag:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_4sp4xj(this.ref.pointer, _sel_setTag_, value);
  }

  /// setTitleTextAttributes:forState:
  void setTitleTextAttributes(objc.NSDictionary? attributes, {required UIControlState forState}) {
    objc.checkOsVersionInternal('UIBarItem.setTitleTextAttributes:forState:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_dldayz(
      this.ref.pointer,
      _sel_setTitleTextAttributes_forState_,
      attributes?.ref.pointer ?? ffi.nullptr,
      forState.value,
    );
  }

  /// titleTextAttributesForState:
  objc.NSDictionary? titleTextAttributesForState(UIControlState state) {
    objc.checkOsVersionInternal('UIBarItem.titleTextAttributesForState:', iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_1g2zxsx(this.ref.pointer, _sel_titleTextAttributesForState_, state.value);
    return _ret.address == 0 ? null : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }
}

late final _class_UIBarButtonItem = objc.getClass("UIBarButtonItem");
late final _class_UIBarButtonItemGroup = objc.getClass("UIBarButtonItemGroup");
late final _sel_initWithBarButtonItems_representativeItem_ = objc.registerName(
  "initWithBarButtonItems:representativeItem:",
);
late final _sel_barButtonItems = objc.registerName("barButtonItems");
late final _sel_setBarButtonItems_ = objc.registerName("setBarButtonItems:");
late final _sel_representativeItem = objc.registerName("representativeItem");
late final _sel_setRepresentativeItem_ = objc.registerName("setRepresentativeItem:");
late final _sel_isDisplayingRepresentativeItem = objc.registerName("isDisplayingRepresentativeItem");

/// UIBarButtonItemGroup
class UIBarButtonItemGroup extends objc.NSObject implements objc.NSCoding {
  UIBarButtonItemGroup._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIBarButtonItemGroup', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UIBarButtonItemGroup] that points to the same underlying object as [other].
  UIBarButtonItemGroup.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIBarButtonItemGroup] that wraps the given raw object pointer.
  UIBarButtonItemGroup.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIBarButtonItemGroup].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIBarButtonItemGroup);
  }

  /// new
  static UIBarButtonItemGroup new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIBarButtonItemGroup, _sel_new);
    return UIBarButtonItemGroup.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIBarButtonItemGroup allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(_class_UIBarButtonItemGroup, _sel_allocWithZone_, zone);
    return UIBarButtonItemGroup.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UIBarButtonItemGroup alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UIBarButtonItemGroup, _sel_alloc);
    return UIBarButtonItemGroup.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of UIBarButtonItemGroup constructed with the default `new` method.
  factory UIBarButtonItemGroup() => new$();
}

extension UIBarButtonItemGroup$Methods on UIBarButtonItemGroup {
  /// Create a new bar button item group with the given items. When bar button item layout is done, either the group's barButtonItems or its representativeItem is displayed (if it exists).
  UIBarButtonItemGroup initWithBarButtonItems(objc.NSArray barButtonItems, {UIBarButtonItem? representativeItem}) {
    objc.checkOsVersionInternal(
      'UIBarButtonItemGroup.initWithBarButtonItems:representativeItem:',
      iOS: (false, (9, 0, 0)),
    );
    final _ret = _objc_msgSend_15qeuct(
      this.ref.retainAndReturnPointer(),
      _sel_initWithBarButtonItems_representativeItem_,
      barButtonItems.ref.pointer,
      representativeItem?.ref.pointer ?? ffi.nullptr,
    );
    return UIBarButtonItemGroup.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIBarButtonItemGroup? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0 ? null : UIBarButtonItemGroup.castFromPointer(_ret, retain: false, release: true);
  }

  /// The bar button items associated with this group. Changing these items will affect the bar displaying these items without needing to re-set the groups that are in that bar. Any UIBarButtonItems that are already in group will be removed from that group.
  objc.NSArray get barButtonItems {
    objc.checkOsVersionInternal('UIBarButtonItemGroup.barButtonItems', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_barButtonItems);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// The bar button items associated with this group. Changing these items will affect the bar displaying these items without needing to re-set the groups that are in that bar. Any UIBarButtonItems that are already in group will be removed from that group.
  set barButtonItems(objc.NSArray value) {
    objc.checkOsVersionInternal('UIBarButtonItemGroup.setBarButtonItems:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setBarButtonItems_, value.ref.pointer);
  }

  /// In order to display as many items as possible, bars that support UIBarButtonItemGroup may choose to collapse items associated with groups to the representativeItem specified by the group.
  /// A bar will only collapse groups that have a representativeItem set, but may still choose to use an alternate presentation of these items.
  /// A UIBarButtonItem may only be either the representativeItem or a member of the barButtonItems of a single UIBarButtonItemGroup and may only represent a single group.
  /// If the representativeItem has an action, then that action will be invoked, otherwise the bar will present a standard UI to allow selection of the barButtonItems in the representedItem's group.
  UIBarButtonItem? get representativeItem {
    objc.checkOsVersionInternal('UIBarButtonItemGroup.representativeItem', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_representativeItem);
    return _ret.address == 0 ? null : UIBarButtonItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// In order to display as many items as possible, bars that support UIBarButtonItemGroup may choose to collapse items associated with groups to the representativeItem specified by the group.
  /// A bar will only collapse groups that have a representativeItem set, but may still choose to use an alternate presentation of these items.
  /// A UIBarButtonItem may only be either the representativeItem or a member of the barButtonItems of a single UIBarButtonItemGroup and may only represent a single group.
  /// If the representativeItem has an action, then that action will be invoked, otherwise the bar will present a standard UI to allow selection of the barButtonItems in the representedItem's group.
  set representativeItem(UIBarButtonItem? value) {
    objc.checkOsVersionInternal('UIBarButtonItemGroup.setRepresentativeItem:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setRepresentativeItem_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Returns YES if the representativeItem of this group is currently being displayed, rather than its barButtonItems.
  bool get displayingRepresentativeItem {
    objc.checkOsVersionInternal('UIBarButtonItemGroup.isDisplayingRepresentativeItem', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isDisplayingRepresentativeItem);
  }

  /// init
  UIBarButtonItemGroup init() {
    objc.checkOsVersionInternal('UIBarButtonItemGroup.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIBarButtonItemGroup.castFromPointer(_ret, retain: false, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }
}

late final _sel_buttonGroup = objc.registerName("buttonGroup");

/// UIBarButtonItemGroup
extension UIBarButtonItemGroup$1 on UIBarButtonItem {
  /// The group that the UIBarButtonItem is currently associated with, either as a member of the barButtonItems array or as that group's representativeItem.
  UIBarButtonItemGroup? get buttonGroup {
    objc.checkOsVersionInternal('UIBarButtonItem.buttonGroup', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_buttonGroup);
    return _ret.address == 0 ? null : UIBarButtonItemGroup.castFromPointer(_ret, retain: true, release: true);
  }
}

enum UIBarButtonItemStyle {
  UIBarButtonItemStylePlain(0),
  UIBarButtonItemStyleBordered(1),
  UIBarButtonItemStyleDone(2);

  final int value;
  const UIBarButtonItemStyle(this.value);

  static UIBarButtonItemStyle fromValue(int value) => switch (value) {
    0 => UIBarButtonItemStylePlain,
    1 => UIBarButtonItemStyleBordered,
    2 => UIBarButtonItemStyleDone,
    _ => throw ArgumentError('Unknown value for UIBarButtonItemStyle: $value'),
  };
}

late final _sel_initWithImage_style_target_action_ = objc.registerName("initWithImage:style:target:action:");
final _objc_msgSend_13sbrg9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_initWithImage_landscapeImagePhone_style_target_action_ = objc.registerName(
  "initWithImage:landscapeImagePhone:style:target:action:",
);
final _objc_msgSend_1d97k9n = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_initWithTitle_style_target_action_ = objc.registerName("initWithTitle:style:target:action:");

enum UIBarButtonSystemItem {
  UIBarButtonSystemItemDone(0),
  UIBarButtonSystemItemCancel(1),
  UIBarButtonSystemItemEdit(2),
  UIBarButtonSystemItemSave(3),
  UIBarButtonSystemItemAdd(4),
  UIBarButtonSystemItemFlexibleSpace(5),
  UIBarButtonSystemItemFixedSpace(6),
  UIBarButtonSystemItemCompose(7),
  UIBarButtonSystemItemReply(8),
  UIBarButtonSystemItemAction(9),
  UIBarButtonSystemItemOrganize(10),
  UIBarButtonSystemItemBookmarks(11),
  UIBarButtonSystemItemSearch(12),
  UIBarButtonSystemItemRefresh(13),
  UIBarButtonSystemItemStop(14),
  UIBarButtonSystemItemCamera(15),
  UIBarButtonSystemItemTrash(16),
  UIBarButtonSystemItemPlay(17),
  UIBarButtonSystemItemPause(18),
  UIBarButtonSystemItemRewind(19),
  UIBarButtonSystemItemFastForward(20),
  UIBarButtonSystemItemUndo(21),
  UIBarButtonSystemItemRedo(22),
  UIBarButtonSystemItemPageCurl(23),
  UIBarButtonSystemItemClose(24);

  final int value;
  const UIBarButtonSystemItem(this.value);

  static UIBarButtonSystemItem fromValue(int value) => switch (value) {
    0 => UIBarButtonSystemItemDone,
    1 => UIBarButtonSystemItemCancel,
    2 => UIBarButtonSystemItemEdit,
    3 => UIBarButtonSystemItemSave,
    4 => UIBarButtonSystemItemAdd,
    5 => UIBarButtonSystemItemFlexibleSpace,
    6 => UIBarButtonSystemItemFixedSpace,
    7 => UIBarButtonSystemItemCompose,
    8 => UIBarButtonSystemItemReply,
    9 => UIBarButtonSystemItemAction,
    10 => UIBarButtonSystemItemOrganize,
    11 => UIBarButtonSystemItemBookmarks,
    12 => UIBarButtonSystemItemSearch,
    13 => UIBarButtonSystemItemRefresh,
    14 => UIBarButtonSystemItemStop,
    15 => UIBarButtonSystemItemCamera,
    16 => UIBarButtonSystemItemTrash,
    17 => UIBarButtonSystemItemPlay,
    18 => UIBarButtonSystemItemPause,
    19 => UIBarButtonSystemItemRewind,
    20 => UIBarButtonSystemItemFastForward,
    21 => UIBarButtonSystemItemUndo,
    22 => UIBarButtonSystemItemRedo,
    23 => UIBarButtonSystemItemPageCurl,
    24 => UIBarButtonSystemItemClose,
    _ => throw ArgumentError('Unknown value for UIBarButtonSystemItem: $value'),
  };
}

late final _sel_initWithBarButtonSystemItem_target_action_ = objc.registerName(
  "initWithBarButtonSystemItem:target:action:",
);
final _objc_msgSend_18lulgh = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_initWithCustomView_ = objc.registerName("initWithCustomView:");

/// WARNING: UIAction is a stub. To generate bindings for this class, include
/// UIAction in your config's objc-interfaces list.
///
/// UIAction
class UIAction extends UIMenuElement {
  UIAction._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIAction', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIAction] that points to the same underlying object as [other].
  UIAction.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIAction] that wraps the given raw object pointer.
  UIAction.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_initWithBarButtonSystemItem_primaryAction_ = objc.registerName(
  "initWithBarButtonSystemItem:primaryAction:",
);
final _objc_msgSend_ka2bhe = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_initWithPrimaryAction_ = objc.registerName("initWithPrimaryAction:");
late final _sel_initWithBarButtonSystemItem_menu_ = objc.registerName("initWithBarButtonSystemItem:menu:");
late final _sel_initWithTitle_menu_ = objc.registerName("initWithTitle:menu:");
late final _sel_initWithImage_menu_ = objc.registerName("initWithImage:menu:");
late final _sel_fixedSpaceItemOfWidth_ = objc.registerName("fixedSpaceItemOfWidth:");
final _objc_msgSend_oa8mke = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Double)
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, double)
    >();
late final _sel_flexibleSpaceItem = objc.registerName("flexibleSpaceItem");
late final _sel_style = objc.registerName("style");
final _objc_msgSend_121lhl0 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setStyle_ = objc.registerName("setStyle:");
final _objc_msgSend_11ist7u = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_width = objc.registerName("width");
late final _sel_setWidth_ = objc.registerName("setWidth:");
late final _sel_possibleTitles = objc.registerName("possibleTitles");
late final _sel_setPossibleTitles_ = objc.registerName("setPossibleTitles:");
late final _sel_customView = objc.registerName("customView");
late final _sel_setCustomView_ = objc.registerName("setCustomView:");
late final _sel_action = objc.registerName("action");
final _objc_msgSend_1ovaulg = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCSelector> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCSelector> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
late final _sel_setAction_ = objc.registerName("setAction:");
final _objc_msgSend_1d9e4oe = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCSelector>)
    >();
late final _sel_target = objc.registerName("target");
late final _sel_setTarget_ = objc.registerName("setTarget:");
late final _sel_primaryAction = objc.registerName("primaryAction");
late final _sel_setPrimaryAction_ = objc.registerName("setPrimaryAction:");
late final _sel_menu = objc.registerName("menu");
late final _sel_setMenu_ = objc.registerName("setMenu:");
late final _sel_changesSelectionAsPrimaryAction = objc.registerName("changesSelectionAsPrimaryAction");
late final _sel_setChangesSelectionAsPrimaryAction_ = objc.registerName("setChangesSelectionAsPrimaryAction:");
late final _sel_isSelected = objc.registerName("isSelected");
late final _sel_setSelected_ = objc.registerName("setSelected:");

enum UIBarMetrics {
  UIBarMetricsDefault(0),
  UIBarMetricsCompact(1),
  UIBarMetricsDefaultPrompt(101),
  UIBarMetricsCompactPrompt(102);

  static const UIBarMetricsLandscapePhone = UIBarMetricsCompact;
  static const UIBarMetricsLandscapePhonePrompt = UIBarMetricsCompactPrompt;

  final int value;
  const UIBarMetrics(this.value);

  static UIBarMetrics fromValue(int value) => switch (value) {
    0 => UIBarMetricsDefault,
    1 => UIBarMetricsCompact,
    101 => UIBarMetricsDefaultPrompt,
    102 => UIBarMetricsCompactPrompt,
    _ => throw ArgumentError('Unknown value for UIBarMetrics: $value'),
  };

  @override
  String toString() {
    if (this == UIBarMetricsCompact) return "UIBarMetrics.UIBarMetricsCompact, UIBarMetrics.UIBarMetricsLandscapePhone";
    if (this == UIBarMetricsCompactPrompt)
      return "UIBarMetrics.UIBarMetricsCompactPrompt, UIBarMetrics.UIBarMetricsLandscapePhonePrompt";
    return super.toString();
  }
}

late final _sel_setBackgroundImage_forState_barMetrics_ = objc.registerName("setBackgroundImage:forState:barMetrics:");
final _objc_msgSend_1oar0aj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        int,
      )
    >();
late final _sel_backgroundImageForState_barMetrics_ = objc.registerName("backgroundImageForState:barMetrics:");
final _objc_msgSend_1mmfvr1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int, int)
    >();
late final _sel_setBackgroundImage_forState_style_barMetrics_ = objc.registerName(
  "setBackgroundImage:forState:style:barMetrics:",
);
final _objc_msgSend_1lg97nc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Long,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        int,
        int,
      )
    >();
late final _sel_backgroundImageForState_style_barMetrics_ = objc.registerName(
  "backgroundImageForState:style:barMetrics:",
);
final _objc_msgSend_15kz3t6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Long,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int, int, int)
    >();
late final _class_UIColor = objc.getClass("UIColor");
late final _sel_readableTypeIdentifiersForItemProvider = objc.registerName("readableTypeIdentifiersForItemProvider");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSArray_ffiVoid_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>>()
    .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSArray_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
        >(_ObjCBlock_NSArray_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSArray_ffiVoid_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSArray_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
        >(_ObjCBlock_NSArray_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSArray_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_ObjCBlock_NSArray_ffiVoid_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> fromFunction(
    objc.NSArray Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _ObjCBlock_NSArray_ffiVoid_closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSArray_ffiVoid_CallExtension on objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> {
  objc.NSArray call(ffi.Pointer<ffi.Void> arg0) => objc.NSArray.castFromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)
          >
        >()
        .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(
      ref.pointer,
      arg0,
    ),
    retain: true,
    release: true,
  );
}

late final _sel_writableTypeIdentifiersForItemProvider = objc.registerName("writableTypeIdentifiersForItemProvider");
late final _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_ = objc.registerName(
  "itemProviderVisibilityForRepresentationWithTypeIdentifier:",
);
final _objc_msgSend_16fy0up = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)
    >();
int _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
    .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_fnPtrTrampoline, 0)
        .cast();
int _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_closureTrampoline, 0)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
abstract final class ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
    ptr,
  ) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
    objc.newPointerBlock(_ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunction(
    objc.NSItemProviderRepresentationVisibility Function(ffi.Pointer<ffi.Void>, objc.NSString) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
    objc.newClosureBlock(
      _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, objc.NSString.castFromPointer(arg1, retain: true, release: true)).value,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
extension ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_CallExtension
    on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> {
  objc.NSItemProviderRepresentationVisibility call(ffi.Pointer<ffi.Void> arg0, objc.NSString arg1) =>
      objc.NSItemProviderRepresentationVisibility.fromValue(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                ffi.Long Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0,
                  ffi.Pointer<objc.ObjCObject> arg1,
                )
              >
            >()
            .asFunction<
              int Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
            >()(ref.pointer, arg0, arg1.ref.pointer),
      );
}

void _ObjCBlock_ffiVoid_NSData_NSError_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSData_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_ffiVoid_NSData_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSData_NSError_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
  arg0,
  arg1,
);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSData_NSError_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_ffiVoid_NSData_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSData_NSError_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
    arg0,
    arg1,
  );
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)
>
_ObjCBlock_ffiVoid_NSData_NSError_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)
      >.listener(_ObjCBlock_ffiVoid_NSData_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSData_NSError_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<objc.ObjCObject> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
      arg0,
      arg1,
    );
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_NSData_NSError_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.isolateLocal(_ObjCBlock_ffiVoid_NSData_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_NSData_NSError_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(_ObjCBlock_ffiVoid_NSData_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSData_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
    objc.newPointerBlock(_ObjCBlock_ffiVoid_NSData_NSError_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> fromFunction(
    void Function(objc.NSData?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
    objc.newClosureBlock(
      _ObjCBlock_ffiVoid_NSData_NSError_closureCallable,
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
        arg0.address == 0 ? null : objc.NSData.castFromPointer(arg0, retain: true, release: true),
        arg1.address == 0 ? null : objc.NSError.castFromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> listener(
    void Function(objc.NSData?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_NSData_NSError_listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
        arg0.address == 0 ? null : objc.NSData.castFromPointer(arg0, retain: false, release: true),
        arg1.address == 0 ? null : objc.NSError.castFromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> blocking(
    void Function(objc.NSData?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_NSData_NSError_blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
        arg0.address == 0 ? null : objc.NSData.castFromPointer(arg0, retain: false, release: true),
        arg1.address == 0 ? null : objc.NSError.castFromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_NSData_NSError_blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
        arg0.address == 0 ? null : objc.NSData.castFromPointer(arg0, retain: false, release: true),
        arg1.address == 0 ? null : objc.NSError.castFromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_pfv6jd(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSData_NSError_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> {
  void call(objc.NSData? arg0, objc.NSError? arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_ = objc.registerName(
  "loadDataWithTypeIdentifier:forItemProviderCompletionHandler:",
);
final _objc_msgSend_r0bo0s = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCBlockImpl> arg2,
) => block.ref.target
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCBlockImpl> arg2,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void> _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >(_ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCBlockImpl> arg2,
) =>
    (objc.getBlockClosure(block)
        as ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void> _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >(_ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>`.
abstract final class ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.NSProgress? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSString,
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
    )
  >
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<
        objc.NSProgress? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSString,
          objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.NSProgress? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSString,
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCBlockImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.NSProgress? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSString,
          objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
        )
      >(
        objc.newPointerBlock(_ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.NSProgress? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSString,
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
    )
  >
  fromFunction(
    objc.NSProgress? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSString,
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.NSProgress? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSString,
          objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
        )
      >(
        objc.newClosureBlock(
          _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2) =>
              fn(
                arg0,
                objc.NSString.castFromPointer(arg1, retain: true, release: true),
                ObjCBlock_ffiVoid_NSData_NSError.castFromPointer(arg2, retain: true, release: true),
              )?.ref.retainAndAutorelease() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );
}

/// Call operator for `objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>`.
extension ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_CallExtension
    on
        objc.ObjCBlock<
          objc.NSProgress? Function(
            ffi.Pointer<ffi.Void>,
            objc.NSString,
            objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
          )
        > {
  objc.NSProgress? call(
    ffi.Pointer<ffi.Void> arg0,
    objc.NSString arg1,
    objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> arg2,
  ) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCBlockImpl> arg2,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer)
              .address ==
          0
      ? null
      : objc.NSProgress.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCBlockImpl> arg2,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer),
          retain: true,
          release: true,
        );
}

/// UINSItemProvider
extension UINSItemProvider on UIColor {
  /// readableTypeIdentifiersForItemProvider
  static objc.NSArray getReadableTypeIdentifiersForItemProvider() {
    objc.checkOsVersionInternal(
      'UIColor.readableTypeIdentifiersForItemProvider',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_readableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// writableTypeIdentifiersForItemProvider
  static objc.NSArray getWritableTypeIdentifiersForItemProvider() {
    objc.checkOsVersionInternal(
      'UIColor.writableTypeIdentifiersForItemProvider',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// writableTypeIdentifiersForItemProvider
  objc.NSArray get writableTypeIdentifiersForItemProvider$1 {
    objc.checkOsVersionInternal(
      'UIColor.writableTypeIdentifiersForItemProvider',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    if (!objc.respondsToSelector(this.ref.pointer, _sel_writableTypeIdentifiersForItemProvider)) {
      throw objc.UnimplementedOptionalMethodException('UIColor', 'writableTypeIdentifiersForItemProvider');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  static objc.NSItemProviderRepresentationVisibility itemProviderVisibilityForRepresentationWithTypeIdentifier(
    objc.NSString typeIdentifier,
  ) {
    objc.checkOsVersionInternal(
      'UIColor.itemProviderVisibilityForRepresentationWithTypeIdentifier:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    if (!objc.respondsToSelector(_class_UIColor, _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIColor',
        'itemProviderVisibilityForRepresentationWithTypeIdentifier:',
      );
    }
    final _ret = _objc_msgSend_16fy0up(
      _class_UIColor,
      _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
      typeIdentifier.ref.pointer,
    );
    return objc.NSItemProviderRepresentationVisibility.fromValue(_ret);
  }

  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  objc.NSItemProviderRepresentationVisibility itemProviderVisibilityForRepresentationWithTypeIdentifier$1(
    objc.NSString typeIdentifier,
  ) {
    objc.checkOsVersionInternal(
      'UIColor.itemProviderVisibilityForRepresentationWithTypeIdentifier:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    if (!objc.respondsToSelector(this.ref.pointer, _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIColor',
        'itemProviderVisibilityForRepresentationWithTypeIdentifier:',
      );
    }
    final _ret = _objc_msgSend_16fy0up(
      this.ref.pointer,
      _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
      typeIdentifier.ref.pointer,
    );
    return objc.NSItemProviderRepresentationVisibility.fromValue(_ret);
  }

  /// loadDataWithTypeIdentifier:forItemProviderCompletionHandler:
  objc.NSProgress? loadDataWithTypeIdentifier(
    objc.NSString typeIdentifier, {
    required objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> forItemProviderCompletionHandler,
  }) {
    objc.checkOsVersionInternal(
      'UIColor.loadDataWithTypeIdentifier:forItemProviderCompletionHandler:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final _ret = _objc_msgSend_r0bo0s(
      this.ref.pointer,
      _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_,
      typeIdentifier.ref.pointer,
      forItemProviderCompletionHandler.ref.pointer,
    );
    return _ret.address == 0 ? null : objc.NSProgress.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_colorNamed_ = objc.registerName("colorNamed:");
late final _sel_colorNamed_inBundle_compatibleWithTraitCollection_ = objc.registerName(
  "colorNamed:inBundle:compatibleWithTraitCollection:",
);
final _objc_msgSend_11spmsz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();

/// UIColorNamedColors
extension UIColorNamedColors on UIColor {
  /// colorNamed:
  static UIColor? colorNamed(objc.NSString name) {
    objc.checkOsVersionInternal('UIColor.colorNamed:', iOS: (false, (11, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_UIColor, _sel_colorNamed_, name.ref.pointer);
    return _ret.address == 0 ? null : UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// colorNamed:inBundle:compatibleWithTraitCollection:
  static UIColor? colorNamed$1(
    objc.NSString name, {
    NSBundle? inBundle,
    UITraitCollection? compatibleWithTraitCollection,
  }) {
    objc.checkOsVersionInternal('UIColor.colorNamed:inBundle:compatibleWithTraitCollection:', iOS: (false, (11, 0, 0)));
    final _ret = _objc_msgSend_11spmsz(
      _class_UIColor,
      _sel_colorNamed_inBundle_compatibleWithTraitCollection_,
      name.ref.pointer,
      inBundle?.ref.pointer ?? ffi.nullptr,
      compatibleWithTraitCollection?.ref.pointer ?? ffi.nullptr,
    );
    return _ret.address == 0 ? null : UIColor.castFromPointer(_ret, retain: true, release: true);
  }
}

ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIColor_UITraitCollection_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
    .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIColor_UITraitCollection_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_UIColor_UITraitCollection_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIColor_UITraitCollection_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIColor_UITraitCollection_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_UIColor_UITraitCollection_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<UIColor Function(UITraitCollection)>`.
abstract final class ObjCBlock_UIColor_UITraitCollection {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIColor Function(UITraitCollection)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UIColor Function(UITraitCollection)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIColor Function(UITraitCollection)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject> arg0)>> ptr,
  ) => objc.ObjCBlock<UIColor Function(UITraitCollection)>(
    objc.newPointerBlock(_ObjCBlock_UIColor_UITraitCollection_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIColor Function(UITraitCollection)> fromFunction(
    UIColor Function(UITraitCollection) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UIColor Function(UITraitCollection)>(
    objc.newClosureBlock(
      _ObjCBlock_UIColor_UITraitCollection_closureCallable,
      (ffi.Pointer<objc.ObjCObject> arg0) =>
          fn(UITraitCollection.castFromPointer(arg0, retain: true, release: true)).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<UIColor Function(UITraitCollection)>`.
extension ObjCBlock_UIColor_UITraitCollection_CallExtension on objc.ObjCBlock<UIColor Function(UITraitCollection)> {
  UIColor call(UITraitCollection arg0) => UIColor.castFromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<objc.ObjCObject> arg0,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
        >()(ref.pointer, arg0.ref.pointer),
    retain: true,
    release: true,
  );
}

late final _sel_colorWithDynamicProvider_ = objc.registerName("colorWithDynamicProvider:");
final _objc_msgSend_nnxkei = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_initWithDynamicProvider_ = objc.registerName("initWithDynamicProvider:");
late final _sel_resolvedColorWithTraitCollection_ = objc.registerName("resolvedColorWithTraitCollection:");

/// DynamicColors
extension DynamicColors on UIColor {
  /// colorWithDynamicProvider:
  static UIColor colorWithDynamicProvider(objc.ObjCBlock<UIColor Function(UITraitCollection)> dynamicProvider) {
    objc.checkOsVersionInternal('UIColor.colorWithDynamicProvider:', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_nnxkei(_class_UIColor, _sel_colorWithDynamicProvider_, dynamicProvider.ref.pointer);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithDynamicProvider:
  UIColor initWithDynamicProvider(objc.ObjCBlock<UIColor Function(UITraitCollection)> dynamicProvider) {
    objc.checkOsVersionInternal('UIColor.initWithDynamicProvider:', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_nnxkei(
      this.ref.retainAndReturnPointer(),
      _sel_initWithDynamicProvider_,
      dynamicProvider.ref.pointer,
    );
    return UIColor.castFromPointer(_ret, retain: false, release: true);
  }

  /// resolvedColorWithTraitCollection:
  UIColor resolvedColorWithTraitCollection(UITraitCollection traitCollection) {
    objc.checkOsVersionInternal('UIColor.resolvedColorWithTraitCollection:', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
      this.ref.pointer,
      _sel_resolvedColorWithTraitCollection_,
      traitCollection.ref.pointer,
    );
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_systemRedColor = objc.registerName("systemRedColor");
late final _sel_systemGreenColor = objc.registerName("systemGreenColor");
late final _sel_systemBlueColor = objc.registerName("systemBlueColor");
late final _sel_systemOrangeColor = objc.registerName("systemOrangeColor");
late final _sel_systemYellowColor = objc.registerName("systemYellowColor");
late final _sel_systemPinkColor = objc.registerName("systemPinkColor");
late final _sel_systemPurpleColor = objc.registerName("systemPurpleColor");
late final _sel_systemTealColor = objc.registerName("systemTealColor");
late final _sel_systemIndigoColor = objc.registerName("systemIndigoColor");
late final _sel_systemBrownColor = objc.registerName("systemBrownColor");
late final _sel_systemMintColor = objc.registerName("systemMintColor");
late final _sel_systemCyanColor = objc.registerName("systemCyanColor");
late final _sel_systemGrayColor = objc.registerName("systemGrayColor");
late final _sel_systemGray2Color = objc.registerName("systemGray2Color");
late final _sel_systemGray3Color = objc.registerName("systemGray3Color");
late final _sel_systemGray4Color = objc.registerName("systemGray4Color");
late final _sel_systemGray5Color = objc.registerName("systemGray5Color");
late final _sel_systemGray6Color = objc.registerName("systemGray6Color");
late final _sel_tintColor = objc.registerName("tintColor");
late final _sel_labelColor = objc.registerName("labelColor");
late final _sel_secondaryLabelColor = objc.registerName("secondaryLabelColor");
late final _sel_tertiaryLabelColor = objc.registerName("tertiaryLabelColor");
late final _sel_quaternaryLabelColor = objc.registerName("quaternaryLabelColor");
late final _sel_linkColor = objc.registerName("linkColor");
late final _sel_placeholderTextColor = objc.registerName("placeholderTextColor");
late final _sel_separatorColor = objc.registerName("separatorColor");
late final _sel_opaqueSeparatorColor = objc.registerName("opaqueSeparatorColor");
late final _sel_systemBackgroundColor = objc.registerName("systemBackgroundColor");
late final _sel_secondarySystemBackgroundColor = objc.registerName("secondarySystemBackgroundColor");
late final _sel_tertiarySystemBackgroundColor = objc.registerName("tertiarySystemBackgroundColor");
late final _sel_systemGroupedBackgroundColor = objc.registerName("systemGroupedBackgroundColor");
late final _sel_secondarySystemGroupedBackgroundColor = objc.registerName("secondarySystemGroupedBackgroundColor");
late final _sel_tertiarySystemGroupedBackgroundColor = objc.registerName("tertiarySystemGroupedBackgroundColor");
late final _sel_systemFillColor = objc.registerName("systemFillColor");
late final _sel_secondarySystemFillColor = objc.registerName("secondarySystemFillColor");
late final _sel_tertiarySystemFillColor = objc.registerName("tertiarySystemFillColor");
late final _sel_quaternarySystemFillColor = objc.registerName("quaternarySystemFillColor");
late final _sel_lightTextColor = objc.registerName("lightTextColor");
late final _sel_darkTextColor = objc.registerName("darkTextColor");
late final _sel_groupTableViewBackgroundColor = objc.registerName("groupTableViewBackgroundColor");
late final _sel_viewFlipsideBackgroundColor = objc.registerName("viewFlipsideBackgroundColor");
late final _sel_scrollViewTexturedBackgroundColor = objc.registerName("scrollViewTexturedBackgroundColor");
late final _sel_underPageBackgroundColor = objc.registerName("underPageBackgroundColor");

/// UIColorSystemColors
extension UIColorSystemColors on UIColor {
  /// systemRedColor
  static UIColor getSystemRedColor() {
    objc.checkOsVersionInternal('UIColor.systemRedColor', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemRedColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemGreenColor
  static UIColor getSystemGreenColor() {
    objc.checkOsVersionInternal('UIColor.systemGreenColor', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemGreenColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemBlueColor
  static UIColor getSystemBlueColor() {
    objc.checkOsVersionInternal('UIColor.systemBlueColor', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemBlueColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemOrangeColor
  static UIColor getSystemOrangeColor() {
    objc.checkOsVersionInternal('UIColor.systemOrangeColor', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemOrangeColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemYellowColor
  static UIColor getSystemYellowColor() {
    objc.checkOsVersionInternal('UIColor.systemYellowColor', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemYellowColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemPinkColor
  static UIColor getSystemPinkColor() {
    objc.checkOsVersionInternal('UIColor.systemPinkColor', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemPinkColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemPurpleColor
  static UIColor getSystemPurpleColor() {
    objc.checkOsVersionInternal('UIColor.systemPurpleColor', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemPurpleColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemTealColor
  static UIColor getSystemTealColor() {
    objc.checkOsVersionInternal('UIColor.systemTealColor', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemTealColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemIndigoColor
  static UIColor getSystemIndigoColor() {
    objc.checkOsVersionInternal('UIColor.systemIndigoColor', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemIndigoColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemBrownColor
  static UIColor getSystemBrownColor() {
    objc.checkOsVersionInternal('UIColor.systemBrownColor', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemBrownColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemMintColor
  static UIColor getSystemMintColor() {
    objc.checkOsVersionInternal('UIColor.systemMintColor', iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemMintColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemCyanColor
  static UIColor getSystemCyanColor() {
    objc.checkOsVersionInternal('UIColor.systemCyanColor', iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemCyanColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemGrayColor
  static UIColor getSystemGrayColor() {
    objc.checkOsVersionInternal('UIColor.systemGrayColor', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemGrayColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemGray2Color
  static UIColor getSystemGray2Color() {
    objc.checkOsVersionInternal('UIColor.systemGray2Color', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemGray2Color);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemGray3Color
  static UIColor getSystemGray3Color() {
    objc.checkOsVersionInternal('UIColor.systemGray3Color', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemGray3Color);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemGray4Color
  static UIColor getSystemGray4Color() {
    objc.checkOsVersionInternal('UIColor.systemGray4Color', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemGray4Color);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemGray5Color
  static UIColor getSystemGray5Color() {
    objc.checkOsVersionInternal('UIColor.systemGray5Color', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemGray5Color);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemGray6Color
  static UIColor getSystemGray6Color() {
    objc.checkOsVersionInternal('UIColor.systemGray6Color', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemGray6Color);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// tintColor
  static UIColor getTintColor() {
    objc.checkOsVersionInternal('UIColor.tintColor', iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_tintColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// labelColor
  static UIColor getLabelColor() {
    objc.checkOsVersionInternal('UIColor.labelColor', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_labelColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// secondaryLabelColor
  static UIColor getSecondaryLabelColor() {
    objc.checkOsVersionInternal('UIColor.secondaryLabelColor', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_secondaryLabelColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// tertiaryLabelColor
  static UIColor getTertiaryLabelColor() {
    objc.checkOsVersionInternal('UIColor.tertiaryLabelColor', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_tertiaryLabelColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// quaternaryLabelColor
  static UIColor getQuaternaryLabelColor() {
    objc.checkOsVersionInternal('UIColor.quaternaryLabelColor', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_quaternaryLabelColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// linkColor
  static UIColor getLinkColor() {
    objc.checkOsVersionInternal('UIColor.linkColor', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_linkColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// placeholderTextColor
  static UIColor getPlaceholderTextColor() {
    objc.checkOsVersionInternal('UIColor.placeholderTextColor', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_placeholderTextColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// separatorColor
  static UIColor getSeparatorColor() {
    objc.checkOsVersionInternal('UIColor.separatorColor', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_separatorColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// opaqueSeparatorColor
  static UIColor getOpaqueSeparatorColor() {
    objc.checkOsVersionInternal('UIColor.opaqueSeparatorColor', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_opaqueSeparatorColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemBackgroundColor
  static UIColor getSystemBackgroundColor() {
    objc.checkOsVersionInternal('UIColor.systemBackgroundColor', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemBackgroundColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// secondarySystemBackgroundColor
  static UIColor getSecondarySystemBackgroundColor() {
    objc.checkOsVersionInternal('UIColor.secondarySystemBackgroundColor', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_secondarySystemBackgroundColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// tertiarySystemBackgroundColor
  static UIColor getTertiarySystemBackgroundColor() {
    objc.checkOsVersionInternal('UIColor.tertiarySystemBackgroundColor', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_tertiarySystemBackgroundColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemGroupedBackgroundColor
  static UIColor getSystemGroupedBackgroundColor() {
    objc.checkOsVersionInternal('UIColor.systemGroupedBackgroundColor', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemGroupedBackgroundColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// secondarySystemGroupedBackgroundColor
  static UIColor getSecondarySystemGroupedBackgroundColor() {
    objc.checkOsVersionInternal('UIColor.secondarySystemGroupedBackgroundColor', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_secondarySystemGroupedBackgroundColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// tertiarySystemGroupedBackgroundColor
  static UIColor getTertiarySystemGroupedBackgroundColor() {
    objc.checkOsVersionInternal('UIColor.tertiarySystemGroupedBackgroundColor', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_tertiarySystemGroupedBackgroundColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemFillColor
  static UIColor getSystemFillColor() {
    objc.checkOsVersionInternal('UIColor.systemFillColor', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemFillColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// secondarySystemFillColor
  static UIColor getSecondarySystemFillColor() {
    objc.checkOsVersionInternal('UIColor.secondarySystemFillColor', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_secondarySystemFillColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// tertiarySystemFillColor
  static UIColor getTertiarySystemFillColor() {
    objc.checkOsVersionInternal('UIColor.tertiarySystemFillColor', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_tertiarySystemFillColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// quaternarySystemFillColor
  static UIColor getQuaternarySystemFillColor() {
    objc.checkOsVersionInternal('UIColor.quaternarySystemFillColor', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_quaternarySystemFillColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// lightTextColor
  static UIColor getLightTextColor() {
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_lightTextColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// darkTextColor
  static UIColor getDarkTextColor() {
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_darkTextColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// groupTableViewBackgroundColor
  static UIColor getGroupTableViewBackgroundColor() {
    objc.checkOsVersionInternal('UIColor.groupTableViewBackgroundColor', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_groupTableViewBackgroundColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// viewFlipsideBackgroundColor
  static UIColor getViewFlipsideBackgroundColor() {
    objc.checkOsVersionInternal('UIColor.viewFlipsideBackgroundColor', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_viewFlipsideBackgroundColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// scrollViewTexturedBackgroundColor
  static UIColor getScrollViewTexturedBackgroundColor() {
    objc.checkOsVersionInternal('UIColor.scrollViewTexturedBackgroundColor', iOS: (false, (3, 2, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_scrollViewTexturedBackgroundColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// underPageBackgroundColor
  static UIColor getUnderPageBackgroundColor() {
    objc.checkOsVersionInternal('UIColor.underPageBackgroundColor', iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_underPageBackgroundColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_colorWithWhite_alpha_ = objc.registerName("colorWithWhite:alpha:");
final _objc_msgSend_1n2vn5t = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Double,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        double,
      )
    >();
late final _sel_colorWithHue_saturation_brightness_alpha_ = objc.registerName(
  "colorWithHue:saturation:brightness:alpha:",
);
final _objc_msgSend_q2wq4h = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Double,
          ffi.Double,
          ffi.Double,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        double,
        double,
        double,
      )
    >();
late final _sel_colorWithRed_green_blue_alpha_ = objc.registerName("colorWithRed:green:blue:alpha:");
late final _sel_colorWithDisplayP3Red_green_blue_alpha_ = objc.registerName("colorWithDisplayP3Red:green:blue:alpha:");
late final _sel_colorWithCGColor_ = objc.registerName("colorWithCGColor:");
final _objc_msgSend_1rsocyz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<CGColor>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<CGColor>,
      )
    >();
late final _sel_colorWithPatternImage_ = objc.registerName("colorWithPatternImage:");

/// WARNING: CIColor is a stub. To generate bindings for this class, include
/// CIColor in your config's objc-interfaces list.
///
/// CIColor
class CIColor extends objc.NSObject implements objc.NSSecureCoding, objc.NSCopying {
  CIColor._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CIColor', macOS: (false, (10, 4, 0)));
  }

  /// Constructs a [CIColor] that points to the same underlying object as [other].
  CIColor.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CIColor] that wraps the given raw object pointer.
  CIColor.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_colorWithCIColor_ = objc.registerName("colorWithCIColor:");
late final _sel_initWithWhite_alpha_ = objc.registerName("initWithWhite:alpha:");
late final _sel_initWithHue_saturation_brightness_alpha_ = objc.registerName(
  "initWithHue:saturation:brightness:alpha:",
);
late final _sel_initWithRed_green_blue_alpha_ = objc.registerName("initWithRed:green:blue:alpha:");
late final _sel_initWithDisplayP3Red_green_blue_alpha_ = objc.registerName("initWithDisplayP3Red:green:blue:alpha:");
late final _sel_initWithCGColor_ = objc.registerName("initWithCGColor:");
late final _sel_initWithPatternImage_ = objc.registerName("initWithPatternImage:");
late final _sel_initWithCIColor_ = objc.registerName("initWithCIColor:");
late final _sel_blackColor = objc.registerName("blackColor");
late final _sel_darkGrayColor = objc.registerName("darkGrayColor");
late final _sel_lightGrayColor = objc.registerName("lightGrayColor");
late final _sel_whiteColor = objc.registerName("whiteColor");
late final _sel_grayColor = objc.registerName("grayColor");
late final _sel_redColor = objc.registerName("redColor");
late final _sel_greenColor = objc.registerName("greenColor");
late final _sel_blueColor = objc.registerName("blueColor");
late final _sel_cyanColor = objc.registerName("cyanColor");
late final _sel_yellowColor = objc.registerName("yellowColor");
late final _sel_magentaColor = objc.registerName("magentaColor");
late final _sel_orangeColor = objc.registerName("orangeColor");
late final _sel_purpleColor = objc.registerName("purpleColor");
late final _sel_brownColor = objc.registerName("brownColor");
late final _sel_clearColor = objc.registerName("clearColor");
late final _sel_set = objc.registerName("set");
late final _sel_setFill = objc.registerName("setFill");
late final _sel_setStroke = objc.registerName("setStroke");
late final _sel_getWhite_alpha_ = objc.registerName("getWhite:alpha:");
final _objc_msgSend_kcpn4z = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Double>,
        ffi.Pointer<ffi.Double>,
      )
    >();
late final _sel_getHue_saturation_brightness_alpha_ = objc.registerName("getHue:saturation:brightness:alpha:");
final _objc_msgSend_xmvde7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Double>,
        ffi.Pointer<ffi.Double>,
        ffi.Pointer<ffi.Double>,
        ffi.Pointer<ffi.Double>,
      )
    >();
late final _sel_getRed_green_blue_alpha_ = objc.registerName("getRed:green:blue:alpha:");
late final _sel_colorWithAlphaComponent_ = objc.registerName("colorWithAlphaComponent:");
late final _sel_CGColor = objc.registerName("CGColor");
final _objc_msgSend_2u9jmz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Pointer<CGColor> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>
    >()
    .asFunction<ffi.Pointer<CGColor> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_CIColor = objc.registerName("CIColor");
late final _sel_objectWithItemProviderData_typeIdentifier_error_ = objc.registerName(
  "objectWithItemProviderData:typeIdentifier:error:",
);
final _objc_msgSend_1pnyuds = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      )
    >();
instancetype _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3,
) => block.ref.target
    .cast<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3,
        )
      >
    >()
    .asFunction<
      instancetype Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      )
    >()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
          instancetype Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
          )
        >(_ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_fnPtrTrampoline)
        .cast();
instancetype _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3,
) =>
    (objc.getBlockClosure(block)
        as instancetype Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        ))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_closureCallable =
    ffi.Pointer.fromFunction<
          instancetype Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
          )
        >(_ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject>? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSData,
      objc.NSString,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
    )
  >
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject>? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSData,
          objc.NSString,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject>? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSData,
      objc.NSString,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject>? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSData,
          objc.NSString,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >(
        objc.newPointerBlock(_ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject>? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSData,
      objc.NSString,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
    )
  >
  fromFunction(
    Dartinstancetype? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSData,
      objc.NSString,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject>? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSData,
          objc.NSString,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >(
        objc.newClosureBlock(
          _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3,
          ) =>
              fn(
                arg0,
                objc.NSData.castFromPointer(arg1, retain: true, release: true),
                objc.NSString.castFromPointer(arg2, retain: true, release: true),
                arg3,
              )?.ref.retainAndAutorelease() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>`.
extension ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject>? Function(
            ffi.Pointer<ffi.Void>,
            objc.NSData,
            objc.NSString,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
          )
        > {
  Dartinstancetype? call(
    ffi.Pointer<ffi.Void> arg0,
    objc.NSData arg1,
    objc.NSString arg2,
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3,
  ) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2,
                    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3)
              .address ==
          0
      ? null
      : objc.ObjCObjectBase(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2,
                    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3),
          retain: true,
          release: true,
        );
}

/// UIColor
class UIColor extends objc.NSObject implements objc.NSSecureCoding, objc.NSCopying {
  UIColor._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIColor', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIColor] that points to the same underlying object as [other].
  UIColor.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIColor] that wraps the given raw object pointer.
  UIColor.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIColor].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIColor);
  }

  /// colorWithWhite:alpha:
  static UIColor colorWithWhite(double white, {required double alpha}) {
    objc.checkOsVersionInternal('UIColor.colorWithWhite:alpha:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1n2vn5t(_class_UIColor, _sel_colorWithWhite_alpha_, white, alpha);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// colorWithHue:saturation:brightness:alpha:
  static UIColor colorWithHue(
    double hue, {
    required double saturation,
    required double brightness,
    required double alpha,
  }) {
    objc.checkOsVersionInternal('UIColor.colorWithHue:saturation:brightness:alpha:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_q2wq4h(
      _class_UIColor,
      _sel_colorWithHue_saturation_brightness_alpha_,
      hue,
      saturation,
      brightness,
      alpha,
    );
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// colorWithRed:green:blue:alpha:
  static UIColor colorWithRed(double red, {required double green, required double blue, required double alpha}) {
    objc.checkOsVersionInternal('UIColor.colorWithRed:green:blue:alpha:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_q2wq4h(_class_UIColor, _sel_colorWithRed_green_blue_alpha_, red, green, blue, alpha);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// colorWithDisplayP3Red:green:blue:alpha:
  static UIColor colorWithDisplayP3Red(
    double displayP3Red, {
    required double green,
    required double blue,
    required double alpha,
  }) {
    objc.checkOsVersionInternal('UIColor.colorWithDisplayP3Red:green:blue:alpha:', iOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_q2wq4h(
      _class_UIColor,
      _sel_colorWithDisplayP3Red_green_blue_alpha_,
      displayP3Red,
      green,
      blue,
      alpha,
    );
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// colorWithCGColor:
  static UIColor colorWithCGColor(ffi.Pointer<CGColor> cgColor) {
    objc.checkOsVersionInternal('UIColor.colorWithCGColor:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1rsocyz(_class_UIColor, _sel_colorWithCGColor_, cgColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// colorWithPatternImage:
  static UIColor colorWithPatternImage(UIImage image) {
    objc.checkOsVersionInternal('UIColor.colorWithPatternImage:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_UIColor, _sel_colorWithPatternImage_, image.ref.pointer);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// colorWithCIColor:
  static UIColor colorWithCIColor(CIColor ciColor) {
    objc.checkOsVersionInternal('UIColor.colorWithCIColor:', iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_UIColor, _sel_colorWithCIColor_, ciColor.ref.pointer);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// blackColor
  static UIColor getBlackColor() {
    objc.checkOsVersionInternal('UIColor.blackColor', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_blackColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// darkGrayColor
  static UIColor getDarkGrayColor() {
    objc.checkOsVersionInternal('UIColor.darkGrayColor', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_darkGrayColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// lightGrayColor
  static UIColor getLightGrayColor() {
    objc.checkOsVersionInternal('UIColor.lightGrayColor', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_lightGrayColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// whiteColor
  static UIColor getWhiteColor() {
    objc.checkOsVersionInternal('UIColor.whiteColor', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_whiteColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// grayColor
  static UIColor getGrayColor() {
    objc.checkOsVersionInternal('UIColor.grayColor', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_grayColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// redColor
  static UIColor getRedColor() {
    objc.checkOsVersionInternal('UIColor.redColor', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_redColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// greenColor
  static UIColor getGreenColor() {
    objc.checkOsVersionInternal('UIColor.greenColor', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_greenColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// blueColor
  static UIColor getBlueColor() {
    objc.checkOsVersionInternal('UIColor.blueColor', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_blueColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// cyanColor
  static UIColor getCyanColor() {
    objc.checkOsVersionInternal('UIColor.cyanColor', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_cyanColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// yellowColor
  static UIColor getYellowColor() {
    objc.checkOsVersionInternal('UIColor.yellowColor', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_yellowColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// magentaColor
  static UIColor getMagentaColor() {
    objc.checkOsVersionInternal('UIColor.magentaColor', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_magentaColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// orangeColor
  static UIColor getOrangeColor() {
    objc.checkOsVersionInternal('UIColor.orangeColor', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_orangeColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// purpleColor
  static UIColor getPurpleColor() {
    objc.checkOsVersionInternal('UIColor.purpleColor', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_purpleColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// brownColor
  static UIColor getBrownColor() {
    objc.checkOsVersionInternal('UIColor.brownColor', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_brownColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// clearColor
  static UIColor getClearColor() {
    objc.checkOsVersionInternal('UIColor.clearColor', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_clearColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static UIColor new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_new);
    return UIColor.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIColor allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(_class_UIColor, _sel_allocWithZone_, zone);
    return UIColor.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UIColor alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UIColor, _sel_alloc);
    return UIColor.castFromPointer(_ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UIColor, _sel_supportsSecureCoding);
  }

  /// objectWithItemProviderData:typeIdentifier:error:
  static UIColor? objectWithItemProviderData(
    objc.NSData data, {
    required objc.NSString typeIdentifier,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'UIColor.objectWithItemProviderData:typeIdentifier:error:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final _ret = _objc_msgSend_1pnyuds(
      _class_UIColor,
      _sel_objectWithItemProviderData_typeIdentifier_error_,
      data.ref.pointer,
      typeIdentifier.ref.pointer,
      error,
    );
    return _ret.address == 0 ? null : UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of UIColor constructed with the default `new` method.
  factory UIColor() => new$();
}

extension UIColor$Methods on UIColor {
  /// initWithWhite:alpha:
  UIColor initWithWhite(double white, {required double alpha}) {
    objc.checkOsVersionInternal('UIColor.initWithWhite:alpha:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1n2vn5t(this.ref.retainAndReturnPointer(), _sel_initWithWhite_alpha_, white, alpha);
    return UIColor.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithHue:saturation:brightness:alpha:
  UIColor initWithHue(double hue, {required double saturation, required double brightness, required double alpha}) {
    objc.checkOsVersionInternal('UIColor.initWithHue:saturation:brightness:alpha:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_q2wq4h(
      this.ref.retainAndReturnPointer(),
      _sel_initWithHue_saturation_brightness_alpha_,
      hue,
      saturation,
      brightness,
      alpha,
    );
    return UIColor.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithRed:green:blue:alpha:
  UIColor initWithRed(double red, {required double green, required double blue, required double alpha}) {
    objc.checkOsVersionInternal('UIColor.initWithRed:green:blue:alpha:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_q2wq4h(
      this.ref.retainAndReturnPointer(),
      _sel_initWithRed_green_blue_alpha_,
      red,
      green,
      blue,
      alpha,
    );
    return UIColor.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithDisplayP3Red:green:blue:alpha:
  UIColor initWithDisplayP3Red(
    double displayP3Red, {
    required double green,
    required double blue,
    required double alpha,
  }) {
    objc.checkOsVersionInternal('UIColor.initWithDisplayP3Red:green:blue:alpha:', iOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_q2wq4h(
      this.ref.retainAndReturnPointer(),
      _sel_initWithDisplayP3Red_green_blue_alpha_,
      displayP3Red,
      green,
      blue,
      alpha,
    );
    return UIColor.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCGColor:
  UIColor initWithCGColor(ffi.Pointer<CGColor> cgColor) {
    objc.checkOsVersionInternal('UIColor.initWithCGColor:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1rsocyz(this.ref.retainAndReturnPointer(), _sel_initWithCGColor_, cgColor);
    return UIColor.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithPatternImage:
  UIColor initWithPatternImage(UIImage image) {
    objc.checkOsVersionInternal('UIColor.initWithPatternImage:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
      this.ref.retainAndReturnPointer(),
      _sel_initWithPatternImage_,
      image.ref.pointer,
    );
    return UIColor.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCIColor:
  UIColor initWithCIColor(CIColor ciColor) {
    objc.checkOsVersionInternal('UIColor.initWithCIColor:', iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCIColor_, ciColor.ref.pointer);
    return UIColor.castFromPointer(_ret, retain: false, release: true);
  }

  /// set
  void set$() {
    objc.checkOsVersionInternal('UIColor.set', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_set);
  }

  /// setFill
  void setFill() {
    objc.checkOsVersionInternal('UIColor.setFill', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setFill);
  }

  /// setStroke
  void setStroke() {
    objc.checkOsVersionInternal('UIColor.setStroke', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setStroke);
  }

  /// getWhite:alpha:
  bool getWhite(ffi.Pointer<ffi.Double> white, {required ffi.Pointer<ffi.Double> alpha}) {
    objc.checkOsVersionInternal('UIColor.getWhite:alpha:', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_kcpn4z(this.ref.pointer, _sel_getWhite_alpha_, white, alpha);
  }

  /// getHue:saturation:brightness:alpha:
  bool getHue(
    ffi.Pointer<ffi.Double> hue, {
    required ffi.Pointer<ffi.Double> saturation,
    required ffi.Pointer<ffi.Double> brightness,
    required ffi.Pointer<ffi.Double> alpha,
  }) {
    objc.checkOsVersionInternal('UIColor.getHue:saturation:brightness:alpha:', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_xmvde7(
      this.ref.pointer,
      _sel_getHue_saturation_brightness_alpha_,
      hue,
      saturation,
      brightness,
      alpha,
    );
  }

  /// getRed:green:blue:alpha:
  bool getRed(
    ffi.Pointer<ffi.Double> red, {
    required ffi.Pointer<ffi.Double> green,
    required ffi.Pointer<ffi.Double> blue,
    required ffi.Pointer<ffi.Double> alpha,
  }) {
    objc.checkOsVersionInternal('UIColor.getRed:green:blue:alpha:', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_xmvde7(this.ref.pointer, _sel_getRed_green_blue_alpha_, red, green, blue, alpha);
  }

  /// colorWithAlphaComponent:
  UIColor colorWithAlphaComponent(double alpha) {
    objc.checkOsVersionInternal('UIColor.colorWithAlphaComponent:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_oa8mke(this.ref.pointer, _sel_colorWithAlphaComponent_, alpha);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// CGColor
  ffi.Pointer<CGColor> get CGColor$1 {
    objc.checkOsVersionInternal('UIColor.CGColor', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_2u9jmz(this.ref.pointer, _sel_CGColor);
  }

  /// CIColor
  CIColor get CIColor$1 {
    objc.checkOsVersionInternal('UIColor.CIColor', iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_CIColor);
    return CIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  UIColor init() {
    objc.checkOsVersionInternal('UIColor.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIColor.castFromPointer(_ret, retain: false, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// initWithCoder:
  UIColor? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0 ? null : UIColor.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _sel_setTintColor_ = objc.registerName("setTintColor:");
late final _sel_setBackgroundVerticalPositionAdjustment_forBarMetrics_ = objc.registerName(
  "setBackgroundVerticalPositionAdjustment:forBarMetrics:",
);
final _objc_msgSend_159fszq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Double, ffi.Long)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, double, int)>();
late final _sel_backgroundVerticalPositionAdjustmentForBarMetrics_ = objc.registerName(
  "backgroundVerticalPositionAdjustmentForBarMetrics:",
);
final _objc_msgSend_1ih4ekw = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Double Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<double Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
final _objc_msgSend_1ih4ekwFpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<ffi.Double Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<double Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();

final class UIOffset extends ffi.Struct {
  @ffi.Double()
  external double horizontal;

  @ffi.Double()
  external double vertical;
}

late final _sel_setTitlePositionAdjustment_forBarMetrics_ = objc.registerName(
  "setTitlePositionAdjustment:forBarMetrics:",
);
final _objc_msgSend_dhwtpp = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, UIOffset, ffi.Long)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, UIOffset, int)>();
late final _sel_titlePositionAdjustmentForBarMetrics_ = objc.registerName("titlePositionAdjustmentForBarMetrics:");
final _objc_msgSend_qx0nmf = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<UIOffset Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<UIOffset Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
final _objc_msgSend_qx0nmfStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<UIOffset>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<UIOffset>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)
    >();
late final _sel_setBackButtonBackgroundImage_forState_barMetrics_ = objc.registerName(
  "setBackButtonBackgroundImage:forState:barMetrics:",
);
late final _sel_backButtonBackgroundImageForState_barMetrics_ = objc.registerName(
  "backButtonBackgroundImageForState:barMetrics:",
);
late final _sel_setBackButtonTitlePositionAdjustment_forBarMetrics_ = objc.registerName(
  "setBackButtonTitlePositionAdjustment:forBarMetrics:",
);
late final _sel_backButtonTitlePositionAdjustmentForBarMetrics_ = objc.registerName(
  "backButtonTitlePositionAdjustmentForBarMetrics:",
);
late final _sel_setBackButtonBackgroundVerticalPositionAdjustment_forBarMetrics_ = objc.registerName(
  "setBackButtonBackgroundVerticalPositionAdjustment:forBarMetrics:",
);
late final _sel_backButtonBackgroundVerticalPositionAdjustmentForBarMetrics_ = objc.registerName(
  "backButtonBackgroundVerticalPositionAdjustmentForBarMetrics:",
);

/// UIBarButtonItem
class UIBarButtonItem extends UIBarItem implements objc.NSCoding {
  UIBarButtonItem._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [UIBarButtonItem] that points to the same underlying object as [other].
  UIBarButtonItem.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIBarButtonItem] that wraps the given raw object pointer.
  UIBarButtonItem.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIBarButtonItem].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIBarButtonItem);
  }

  /// Construct a new fixed space item with the given width.
  static UIBarButtonItem fixedSpaceItemOfWidth(double width) {
    objc.checkOsVersionInternal('UIBarButtonItem.fixedSpaceItemOfWidth:', iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_oa8mke(_class_UIBarButtonItem, _sel_fixedSpaceItemOfWidth_, width);
    return UIBarButtonItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// Construct a new flexible space item.
  static UIBarButtonItem flexibleSpaceItem() {
    objc.checkOsVersionInternal('UIBarButtonItem.flexibleSpaceItem', iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIBarButtonItem, _sel_flexibleSpaceItem);
    return UIBarButtonItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static UIBarButtonItem new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIBarButtonItem, _sel_new);
    return UIBarButtonItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIBarButtonItem allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(_class_UIBarButtonItem, _sel_allocWithZone_, zone);
    return UIBarButtonItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UIBarButtonItem alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UIBarButtonItem, _sel_alloc);
    return UIBarButtonItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// appearance
  static UIBarButtonItem appearance() {
    final _ret = _objc_msgSend_151sglz(_class_UIBarButtonItem, _sel_appearance);
    return UIBarButtonItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceWhenContainedIn:
  static UIBarButtonItem appearanceWhenContainedIn(UIAppearanceContainer? ContainerClass) {
    objc.checkOsVersionInternal('UIBarButtonItem.appearanceWhenContainedIn:', iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
      _class_UIBarButtonItem,
      _sel_appearanceWhenContainedIn_,
      ContainerClass?.ref.pointer ?? ffi.nullptr,
    );
    return UIBarButtonItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceWhenContainedInInstancesOfClasses:
  static UIBarButtonItem appearanceWhenContainedInInstancesOfClasses(objc.NSArray containerTypes) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.appearanceWhenContainedInInstancesOfClasses:',
      iOS: (false, (9, 0, 0)),
    );
    final _ret = _objc_msgSend_1sotr3r(
      _class_UIBarButtonItem,
      _sel_appearanceWhenContainedInInstancesOfClasses_,
      containerTypes.ref.pointer,
    );
    return UIBarButtonItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:
  static UIBarButtonItem appearanceForTraitCollection(UITraitCollection trait) {
    objc.checkOsVersionInternal('UIBarButtonItem.appearanceForTraitCollection:', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_UIBarButtonItem, _sel_appearanceForTraitCollection_, trait.ref.pointer);
    return UIBarButtonItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedIn:
  static UIBarButtonItem appearanceForTraitCollection$1(
    UITraitCollection trait, {
    UIAppearanceContainer? whenContainedIn,
  }) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.appearanceForTraitCollection:whenContainedIn:',
      iOS: (false, (8, 0, 0)),
    );
    final _ret = _objc_msgSend_15qeuct(
      _class_UIBarButtonItem,
      _sel_appearanceForTraitCollection_whenContainedIn_,
      trait.ref.pointer,
      whenContainedIn?.ref.pointer ?? ffi.nullptr,
    );
    return UIBarButtonItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedInInstancesOfClasses:
  static UIBarButtonItem appearanceForTraitCollection$2(
    UITraitCollection trait, {
    required objc.NSArray whenContainedInInstancesOfClasses,
  }) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.appearanceForTraitCollection:whenContainedInInstancesOfClasses:',
      iOS: (false, (9, 0, 0)),
    );
    final _ret = _objc_msgSend_15qeuct(
      _class_UIBarButtonItem,
      _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_,
      trait.ref.pointer,
      whenContainedInInstancesOfClasses.ref.pointer,
    );
    return UIBarButtonItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of UIBarButtonItem constructed with the default `new` method.
  factory UIBarButtonItem() => new$();
}

extension UIBarButtonItem$Methods on UIBarButtonItem {
  /// init
  UIBarButtonItem init() {
    objc.checkOsVersionInternal('UIBarButtonItem.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIBarButtonItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIBarButtonItem? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0 ? null : UIBarButtonItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithImage:style:target:action:
  UIBarButtonItem initWithImage(
    UIImage? image, {
    required UIBarButtonItemStyle style,
    objc.ObjCObjectBase? target,
    required ffi.Pointer<objc.ObjCSelector> action,
  }) {
    objc.checkOsVersionInternal('UIBarButtonItem.initWithImage:style:target:action:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_13sbrg9(
      this.ref.retainAndReturnPointer(),
      _sel_initWithImage_style_target_action_,
      image?.ref.pointer ?? ffi.nullptr,
      style.value,
      target?.ref.pointer ?? ffi.nullptr,
      action,
    );
    return UIBarButtonItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithImage:landscapeImagePhone:style:target:action:
  UIBarButtonItem initWithImage$1(
    UIImage? image, {
    UIImage? landscapeImagePhone,
    required UIBarButtonItemStyle style,
    objc.ObjCObjectBase? target,
    required ffi.Pointer<objc.ObjCSelector> action,
  }) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.initWithImage:landscapeImagePhone:style:target:action:',
      iOS: (false, (5, 0, 0)),
    );
    final _ret = _objc_msgSend_1d97k9n(
      this.ref.retainAndReturnPointer(),
      _sel_initWithImage_landscapeImagePhone_style_target_action_,
      image?.ref.pointer ?? ffi.nullptr,
      landscapeImagePhone?.ref.pointer ?? ffi.nullptr,
      style.value,
      target?.ref.pointer ?? ffi.nullptr,
      action,
    );
    return UIBarButtonItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithTitle:style:target:action:
  UIBarButtonItem initWithTitle(
    objc.NSString? title, {
    required UIBarButtonItemStyle style,
    objc.ObjCObjectBase? target,
    required ffi.Pointer<objc.ObjCSelector> action,
  }) {
    objc.checkOsVersionInternal('UIBarButtonItem.initWithTitle:style:target:action:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_13sbrg9(
      this.ref.retainAndReturnPointer(),
      _sel_initWithTitle_style_target_action_,
      title?.ref.pointer ?? ffi.nullptr,
      style.value,
      target?.ref.pointer ?? ffi.nullptr,
      action,
    );
    return UIBarButtonItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithBarButtonSystemItem:target:action:
  UIBarButtonItem initWithBarButtonSystemItem(
    UIBarButtonSystemItem systemItem, {
    objc.ObjCObjectBase? target,
    required ffi.Pointer<objc.ObjCSelector> action,
  }) {
    objc.checkOsVersionInternal('UIBarButtonItem.initWithBarButtonSystemItem:target:action:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_18lulgh(
      this.ref.retainAndReturnPointer(),
      _sel_initWithBarButtonSystemItem_target_action_,
      systemItem.value,
      target?.ref.pointer ?? ffi.nullptr,
      action,
    );
    return UIBarButtonItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCustomView:
  UIBarButtonItem initWithCustomView(UIView customView) {
    objc.checkOsVersionInternal('UIBarButtonItem.initWithCustomView:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
      this.ref.retainAndReturnPointer(),
      _sel_initWithCustomView_,
      customView.ref.pointer,
    );
    return UIBarButtonItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// Creates a bar button item for the given systemItem. The primaryAction is copied, and its title & image are ignored.
  UIBarButtonItem initWithBarButtonSystemItem$1(UIBarButtonSystemItem systemItem, {UIAction? primaryAction}) {
    objc.checkOsVersionInternal('UIBarButtonItem.initWithBarButtonSystemItem:primaryAction:', iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_ka2bhe(
      this.ref.retainAndReturnPointer(),
      _sel_initWithBarButtonSystemItem_primaryAction_,
      systemItem.value,
      primaryAction?.ref.pointer ?? ffi.nullptr,
    );
    return UIBarButtonItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// Creates a plain-style bar button item from the properties of primaryAction. primaryAction is copied.
  UIBarButtonItem initWithPrimaryAction(UIAction? primaryAction) {
    objc.checkOsVersionInternal('UIBarButtonItem.initWithPrimaryAction:', iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
      this.ref.retainAndReturnPointer(),
      _sel_initWithPrimaryAction_,
      primaryAction?.ref.pointer ?? ffi.nullptr,
    );
    return UIBarButtonItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// Creates a bar button item for the given systemItem. The constructed item will present the menu immediately when touched.
  UIBarButtonItem initWithBarButtonSystemItem$2(UIBarButtonSystemItem systemItem, {UIMenu? menu}) {
    objc.checkOsVersionInternal('UIBarButtonItem.initWithBarButtonSystemItem:menu:', iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_ka2bhe(
      this.ref.retainAndReturnPointer(),
      _sel_initWithBarButtonSystemItem_menu_,
      systemItem.value,
      menu?.ref.pointer ?? ffi.nullptr,
    );
    return UIBarButtonItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// Creates a plain-style bar button item with the given title. The constructed item will present the menu immediately when touched.
  UIBarButtonItem initWithTitle$1(objc.NSString? title, {UIMenu? menu}) {
    objc.checkOsVersionInternal('UIBarButtonItem.initWithTitle:menu:', iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_15qeuct(
      this.ref.retainAndReturnPointer(),
      _sel_initWithTitle_menu_,
      title?.ref.pointer ?? ffi.nullptr,
      menu?.ref.pointer ?? ffi.nullptr,
    );
    return UIBarButtonItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// Creates a plain-style bar button item with the given item. The constructed item will present the menu immediately when touched.
  UIBarButtonItem initWithImage$2(UIImage? image, {UIMenu? menu}) {
    objc.checkOsVersionInternal('UIBarButtonItem.initWithImage:menu:', iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_15qeuct(
      this.ref.retainAndReturnPointer(),
      _sel_initWithImage_menu_,
      image?.ref.pointer ?? ffi.nullptr,
      menu?.ref.pointer ?? ffi.nullptr,
    );
    return UIBarButtonItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// style
  UIBarButtonItemStyle get style {
    objc.checkOsVersionInternal('UIBarButtonItem.style', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_121lhl0(this.ref.pointer, _sel_style);
    return UIBarButtonItemStyle.fromValue(_ret);
  }

  /// setStyle:
  set style(UIBarButtonItemStyle value) {
    objc.checkOsVersionInternal('UIBarButtonItem.setStyle:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_11ist7u(this.ref.pointer, _sel_setStyle_, value.value);
  }

  /// width
  double get width {
    objc.checkOsVersionInternal('UIBarButtonItem.width', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_width)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_width);
  }

  /// setWidth:
  set width(double value) {
    objc.checkOsVersionInternal('UIBarButtonItem.setWidth:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setWidth_, value);
  }

  /// possibleTitles
  objc.NSSet? get possibleTitles {
    objc.checkOsVersionInternal('UIBarButtonItem.possibleTitles', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_possibleTitles);
    return _ret.address == 0 ? null : objc.NSSet.castFromPointer(_ret, retain: true, release: true);
  }

  /// setPossibleTitles:
  set possibleTitles(objc.NSSet? value) {
    objc.checkOsVersionInternal('UIBarButtonItem.setPossibleTitles:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setPossibleTitles_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// customView
  UIView? get customView {
    objc.checkOsVersionInternal('UIBarButtonItem.customView', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_customView);
    return _ret.address == 0 ? null : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// setCustomView:
  set customView(UIView? value) {
    objc.checkOsVersionInternal('UIBarButtonItem.setCustomView:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setCustomView_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// action
  ffi.Pointer<objc.ObjCSelector> get action {
    objc.checkOsVersionInternal('UIBarButtonItem.action', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1ovaulg(this.ref.pointer, _sel_action);
  }

  /// setAction:
  set action(ffi.Pointer<objc.ObjCSelector> value) {
    objc.checkOsVersionInternal('UIBarButtonItem.setAction:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1d9e4oe(this.ref.pointer, _sel_setAction_, value);
  }

  /// target
  objc.ObjCObjectBase? get target {
    objc.checkOsVersionInternal('UIBarButtonItem.target', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_target);
    return _ret.address == 0 ? null : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// setTarget:
  set target(objc.ObjCObjectBase? value) {
    objc.checkOsVersionInternal('UIBarButtonItem.setTarget:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTarget_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Set the primaryAction on this item, updating the title & image of the item if appropriate (primaryAction is non-nil, and this is not a system item). When primaryAction is non-nil, the target & action properties are ignored. If primaryAction is set to nil, the title & image properties are left unchanged.
  UIAction? get primaryAction {
    objc.checkOsVersionInternal('UIBarButtonItem.primaryAction', iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_primaryAction);
    return _ret.address == 0 ? null : UIAction.castFromPointer(_ret, retain: true, release: true);
  }

  /// Set the primaryAction on this item, updating the title & image of the item if appropriate (primaryAction is non-nil, and this is not a system item). When primaryAction is non-nil, the target & action properties are ignored. If primaryAction is set to nil, the title & image properties are left unchanged.
  set primaryAction(UIAction? value) {
    objc.checkOsVersionInternal('UIBarButtonItem.setPrimaryAction:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setPrimaryAction_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// When non-nil the menu is presented, the gesture used to trigger the menu is based on if the bar button item would normally trigger an action when tapped.
  UIMenu? get menu {
    objc.checkOsVersionInternal('UIBarButtonItem.menu', iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_menu);
    return _ret.address == 0 ? null : UIMenu.castFromPointer(_ret, retain: true, release: true);
  }

  /// When non-nil the menu is presented, the gesture used to trigger the menu is based on if the bar button item would normally trigger an action when tapped.
  set menu(UIMenu? value) {
    objc.checkOsVersionInternal('UIBarButtonItem.setMenu:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setMenu_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Indicates if the button changes selection as its primary action.
  /// This shows the menu as options for selection if a menu is populated and no action when tapped is enabled.
  /// If no menu is provided and no action is enabled when tapped, the item is toggled on and off for the primary action.
  bool get changesSelectionAsPrimaryAction {
    objc.checkOsVersionInternal('UIBarButtonItem.changesSelectionAsPrimaryAction', iOS: (false, (15, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_changesSelectionAsPrimaryAction);
  }

  /// Indicates if the button changes selection as its primary action.
  /// This shows the menu as options for selection if a menu is populated and no action when tapped is enabled.
  /// If no menu is provided and no action is enabled when tapped, the item is toggled on and off for the primary action.
  set changesSelectionAsPrimaryAction(bool value) {
    objc.checkOsVersionInternal('UIBarButtonItem.setChangesSelectionAsPrimaryAction:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setChangesSelectionAsPrimaryAction_, value);
  }

  /// isSelected
  bool get selected {
    objc.checkOsVersionInternal('UIBarButtonItem.isSelected', iOS: (false, (15, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isSelected);
  }

  /// setSelected:
  set selected(bool value) {
    objc.checkOsVersionInternal('UIBarButtonItem.setSelected:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setSelected_, value);
  }

  /// setBackgroundImage:forState:barMetrics:
  void setBackgroundImage(
    UIImage? backgroundImage, {
    required UIControlState forState,
    required UIBarMetrics barMetrics,
  }) {
    objc.checkOsVersionInternal('UIBarButtonItem.setBackgroundImage:forState:barMetrics:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_1oar0aj(
      this.ref.pointer,
      _sel_setBackgroundImage_forState_barMetrics_,
      backgroundImage?.ref.pointer ?? ffi.nullptr,
      forState.value,
      barMetrics.value,
    );
  }

  /// backgroundImageForState:barMetrics:
  UIImage? backgroundImageForState(UIControlState state, {required UIBarMetrics barMetrics}) {
    objc.checkOsVersionInternal('UIBarButtonItem.backgroundImageForState:barMetrics:', iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_1mmfvr1(
      this.ref.pointer,
      _sel_backgroundImageForState_barMetrics_,
      state.value,
      barMetrics.value,
    );
    return _ret.address == 0 ? null : UIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// setBackgroundImage:forState:style:barMetrics:
  void setBackgroundImage$1(
    UIImage? backgroundImage, {
    required UIControlState forState,
    required UIBarButtonItemStyle style$1,
    required UIBarMetrics barMetrics,
  }) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.setBackgroundImage:forState:style:barMetrics:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_1lg97nc(
      this.ref.pointer,
      _sel_setBackgroundImage_forState_style_barMetrics_,
      backgroundImage?.ref.pointer ?? ffi.nullptr,
      forState.value,
      style$1.value,
      barMetrics.value,
    );
  }

  /// backgroundImageForState:style:barMetrics:
  UIImage? backgroundImageForState$1(
    UIControlState state, {
    required UIBarButtonItemStyle style$1,
    required UIBarMetrics barMetrics,
  }) {
    objc.checkOsVersionInternal('UIBarButtonItem.backgroundImageForState:style:barMetrics:', iOS: (false, (6, 0, 0)));
    final _ret = _objc_msgSend_15kz3t6(
      this.ref.pointer,
      _sel_backgroundImageForState_style_barMetrics_,
      state.value,
      style$1.value,
      barMetrics.value,
    );
    return _ret.address == 0 ? null : UIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// tintColor
  UIColor? get tintColor {
    objc.checkOsVersionInternal('UIBarButtonItem.tintColor', iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_tintColor);
    return _ret.address == 0 ? null : UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTintColor:
  set tintColor(UIColor? value) {
    objc.checkOsVersionInternal('UIBarButtonItem.setTintColor:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTintColor_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setBackgroundVerticalPositionAdjustment:forBarMetrics:
  void setBackgroundVerticalPositionAdjustment(double adjustment, {required UIBarMetrics forBarMetrics}) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.setBackgroundVerticalPositionAdjustment:forBarMetrics:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_159fszq(
      this.ref.pointer,
      _sel_setBackgroundVerticalPositionAdjustment_forBarMetrics_,
      adjustment,
      forBarMetrics.value,
    );
  }

  /// backgroundVerticalPositionAdjustmentForBarMetrics:
  double backgroundVerticalPositionAdjustmentForBarMetrics(UIBarMetrics barMetrics) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.backgroundVerticalPositionAdjustmentForBarMetrics:',
      iOS: (false, (5, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ih4ekwFpret(
            this.ref.pointer,
            _sel_backgroundVerticalPositionAdjustmentForBarMetrics_,
            barMetrics.value,
          )
        : _objc_msgSend_1ih4ekw(
            this.ref.pointer,
            _sel_backgroundVerticalPositionAdjustmentForBarMetrics_,
            barMetrics.value,
          );
  }

  /// setTitlePositionAdjustment:forBarMetrics:
  void setTitlePositionAdjustment(UIOffset adjustment, {required UIBarMetrics forBarMetrics}) {
    objc.checkOsVersionInternal('UIBarButtonItem.setTitlePositionAdjustment:forBarMetrics:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_dhwtpp(
      this.ref.pointer,
      _sel_setTitlePositionAdjustment_forBarMetrics_,
      adjustment,
      forBarMetrics.value,
    );
  }

  /// titlePositionAdjustmentForBarMetrics:
  UIOffset titlePositionAdjustmentForBarMetrics(UIBarMetrics barMetrics) {
    objc.checkOsVersionInternal('UIBarButtonItem.titlePositionAdjustmentForBarMetrics:', iOS: (false, (5, 0, 0)));
    final _ptr = pkg_ffi.calloc<UIOffset>();
    objc.useMsgSendVariants
        ? _objc_msgSend_qx0nmfStret(
            _ptr,
            this.ref.pointer,
            _sel_titlePositionAdjustmentForBarMetrics_,
            barMetrics.value,
          )
        : _ptr.ref = _objc_msgSend_qx0nmf(
            this.ref.pointer,
            _sel_titlePositionAdjustmentForBarMetrics_,
            barMetrics.value,
          );
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIOffset>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIOffset>(_finalizable);
  }

  /// setBackButtonBackgroundImage:forState:barMetrics:
  void setBackButtonBackgroundImage(
    UIImage? backgroundImage, {
    required UIControlState forState,
    required UIBarMetrics barMetrics,
  }) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.setBackButtonBackgroundImage:forState:barMetrics:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_1oar0aj(
      this.ref.pointer,
      _sel_setBackButtonBackgroundImage_forState_barMetrics_,
      backgroundImage?.ref.pointer ?? ffi.nullptr,
      forState.value,
      barMetrics.value,
    );
  }

  /// backButtonBackgroundImageForState:barMetrics:
  UIImage? backButtonBackgroundImageForState(UIControlState state, {required UIBarMetrics barMetrics}) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.backButtonBackgroundImageForState:barMetrics:',
      iOS: (false, (5, 0, 0)),
    );
    final _ret = _objc_msgSend_1mmfvr1(
      this.ref.pointer,
      _sel_backButtonBackgroundImageForState_barMetrics_,
      state.value,
      barMetrics.value,
    );
    return _ret.address == 0 ? null : UIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// setBackButtonTitlePositionAdjustment:forBarMetrics:
  void setBackButtonTitlePositionAdjustment(UIOffset adjustment, {required UIBarMetrics forBarMetrics}) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.setBackButtonTitlePositionAdjustment:forBarMetrics:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_dhwtpp(
      this.ref.pointer,
      _sel_setBackButtonTitlePositionAdjustment_forBarMetrics_,
      adjustment,
      forBarMetrics.value,
    );
  }

  /// backButtonTitlePositionAdjustmentForBarMetrics:
  UIOffset backButtonTitlePositionAdjustmentForBarMetrics(UIBarMetrics barMetrics) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.backButtonTitlePositionAdjustmentForBarMetrics:',
      iOS: (false, (5, 0, 0)),
    );
    final _ptr = pkg_ffi.calloc<UIOffset>();
    objc.useMsgSendVariants
        ? _objc_msgSend_qx0nmfStret(
            _ptr,
            this.ref.pointer,
            _sel_backButtonTitlePositionAdjustmentForBarMetrics_,
            barMetrics.value,
          )
        : _ptr.ref = _objc_msgSend_qx0nmf(
            this.ref.pointer,
            _sel_backButtonTitlePositionAdjustmentForBarMetrics_,
            barMetrics.value,
          );
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIOffset>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIOffset>(_finalizable);
  }

  /// setBackButtonBackgroundVerticalPositionAdjustment:forBarMetrics:
  void setBackButtonBackgroundVerticalPositionAdjustment(double adjustment, {required UIBarMetrics forBarMetrics}) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.setBackButtonBackgroundVerticalPositionAdjustment:forBarMetrics:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_159fszq(
      this.ref.pointer,
      _sel_setBackButtonBackgroundVerticalPositionAdjustment_forBarMetrics_,
      adjustment,
      forBarMetrics.value,
    );
  }

  /// backButtonBackgroundVerticalPositionAdjustmentForBarMetrics:
  double backButtonBackgroundVerticalPositionAdjustmentForBarMetrics(UIBarMetrics barMetrics) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.backButtonBackgroundVerticalPositionAdjustmentForBarMetrics:',
      iOS: (false, (5, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ih4ekwFpret(
            this.ref.pointer,
            _sel_backButtonBackgroundVerticalPositionAdjustmentForBarMetrics_,
            barMetrics.value,
          )
        : _objc_msgSend_1ih4ekw(
            this.ref.pointer,
            _sel_backButtonBackgroundVerticalPositionAdjustmentForBarMetrics_,
            barMetrics.value,
          );
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }
}

late final _sel_editButtonItem = objc.registerName("editButtonItem");

/// UIViewControllerEditing
extension UIViewControllerEditing on UIViewController {
  /// isEditing
  bool get editing {
    objc.checkOsVersionInternal('UIViewController.isEditing', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isEditing);
  }

  /// setEditing:
  set editing(bool value) {
    objc.checkOsVersionInternal('UIViewController.setEditing:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setEditing_, value);
  }

  /// setEditing:animated:
  void setEditing(bool editing$1, {required bool animated}) {
    objc.checkOsVersionInternal('UIViewController.setEditing:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_14iqu8t(this.ref.pointer, _sel_setEditing_animated_, editing$1, animated);
  }

  /// editButtonItem
  UIBarButtonItem get editButtonItem {
    objc.checkOsVersionInternal('UIViewController.editButtonItem', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_editButtonItem);
    return UIBarButtonItem.castFromPointer(_ret, retain: true, release: true);
  }
}

/// WARNING: UISearchDisplayController is a stub. To generate bindings for this class, include
/// UISearchDisplayController in your config's objc-interfaces list.
///
/// UISearchDisplayController
class UISearchDisplayController extends objc.ObjCObjectBase {
  UISearchDisplayController._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UISearchDisplayController] that points to the same underlying object as [other].
  UISearchDisplayController.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UISearchDisplayController] that wraps the given raw object pointer.
  UISearchDisplayController.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_searchDisplayController = objc.registerName("searchDisplayController");

/// UISearchDisplayControllerSupport
extension UISearchDisplayControllerSupport on UIViewController {
  /// searchDisplayController
  UISearchDisplayController? get searchDisplayController {
    objc.checkOsVersionInternal('UIViewController.searchDisplayController', iOS: (false, (3, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_searchDisplayController);
    return _ret.address == 0 ? null : UISearchDisplayController.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_childViewControllers = objc.registerName("childViewControllers");
late final _sel_addChildViewController_ = objc.registerName("addChildViewController:");
late final _sel_removeFromParentViewController = objc.registerName("removeFromParentViewController");

enum UIViewAnimationOptions {
  UIViewAnimationOptionLayoutSubviews(1),
  UIViewAnimationOptionAllowUserInteraction(2),
  UIViewAnimationOptionBeginFromCurrentState(4),
  UIViewAnimationOptionRepeat(8),
  UIViewAnimationOptionAutoreverse(16),
  UIViewAnimationOptionOverrideInheritedDuration(32),
  UIViewAnimationOptionOverrideInheritedCurve(64),
  UIViewAnimationOptionAllowAnimatedContent(128),
  UIViewAnimationOptionShowHideTransitionViews(256),
  UIViewAnimationOptionOverrideInheritedOptions(512),
  UIViewAnimationOptionCurveEaseInOut(0),
  UIViewAnimationOptionCurveEaseIn(65536),
  UIViewAnimationOptionCurveEaseOut(131072),
  UIViewAnimationOptionCurveLinear(196608),
  UIViewAnimationOptionTransitionFlipFromLeft(1048576),
  UIViewAnimationOptionTransitionFlipFromRight(2097152),
  UIViewAnimationOptionTransitionCurlUp(3145728),
  UIViewAnimationOptionTransitionCurlDown(4194304),
  UIViewAnimationOptionTransitionCrossDissolve(5242880),
  UIViewAnimationOptionTransitionFlipFromTop(6291456),
  UIViewAnimationOptionTransitionFlipFromBottom(7340032),
  UIViewAnimationOptionPreferredFramesPerSecond60(50331648),
  UIViewAnimationOptionPreferredFramesPerSecond30(117440512);

  static const UIViewAnimationOptionTransitionNone = UIViewAnimationOptionCurveEaseInOut;
  static const UIViewAnimationOptionPreferredFramesPerSecondDefault = UIViewAnimationOptionCurveEaseInOut;

  final int value;
  const UIViewAnimationOptions(this.value);

  static UIViewAnimationOptions fromValue(int value) => switch (value) {
    1 => UIViewAnimationOptionLayoutSubviews,
    2 => UIViewAnimationOptionAllowUserInteraction,
    4 => UIViewAnimationOptionBeginFromCurrentState,
    8 => UIViewAnimationOptionRepeat,
    16 => UIViewAnimationOptionAutoreverse,
    32 => UIViewAnimationOptionOverrideInheritedDuration,
    64 => UIViewAnimationOptionOverrideInheritedCurve,
    128 => UIViewAnimationOptionAllowAnimatedContent,
    256 => UIViewAnimationOptionShowHideTransitionViews,
    512 => UIViewAnimationOptionOverrideInheritedOptions,
    0 => UIViewAnimationOptionCurveEaseInOut,
    65536 => UIViewAnimationOptionCurveEaseIn,
    131072 => UIViewAnimationOptionCurveEaseOut,
    196608 => UIViewAnimationOptionCurveLinear,
    1048576 => UIViewAnimationOptionTransitionFlipFromLeft,
    2097152 => UIViewAnimationOptionTransitionFlipFromRight,
    3145728 => UIViewAnimationOptionTransitionCurlUp,
    4194304 => UIViewAnimationOptionTransitionCurlDown,
    5242880 => UIViewAnimationOptionTransitionCrossDissolve,
    6291456 => UIViewAnimationOptionTransitionFlipFromTop,
    7340032 => UIViewAnimationOptionTransitionFlipFromBottom,
    50331648 => UIViewAnimationOptionPreferredFramesPerSecond60,
    117440512 => UIViewAnimationOptionPreferredFramesPerSecond30,
    _ => throw ArgumentError('Unknown value for UIViewAnimationOptions: $value'),
  };

  @override
  String toString() {
    if (this == UIViewAnimationOptionCurveEaseInOut)
      return "UIViewAnimationOptions.UIViewAnimationOptionCurveEaseInOut, UIViewAnimationOptions.UIViewAnimationOptionTransitionNone, UIViewAnimationOptions.UIViewAnimationOptionPreferredFramesPerSecondDefault";
    return super.toString();
  }
}

void _ObjCBlock_ffiVoid_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
) => block.ref.target.cast<ffi.NativeFunction<ffi.Void Function()>>().asFunction<void Function()>()();
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>(
      _ObjCBlock_ffiVoid_fnPtrTrampoline,
    ).cast();
void _ObjCBlock_ffiVoid_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
) => (objc.getBlockClosure(block) as void Function())();
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>(
      _ObjCBlock_ffiVoid_closureTrampoline,
    ).cast();
void _ObjCBlock_ffiVoid_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
) {
  (objc.getBlockClosure(block) as void Function())();
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)> _ObjCBlock_ffiVoid_listenerCallable =
    ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
      _ObjCBlock_ffiVoid_listenerTrampoline,
    )..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_blockingTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter) {
  try {
    (objc.getBlockClosure(block) as void Function())();
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>
_ObjCBlock_ffiVoid_blockingCallable =
    ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>.isolateLocal(
      _ObjCBlock_ffiVoid_blockingTrampoline,
    )..keepIsolateAlive = false;
ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>
_ObjCBlock_ffiVoid_blockingListenerCallable =
    ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>.listener(
      _ObjCBlock_ffiVoid_blockingTrampoline,
    )..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function()>`.
abstract final class ObjCBlock_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function()> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function()>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function()> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function()>(
    objc.newPointerBlock(_ObjCBlock_ffiVoid_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> fromFunction(void Function() fn, {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function()>(
        objc.newClosureBlock(_ObjCBlock_ffiVoid_closureCallable, () => fn(), keepIsolateAlive),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> listener(void Function() fn, {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_listenerCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_1pl9qdv(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function()>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function()> blocking(void Function() fn, {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_blockingCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_blockingListenerCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_1pl9qdv(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function()>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function()>`.
extension ObjCBlock_ffiVoid_CallExtension on objc.ObjCBlock<ffi.Void Function()> {
  void call() =>
      ref.pointer.ref.invoke
          .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block)>>()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>)>()(
        ref.pointer,
      );
}

void _ObjCBlock_ffiVoid_bool_fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, bool arg0) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Void Function(ffi.Bool arg0)>>()
    .asFunction<void Function(bool)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_bool_fnPtrCallable =
    ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)>(
      _ObjCBlock_ffiVoid_bool_fnPtrTrampoline,
    ).cast();
void _ObjCBlock_ffiVoid_bool_closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, bool arg0) =>
    (objc.getBlockClosure(block) as void Function(bool))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_bool_closureCallable =
    ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)>(
      _ObjCBlock_ffiVoid_bool_closureTrampoline,
    ).cast();
void _ObjCBlock_ffiVoid_bool_listenerTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, bool arg0) {
  (objc.getBlockClosure(block) as void Function(bool))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)>
_ObjCBlock_ffiVoid_bool_listenerCallable =
    ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)>.listener(
      _ObjCBlock_ffiVoid_bool_listenerTrampoline,
    )..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_bool_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  bool arg0,
) {
  try {
    (objc.getBlockClosure(block) as void Function(bool))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)>
_ObjCBlock_ffiVoid_bool_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)
      >.isolateLocal(_ObjCBlock_ffiVoid_bool_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)>
_ObjCBlock_ffiVoid_bool_blockingListenerCallable =
    ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)>.listener(
      _ObjCBlock_ffiVoid_bool_blockingTrampoline,
    )..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Bool)>`.
abstract final class ObjCBlock_ffiVoid_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
    objc.newPointerBlock(_ObjCBlock_ffiVoid_bool_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> fromFunction(
    void Function(bool) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
    objc.newClosureBlock(_ObjCBlock_ffiVoid_bool_closureCallable, (bool arg0) => fn(arg0), keepIsolateAlive),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> listener(void Function(bool) fn, {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_bool_listenerCallable.nativeFunction.cast(),
      (bool arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_1s56lr9(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> blocking(void Function(bool) fn, {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_bool_blockingCallable.nativeFunction.cast(),
      (bool arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_bool_blockingListenerCallable.nativeFunction.cast(),
      (bool arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_1s56lr9(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Bool)>`.
extension ObjCBlock_ffiVoid_bool_CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Bool)> {
  void call(bool arg0) => ref.pointer.ref.invoke
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Bool arg0)>>()
      .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, bool)>()(ref.pointer, arg0);
}

late final _sel_transitionFromViewController_toViewController_duration_options_animations_completion_ = objc
    .registerName("transitionFromViewController:toViewController:duration:options:animations:completion:");
final _objc_msgSend_2fdtmz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        double,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_beginAppearanceTransition_animated_ = objc.registerName("beginAppearanceTransition:animated:");
late final _sel_endAppearanceTransition = objc.registerName("endAppearanceTransition");
late final _sel_childViewControllerForStatusBarStyle = objc.registerName("childViewControllerForStatusBarStyle");
late final _sel_childViewControllerForStatusBarHidden = objc.registerName("childViewControllerForStatusBarHidden");
late final _sel_setOverrideTraitCollection_forChildViewController_ = objc.registerName(
  "setOverrideTraitCollection:forChildViewController:",
);
final _objc_msgSend_pfv6jd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_overrideTraitCollectionForChildViewController_ = objc.registerName(
  "overrideTraitCollectionForChildViewController:",
);
late final _sel_childViewControllerForUserInterfaceStyle = objc.registerName(
  "childViewControllerForUserInterfaceStyle",
);

/// UIContainerViewControllerProtectedMethods
extension UIContainerViewControllerProtectedMethods on UIViewController {
  /// childViewControllers
  objc.NSArray get childViewControllers {
    objc.checkOsVersionInternal('UIViewController.childViewControllers', iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_childViewControllers);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// addChildViewController:
  void addChildViewController(UIViewController childController) {
    objc.checkOsVersionInternal('UIViewController.addChildViewController:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addChildViewController_, childController.ref.pointer);
  }

  /// removeFromParentViewController
  void removeFromParentViewController() {
    objc.checkOsVersionInternal('UIViewController.removeFromParentViewController', iOS: (false, (5, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_removeFromParentViewController);
  }

  /// transitionFromViewController:toViewController:duration:options:animations:completion:
  void transitionFromViewController(
    UIViewController fromViewController, {
    required UIViewController toViewController,
    required double duration,
    required UIViewAnimationOptions options,
    objc.ObjCBlock<ffi.Void Function()>? animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.transitionFromViewController:toViewController:duration:options:animations:completion:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_2fdtmz(
      this.ref.pointer,
      _sel_transitionFromViewController_toViewController_duration_options_animations_completion_,
      fromViewController.ref.pointer,
      toViewController.ref.pointer,
      duration,
      options.value,
      animations?.ref.pointer ?? ffi.nullptr,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// beginAppearanceTransition:animated:
  void beginAppearanceTransition(bool isAppearing, {required bool animated}) {
    objc.checkOsVersionInternal('UIViewController.beginAppearanceTransition:animated:', macOS: (true, null));
    _objc_msgSend_14iqu8t(this.ref.pointer, _sel_beginAppearanceTransition_animated_, isAppearing, animated);
  }

  /// endAppearanceTransition
  void endAppearanceTransition() {
    objc.checkOsVersionInternal('UIViewController.endAppearanceTransition', macOS: (true, null));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_endAppearanceTransition);
  }

  /// childViewControllerForStatusBarStyle
  UIViewController? get childViewControllerForStatusBarStyle {
    objc.checkOsVersionInternal('UIViewController.childViewControllerForStatusBarStyle', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_childViewControllerForStatusBarStyle);
    return _ret.address == 0 ? null : UIViewController.castFromPointer(_ret, retain: true, release: true);
  }

  /// childViewControllerForStatusBarHidden
  UIViewController? get childViewControllerForStatusBarHidden {
    objc.checkOsVersionInternal('UIViewController.childViewControllerForStatusBarHidden', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_childViewControllerForStatusBarHidden);
    return _ret.address == 0 ? null : UIViewController.castFromPointer(_ret, retain: true, release: true);
  }

  /// setOverrideTraitCollection:forChildViewController:
  void setOverrideTraitCollection(UITraitCollection? collection, {required UIViewController forChildViewController}) {
    objc.checkOsVersionInternal(
      'UIViewController.setOverrideTraitCollection:forChildViewController:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_setOverrideTraitCollection_forChildViewController_,
      collection?.ref.pointer ?? ffi.nullptr,
      forChildViewController.ref.pointer,
    );
  }

  /// overrideTraitCollectionForChildViewController:
  UITraitCollection? overrideTraitCollectionForChildViewController(UIViewController childViewController) {
    objc.checkOsVersionInternal(
      'UIViewController.overrideTraitCollectionForChildViewController:',
      iOS: (false, (8, 0, 0)),
    );
    final _ret = _objc_msgSend_1sotr3r(
      this.ref.pointer,
      _sel_overrideTraitCollectionForChildViewController_,
      childViewController.ref.pointer,
    );
    return _ret.address == 0 ? null : UITraitCollection.castFromPointer(_ret, retain: true, release: true);
  }

  /// childViewControllerForUserInterfaceStyle
  UIViewController? get childViewControllerForUserInterfaceStyle {
    objc.checkOsVersionInternal('UIViewController.childViewControllerForUserInterfaceStyle', iOS: (true, null));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_childViewControllerForUserInterfaceStyle);
    return _ret.address == 0 ? null : UIViewController.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers = objc.registerName(
  "automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers",
);
late final _sel_shouldAutomaticallyForwardRotationMethods = objc.registerName(
  "shouldAutomaticallyForwardRotationMethods",
);
late final _sel_shouldAutomaticallyForwardAppearanceMethods = objc.registerName(
  "shouldAutomaticallyForwardAppearanceMethods",
);
late final _sel_willMoveToParentViewController_ = objc.registerName("willMoveToParentViewController:");
late final _sel_didMoveToParentViewController_ = objc.registerName("didMoveToParentViewController:");

/// UIContainerViewControllerCallbacks
extension UIContainerViewControllerCallbacks on UIViewController {
  /// automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers
  bool automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers() {
    objc.checkOsVersionInternal(
      'UIViewController.automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers',
      iOS: (false, (5, 0, 0)),
    );
    return _objc_msgSend_91o635(
      this.ref.pointer,
      _sel_automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers,
    );
  }

  /// shouldAutomaticallyForwardRotationMethods
  bool shouldAutomaticallyForwardRotationMethods() {
    objc.checkOsVersionInternal('UIViewController.shouldAutomaticallyForwardRotationMethods', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_shouldAutomaticallyForwardRotationMethods);
  }

  /// shouldAutomaticallyForwardAppearanceMethods
  bool get shouldAutomaticallyForwardAppearanceMethods {
    objc.checkOsVersionInternal(
      'UIViewController.shouldAutomaticallyForwardAppearanceMethods',
      iOS: (false, (6, 0, 0)),
    );
    return _objc_msgSend_91o635(this.ref.pointer, _sel_shouldAutomaticallyForwardAppearanceMethods);
  }

  /// willMoveToParentViewController:
  void willMoveToParentViewController(UIViewController? parent) {
    objc.checkOsVersionInternal('UIViewController.willMoveToParentViewController:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_willMoveToParentViewController_, parent?.ref.pointer ?? ffi.nullptr);
  }

  /// didMoveToParentViewController:
  void didMoveToParentViewController(UIViewController? parent) {
    objc.checkOsVersionInternal('UIViewController.didMoveToParentViewController:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_didMoveToParentViewController_, parent?.ref.pointer ?? ffi.nullptr);
  }
}

/// WARNING: UIStateRestoring is a stub. To generate bindings for this class, include
/// UIStateRestoring in your config's objc-protocols list.
///
/// UIStateRestoring
interface class UIStateRestoring extends objc.ObjCProtocolBase {
  UIStateRestoring._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIStateRestoring] that points to the same underlying object as [other].
  UIStateRestoring.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIStateRestoring] that wraps the given raw object pointer.
  UIStateRestoring.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_restorationIdentifier = objc.registerName("restorationIdentifier");
late final _sel_setRestorationIdentifier_ = objc.registerName("setRestorationIdentifier:");

/// WARNING: UIViewControllerRestoration is a stub. To generate bindings for this class, include
/// UIViewControllerRestoration in your config's objc-protocols list.
///
/// UIViewControllerRestoration
interface class UIViewControllerRestoration extends objc.ObjCProtocolBase {
  UIViewControllerRestoration._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIViewControllerRestoration] that points to the same underlying object as [other].
  UIViewControllerRestoration.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIViewControllerRestoration] that wraps the given raw object pointer.
  UIViewControllerRestoration.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_restorationClass = objc.registerName("restorationClass");
late final _sel_setRestorationClass_ = objc.registerName("setRestorationClass:");
late final _sel_encodeRestorableStateWithCoder_ = objc.registerName("encodeRestorableStateWithCoder:");
late final _sel_decodeRestorableStateWithCoder_ = objc.registerName("decodeRestorableStateWithCoder:");
late final _sel_applicationFinishedRestoringState = objc.registerName("applicationFinishedRestoringState");

/// UIStateRestoration
extension UIStateRestoration on UIViewController {
  /// restorationIdentifier
  objc.NSString? get restorationIdentifier {
    objc.checkOsVersionInternal('UIViewController.restorationIdentifier', iOS: (false, (6, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_restorationIdentifier);
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setRestorationIdentifier:
  set restorationIdentifier(objc.NSString? value) {
    objc.checkOsVersionInternal('UIViewController.setRestorationIdentifier:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setRestorationIdentifier_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// restorationClass
  UIViewControllerRestoration? get restorationClass {
    objc.checkOsVersionInternal('UIViewController.restorationClass', iOS: (false, (6, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_restorationClass);
    return _ret.address == 0 ? null : UIViewControllerRestoration.castFromPointer(_ret, retain: true, release: true);
  }

  /// setRestorationClass:
  set restorationClass(UIViewControllerRestoration? value) {
    objc.checkOsVersionInternal('UIViewController.setRestorationClass:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setRestorationClass_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// encodeRestorableStateWithCoder:
  void encodeRestorableStateWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal('UIViewController.encodeRestorableStateWithCoder:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeRestorableStateWithCoder_, coder.ref.pointer);
  }

  /// decodeRestorableStateWithCoder:
  void decodeRestorableStateWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal('UIViewController.decodeRestorableStateWithCoder:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_decodeRestorableStateWithCoder_, coder.ref.pointer);
  }

  /// applicationFinishedRestoringState
  void applicationFinishedRestoringState() {
    objc.checkOsVersionInternal('UIViewController.applicationFinishedRestoringState', iOS: (false, (7, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_applicationFinishedRestoringState);
  }
}

late final _sel_updateViewConstraints = objc.registerName("updateViewConstraints");

/// UIConstraintBasedLayoutCoreMethods
extension UIConstraintBasedLayoutCoreMethods on UIViewController {
  /// updateViewConstraints
  void updateViewConstraints() {
    objc.checkOsVersionInternal('UIViewController.updateViewConstraints', iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_updateViewConstraints);
  }
}

/// WARNING: UIViewControllerTransitioningDelegate is a stub. To generate bindings for this class, include
/// UIViewControllerTransitioningDelegate in your config's objc-protocols list.
///
/// UIViewControllerTransitioningDelegate
interface class UIViewControllerTransitioningDelegate extends objc.ObjCProtocolBase {
  UIViewControllerTransitioningDelegate._(
    ffi.Pointer<objc.ObjCObject> pointer, {
    bool retain = false,
    bool release = false,
  }) : super(pointer, retain: retain, release: release);

  /// Constructs a [UIViewControllerTransitioningDelegate] that points to the same underlying object as [other].
  UIViewControllerTransitioningDelegate.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIViewControllerTransitioningDelegate] that wraps the given raw object pointer.
  UIViewControllerTransitioningDelegate.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_transitioningDelegate = objc.registerName("transitioningDelegate");
late final _sel_setTransitioningDelegate_ = objc.registerName("setTransitioningDelegate:");

/// UIViewControllerTransitioning
extension UIViewControllerTransitioning on UIViewController {
  /// transitioningDelegate
  UIViewControllerTransitioningDelegate? get transitioningDelegate {
    objc.checkOsVersionInternal('UIViewController.transitioningDelegate', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_transitioningDelegate);
    return _ret.address == 0
        ? null
        : UIViewControllerTransitioningDelegate.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTransitioningDelegate:
  set transitioningDelegate(UIViewControllerTransitioningDelegate? value) {
    objc.checkOsVersionInternal('UIViewController.setTransitioningDelegate:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTransitioningDelegate_, value?.ref.pointer ?? ffi.nullptr);
  }
}

/// WARNING: UILayoutSupport is a stub. To generate bindings for this class, include
/// UILayoutSupport in your config's objc-protocols list.
///
/// UILayoutSupport
interface class UILayoutSupport extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UILayoutSupport._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UILayoutSupport] that points to the same underlying object as [other].
  UILayoutSupport.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UILayoutSupport] that wraps the given raw object pointer.
  UILayoutSupport.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_topLayoutGuide = objc.registerName("topLayoutGuide");
late final _sel_bottomLayoutGuide = objc.registerName("bottomLayoutGuide");
late final _sel_additionalSafeAreaInsets = objc.registerName("additionalSafeAreaInsets");
late final _sel_setAdditionalSafeAreaInsets_ = objc.registerName("setAdditionalSafeAreaInsets:");

final class NSDirectionalEdgeInsets extends ffi.Struct {
  @ffi.Double()
  external double top;

  @ffi.Double()
  external double leading;

  @ffi.Double()
  external double bottom;

  @ffi.Double()
  external double trailing;
}

late final _sel_systemMinimumLayoutMargins = objc.registerName("systemMinimumLayoutMargins");
final _objc_msgSend_12yjd2m = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<NSDirectionalEdgeInsets Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>
    >()
    .asFunction<NSDirectionalEdgeInsets Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_12yjd2mStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<NSDirectionalEdgeInsets>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<NSDirectionalEdgeInsets>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
late final _sel_viewRespectsSystemMinimumLayoutMargins = objc.registerName("viewRespectsSystemMinimumLayoutMargins");
late final _sel_setViewRespectsSystemMinimumLayoutMargins_ = objc.registerName(
  "setViewRespectsSystemMinimumLayoutMargins:",
);
late final _sel_viewLayoutMarginsDidChange = objc.registerName("viewLayoutMarginsDidChange");
late final _sel_viewSafeAreaInsetsDidChange = objc.registerName("viewSafeAreaInsetsDidChange");

/// UILayoutSupport
extension UILayoutSupport$1 on UIViewController {
  /// topLayoutGuide
  UILayoutSupport get topLayoutGuide {
    objc.checkOsVersionInternal('UIViewController.topLayoutGuide', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_topLayoutGuide);
    return UILayoutSupport.castFromPointer(_ret, retain: true, release: true);
  }

  /// bottomLayoutGuide
  UILayoutSupport get bottomLayoutGuide {
    objc.checkOsVersionInternal('UIViewController.bottomLayoutGuide', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_bottomLayoutGuide);
    return UILayoutSupport.castFromPointer(_ret, retain: true, release: true);
  }

  /// additionalSafeAreaInsets
  UIEdgeInsets get additionalSafeAreaInsets {
    objc.checkOsVersionInternal('UIViewController.additionalSafeAreaInsets', iOS: (false, (11, 0, 0)));
    final _ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(_ptr, this.ref.pointer, _sel_additionalSafeAreaInsets)
        : _ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_additionalSafeAreaInsets);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>(_finalizable);
  }

  /// setAdditionalSafeAreaInsets:
  set additionalSafeAreaInsets(UIEdgeInsets value) {
    objc.checkOsVersionInternal('UIViewController.setAdditionalSafeAreaInsets:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_1g8fos5(this.ref.pointer, _sel_setAdditionalSafeAreaInsets_, value);
  }

  /// systemMinimumLayoutMargins
  NSDirectionalEdgeInsets get systemMinimumLayoutMargins {
    objc.checkOsVersionInternal('UIViewController.systemMinimumLayoutMargins', iOS: (false, (11, 0, 0)));
    final _ptr = pkg_ffi.calloc<NSDirectionalEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_12yjd2mStret(_ptr, this.ref.pointer, _sel_systemMinimumLayoutMargins)
        : _ptr.ref = _objc_msgSend_12yjd2m(this.ref.pointer, _sel_systemMinimumLayoutMargins);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<NSDirectionalEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<NSDirectionalEdgeInsets>(_finalizable);
  }

  /// viewRespectsSystemMinimumLayoutMargins
  bool get viewRespectsSystemMinimumLayoutMargins {
    objc.checkOsVersionInternal('UIViewController.viewRespectsSystemMinimumLayoutMargins', iOS: (false, (11, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_viewRespectsSystemMinimumLayoutMargins);
  }

  /// setViewRespectsSystemMinimumLayoutMargins:
  set viewRespectsSystemMinimumLayoutMargins(bool value) {
    objc.checkOsVersionInternal(
      'UIViewController.setViewRespectsSystemMinimumLayoutMargins:',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setViewRespectsSystemMinimumLayoutMargins_, value);
  }

  /// viewLayoutMarginsDidChange
  void viewLayoutMarginsDidChange() {
    objc.checkOsVersionInternal('UIViewController.viewLayoutMarginsDidChange', iOS: (false, (11, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_viewLayoutMarginsDidChange);
  }

  /// viewSafeAreaInsetsDidChange
  void viewSafeAreaInsetsDidChange() {
    objc.checkOsVersionInternal('UIViewController.viewSafeAreaInsetsDidChange', iOS: (false, (11, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_viewSafeAreaInsetsDidChange);
  }
}

late final _sel_addKeyCommand_ = objc.registerName("addKeyCommand:");
late final _sel_removeKeyCommand_ = objc.registerName("removeKeyCommand:");

/// UIKeyCommand
extension UIKeyCommand$1 on UIViewController {
  /// addKeyCommand:
  void addKeyCommand(UIKeyCommand keyCommand) {
    objc.checkOsVersionInternal('UIViewController.addKeyCommand:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addKeyCommand_, keyCommand.ref.pointer);
  }

  /// removeKeyCommand:
  void removeKeyCommand(UIKeyCommand keyCommand) {
    objc.checkOsVersionInternal('UIViewController.removeKeyCommand:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_removeKeyCommand_, keyCommand.ref.pointer);
  }
}

late final _sel_performsActionsWhilePresentingModally = objc.registerName("performsActionsWhilePresentingModally");

/// UIPerformsActions
extension UIPerformsActions on UIViewController {
  /// Determines whether the receiver continues to respond to actions while it is presenting a view controller modally.
  ///
  /// Defaults to YES. You can change the default return value by providing a value for UIViewControllerPerformsActionsWhilePresentingModally in your Info.plist file.
  bool get performsActionsWhilePresentingModally {
    objc.checkOsVersionInternal('UIViewController.performsActionsWhilePresentingModally', iOS: (false, (13, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_performsActionsWhilePresentingModally);
  }
}

late final _sel_extensionContext = objc.registerName("extensionContext");
late final _sel_beginRequestWithExtensionContext_ = objc.registerName("beginRequestWithExtensionContext:");
void _ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
    .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
>
_ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.isolateLocal(_ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)>(
    objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, NSExtensionContext) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)>(
    objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, NSExtensionContext.castFromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)> listener(
    void Function(ffi.Pointer<ffi.Void>, NSExtensionContext) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext_listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, NSExtensionContext.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)> blocking(
    void Function(ffi.Pointer<ffi.Void>, NSExtensionContext) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext_blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, NSExtensionContext.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext_blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, NSExtensionContext.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)>(
      wrapper,
      retain: false,
      release: true,
    );
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSExtensionContext arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// NSExtensionAdditions
extension NSExtensionAdditions on UIViewController {
  /// extensionContext
  NSExtensionContext? get extensionContext {
    objc.checkOsVersionInternal('UIViewController.extensionContext', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_extensionContext);
    return _ret.address == 0 ? null : NSExtensionContext.castFromPointer(_ret, retain: true, release: true);
  }

  /// beginRequestWithExtensionContext:
  void beginRequestWithExtensionContext(NSExtensionContext context) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_beginRequestWithExtensionContext_, context.ref.pointer);
  }
}

/// WARNING: UIPresentationController is a stub. To generate bindings for this class, include
/// UIPresentationController in your config's objc-interfaces list.
///
/// UIPresentationController
class UIPresentationController extends objc.ObjCObjectBase {
  UIPresentationController._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIPresentationController] that points to the same underlying object as [other].
  UIPresentationController.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIPresentationController] that wraps the given raw object pointer.
  UIPresentationController.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_presentationController = objc.registerName("presentationController");

/// WARNING: UISheetPresentationController is a stub. To generate bindings for this class, include
/// UISheetPresentationController in your config's objc-interfaces list.
///
/// UISheetPresentationController
class UISheetPresentationController extends objc.ObjCObjectBase {
  UISheetPresentationController._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UISheetPresentationController] that points to the same underlying object as [other].
  UISheetPresentationController.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UISheetPresentationController] that wraps the given raw object pointer.
  UISheetPresentationController.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_sheetPresentationController = objc.registerName("sheetPresentationController");

/// WARNING: UIPopoverPresentationController is a stub. To generate bindings for this class, include
/// UIPopoverPresentationController in your config's objc-interfaces list.
///
/// UIPopoverPresentationController
class UIPopoverPresentationController extends objc.ObjCObjectBase {
  UIPopoverPresentationController._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIPopoverPresentationController] that points to the same underlying object as [other].
  UIPopoverPresentationController.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIPopoverPresentationController] that wraps the given raw object pointer.
  UIPopoverPresentationController.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_popoverPresentationController = objc.registerName("popoverPresentationController");
late final _sel_isModalInPresentation = objc.registerName("isModalInPresentation");
late final _sel_setModalInPresentation_ = objc.registerName("setModalInPresentation:");

/// UIPresentationController
extension UIPresentationController$1 on UIViewController {
  /// presentationController
  UIPresentationController? get presentationController {
    objc.checkOsVersionInternal('UIViewController.presentationController', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_presentationController);
    return _ret.address == 0 ? null : UIPresentationController.castFromPointer(_ret, retain: true, release: true);
  }

  /// sheetPresentationController
  UISheetPresentationController? get sheetPresentationController {
    objc.checkOsVersionInternal('UIViewController.sheetPresentationController', iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_sheetPresentationController);
    return _ret.address == 0 ? null : UISheetPresentationController.castFromPointer(_ret, retain: true, release: true);
  }

  /// popoverPresentationController
  UIPopoverPresentationController? get popoverPresentationController {
    objc.checkOsVersionInternal('UIViewController.popoverPresentationController', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_popoverPresentationController);
    return _ret.address == 0
        ? null
        : UIPopoverPresentationController.castFromPointer(_ret, retain: true, release: true);
  }

  /// isModalInPresentation
  bool get modalInPresentation {
    objc.checkOsVersionInternal('UIViewController.isModalInPresentation', iOS: (false, (13, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isModalInPresentation);
  }

  /// setModalInPresentation:
  set modalInPresentation(bool value) {
    objc.checkOsVersionInternal('UIViewController.setModalInPresentation:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setModalInPresentation_, value);
  }
}

/// WARNING: UIViewControllerPreviewing is a stub. To generate bindings for this class, include
/// UIViewControllerPreviewing in your config's objc-protocols list.
///
/// UIViewControllerPreviewing
interface class UIViewControllerPreviewing extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIViewControllerPreviewing._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIViewControllerPreviewing] that points to the same underlying object as [other].
  UIViewControllerPreviewing.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIViewControllerPreviewing] that wraps the given raw object pointer.
  UIViewControllerPreviewing.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

/// WARNING: UIViewControllerPreviewingDelegate is a stub. To generate bindings for this class, include
/// UIViewControllerPreviewingDelegate in your config's objc-protocols list.
///
/// UIViewControllerPreviewingDelegate
interface class UIViewControllerPreviewingDelegate extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIViewControllerPreviewingDelegate._(
    ffi.Pointer<objc.ObjCObject> pointer, {
    bool retain = false,
    bool release = false,
  }) : super(pointer, retain: retain, release: release);

  /// Constructs a [UIViewControllerPreviewingDelegate] that points to the same underlying object as [other].
  UIViewControllerPreviewingDelegate.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIViewControllerPreviewingDelegate] that wraps the given raw object pointer.
  UIViewControllerPreviewingDelegate.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_registerForPreviewingWithDelegate_sourceView_ = objc.registerName(
  "registerForPreviewingWithDelegate:sourceView:",
);
late final _sel_unregisterForPreviewingWithContext_ = objc.registerName("unregisterForPreviewingWithContext:");

/// UIViewControllerPreviewingRegistration
extension UIViewControllerPreviewingRegistration on UIViewController {
  /// registerForPreviewingWithDelegate:sourceView:
  UIViewControllerPreviewing registerForPreviewingWithDelegate(
    UIViewControllerPreviewingDelegate delegate, {
    required UIView sourceView,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.registerForPreviewingWithDelegate:sourceView:',
      iOS: (false, (9, 0, 0)),
    );
    final _ret = _objc_msgSend_15qeuct(
      this.ref.pointer,
      _sel_registerForPreviewingWithDelegate_sourceView_,
      delegate.ref.pointer,
      sourceView.ref.pointer,
    );
    return UIViewControllerPreviewing.castFromPointer(_ret, retain: true, release: true);
  }

  /// unregisterForPreviewingWithContext:
  void unregisterForPreviewingWithContext(UIViewControllerPreviewing previewing) {
    objc.checkOsVersionInternal('UIViewController.unregisterForPreviewingWithContext:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_unregisterForPreviewingWithContext_, previewing.ref.pointer);
  }
}

late final _sel_childViewControllerForScreenEdgesDeferringSystemGestures = objc.registerName(
  "childViewControllerForScreenEdgesDeferringSystemGestures",
);

enum UIRectEdge {
  UIRectEdgeNone(0),
  UIRectEdgeTop(1),
  UIRectEdgeLeft(2),
  UIRectEdgeBottom(4),
  UIRectEdgeRight(8),
  UIRectEdgeAll(15);

  final int value;
  const UIRectEdge(this.value);

  static UIRectEdge fromValue(int value) => switch (value) {
    0 => UIRectEdgeNone,
    1 => UIRectEdgeTop,
    2 => UIRectEdgeLeft,
    4 => UIRectEdgeBottom,
    8 => UIRectEdgeRight,
    15 => UIRectEdgeAll,
    _ => throw ArgumentError('Unknown value for UIRectEdge: $value'),
  };
}

late final _sel_preferredScreenEdgesDeferringSystemGestures = objc.registerName(
  "preferredScreenEdgesDeferringSystemGestures",
);
final _objc_msgSend_qrqu1s = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setNeedsUpdateOfScreenEdgesDeferringSystemGestures = objc.registerName(
  "setNeedsUpdateOfScreenEdgesDeferringSystemGestures",
);

/// UIScreenEdgesDeferringSystemGestures
extension UIScreenEdgesDeferringSystemGestures on UIViewController {
  /// childViewControllerForScreenEdgesDeferringSystemGestures
  UIViewController? get childViewControllerForScreenEdgesDeferringSystemGestures {
    objc.checkOsVersionInternal(
      'UIViewController.childViewControllerForScreenEdgesDeferringSystemGestures',
      iOS: (false, (11, 0, 0)),
    );
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_childViewControllerForScreenEdgesDeferringSystemGestures);
    return _ret.address == 0 ? null : UIViewController.castFromPointer(_ret, retain: true, release: true);
  }

  /// preferredScreenEdgesDeferringSystemGestures
  UIRectEdge get preferredScreenEdgesDeferringSystemGestures {
    objc.checkOsVersionInternal(
      'UIViewController.preferredScreenEdgesDeferringSystemGestures',
      iOS: (false, (11, 0, 0)),
    );
    final _ret = _objc_msgSend_qrqu1s(this.ref.pointer, _sel_preferredScreenEdgesDeferringSystemGestures);
    return UIRectEdge.fromValue(_ret);
  }

  /// setNeedsUpdateOfScreenEdgesDeferringSystemGestures
  void setNeedsUpdateOfScreenEdgesDeferringSystemGestures() {
    objc.checkOsVersionInternal(
      'UIViewController.setNeedsUpdateOfScreenEdgesDeferringSystemGestures',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsUpdateOfScreenEdgesDeferringSystemGestures);
  }
}

late final _sel_childViewControllerForHomeIndicatorAutoHidden = objc.registerName(
  "childViewControllerForHomeIndicatorAutoHidden",
);
late final _sel_prefersHomeIndicatorAutoHidden = objc.registerName("prefersHomeIndicatorAutoHidden");
late final _sel_setNeedsUpdateOfHomeIndicatorAutoHidden = objc.registerName("setNeedsUpdateOfHomeIndicatorAutoHidden");

/// UIHomeIndicatorAutoHidden
extension UIHomeIndicatorAutoHidden on UIViewController {
  /// childViewControllerForHomeIndicatorAutoHidden
  UIViewController? get childViewControllerForHomeIndicatorAutoHidden {
    objc.checkOsVersionInternal(
      'UIViewController.childViewControllerForHomeIndicatorAutoHidden',
      iOS: (false, (11, 0, 0)),
    );
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_childViewControllerForHomeIndicatorAutoHidden);
    return _ret.address == 0 ? null : UIViewController.castFromPointer(_ret, retain: true, release: true);
  }

  /// prefersHomeIndicatorAutoHidden
  bool get prefersHomeIndicatorAutoHidden {
    objc.checkOsVersionInternal('UIViewController.prefersHomeIndicatorAutoHidden', iOS: (false, (11, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_prefersHomeIndicatorAutoHidden);
  }

  /// setNeedsUpdateOfHomeIndicatorAutoHidden
  void setNeedsUpdateOfHomeIndicatorAutoHidden() {
    objc.checkOsVersionInternal('UIViewController.setNeedsUpdateOfHomeIndicatorAutoHidden', iOS: (false, (11, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsUpdateOfHomeIndicatorAutoHidden);
  }
}

late final _sel_childViewControllerForPointerLock = objc.registerName("childViewControllerForPointerLock");
late final _sel_prefersPointerLocked = objc.registerName("prefersPointerLocked");
late final _sel_setNeedsUpdateOfPrefersPointerLocked = objc.registerName("setNeedsUpdateOfPrefersPointerLocked");

/// UIPointerLockSupport
extension UIPointerLockSupport on UIViewController {
  /// childViewControllerForPointerLock
  UIViewController? get childViewControllerForPointerLock {
    objc.checkOsVersionInternal('UIViewController.childViewControllerForPointerLock', iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_childViewControllerForPointerLock);
    return _ret.address == 0 ? null : UIViewController.castFromPointer(_ret, retain: true, release: true);
  }

  /// prefersPointerLocked
  bool get prefersPointerLocked {
    objc.checkOsVersionInternal('UIViewController.prefersPointerLocked', iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_prefersPointerLocked);
  }

  /// setNeedsUpdateOfPrefersPointerLocked
  void setNeedsUpdateOfPrefersPointerLocked() {
    objc.checkOsVersionInternal('UIViewController.setNeedsUpdateOfPrefersPointerLocked', iOS: (false, (14, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsUpdateOfPrefersPointerLocked);
  }
}

///
extension unnamed on UIViewController {}

late final _class_UINavigationItem = objc.getClass("UINavigationItem");
late final _sel_initWithTitle_ = objc.registerName("initWithTitle:");
late final _sel_titleView = objc.registerName("titleView");
late final _sel_setTitleView_ = objc.registerName("setTitleView:");
late final _sel_prompt = objc.registerName("prompt");
late final _sel_setPrompt_ = objc.registerName("setPrompt:");
late final _sel_backBarButtonItem = objc.registerName("backBarButtonItem");
late final _sel_setBackBarButtonItem_ = objc.registerName("setBackBarButtonItem:");
late final _sel_backButtonTitle = objc.registerName("backButtonTitle");
late final _sel_setBackButtonTitle_ = objc.registerName("setBackButtonTitle:");
late final _sel_hidesBackButton = objc.registerName("hidesBackButton");
late final _sel_setHidesBackButton_ = objc.registerName("setHidesBackButton:");
late final _sel_setHidesBackButton_animated_ = objc.registerName("setHidesBackButton:animated:");

enum UINavigationItemBackButtonDisplayMode {
  /// Default mode, uses an appropriate title, followed by a generic title (typically 'Back'), then no title.
  UINavigationItemBackButtonDisplayModeDefault(0),

  /// Generic titles only. Ignores .title and .backButtonTitle (but *not* .backBarButtonItem.title).
  UINavigationItemBackButtonDisplayModeGeneric(1),

  /// Don't use a title, just the back button indicator image.
  UINavigationItemBackButtonDisplayModeMinimal(2);

  final int value;
  const UINavigationItemBackButtonDisplayMode(this.value);

  static UINavigationItemBackButtonDisplayMode fromValue(int value) => switch (value) {
    0 => UINavigationItemBackButtonDisplayModeDefault,
    1 => UINavigationItemBackButtonDisplayModeGeneric,
    2 => UINavigationItemBackButtonDisplayModeMinimal,
    _ => throw ArgumentError('Unknown value for UINavigationItemBackButtonDisplayMode: $value'),
  };
}

late final _sel_backButtonDisplayMode = objc.registerName("backButtonDisplayMode");
final _objc_msgSend_10bx5wy = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setBackButtonDisplayMode_ = objc.registerName("setBackButtonDisplayMode:");
final _objc_msgSend_1dph54c = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_leftBarButtonItems = objc.registerName("leftBarButtonItems");
late final _sel_setLeftBarButtonItems_ = objc.registerName("setLeftBarButtonItems:");
late final _sel_rightBarButtonItems = objc.registerName("rightBarButtonItems");
late final _sel_setRightBarButtonItems_ = objc.registerName("setRightBarButtonItems:");
late final _sel_setLeftBarButtonItems_animated_ = objc.registerName("setLeftBarButtonItems:animated:");
final _objc_msgSend_6p7ndb = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>, bool)
    >();
late final _sel_setRightBarButtonItems_animated_ = objc.registerName("setRightBarButtonItems:animated:");
late final _sel_leftItemsSupplementBackButton = objc.registerName("leftItemsSupplementBackButton");
late final _sel_setLeftItemsSupplementBackButton_ = objc.registerName("setLeftItemsSupplementBackButton:");
late final _sel_leftBarButtonItem = objc.registerName("leftBarButtonItem");
late final _sel_setLeftBarButtonItem_ = objc.registerName("setLeftBarButtonItem:");
late final _sel_rightBarButtonItem = objc.registerName("rightBarButtonItem");
late final _sel_setRightBarButtonItem_ = objc.registerName("setRightBarButtonItem:");
late final _sel_setLeftBarButtonItem_animated_ = objc.registerName("setLeftBarButtonItem:animated:");
late final _sel_setRightBarButtonItem_animated_ = objc.registerName("setRightBarButtonItem:animated:");

enum UINavigationItemLargeTitleDisplayMode {
  /// Automatically use the large out-of-line title based on the state of the previous item in the navigation bar. An item with largeTitleDisplayMode=Automatic will show or hide the large title based on the request of the previous navigation item. If the first item pushed is set to Automatic, then it will show the large title if the navigation bar has prefersLargeTitles=YES.
  UINavigationItemLargeTitleDisplayModeAutomatic(0),

  /// Always use a larger title when this item is topmost.
  UINavigationItemLargeTitleDisplayModeAlways(1),

  /// Never use a larger title when this item is topmost.
  UINavigationItemLargeTitleDisplayModeNever(2);

  final int value;
  const UINavigationItemLargeTitleDisplayMode(this.value);

  static UINavigationItemLargeTitleDisplayMode fromValue(int value) => switch (value) {
    0 => UINavigationItemLargeTitleDisplayModeAutomatic,
    1 => UINavigationItemLargeTitleDisplayModeAlways,
    2 => UINavigationItemLargeTitleDisplayModeNever,
    _ => throw ArgumentError('Unknown value for UINavigationItemLargeTitleDisplayMode: $value'),
  };
}

late final _sel_largeTitleDisplayMode = objc.registerName("largeTitleDisplayMode");
final _objc_msgSend_1j6d9um = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setLargeTitleDisplayMode_ = objc.registerName("setLargeTitleDisplayMode:");
final _objc_msgSend_1ddnfsg = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();

/// WARNING: UISearchController is a stub. To generate bindings for this class, include
/// UISearchController in your config's objc-interfaces list.
///
/// UISearchController
class UISearchController extends objc.ObjCObjectBase {
  UISearchController._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UISearchController] that points to the same underlying object as [other].
  UISearchController.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UISearchController] that wraps the given raw object pointer.
  UISearchController.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_searchController = objc.registerName("searchController");
late final _sel_setSearchController_ = objc.registerName("setSearchController:");
late final _sel_hidesSearchBarWhenScrolling = objc.registerName("hidesSearchBarWhenScrolling");
late final _sel_setHidesSearchBarWhenScrolling_ = objc.registerName("setHidesSearchBarWhenScrolling:");
late final _class_UINavigationBarAppearance = objc.getClass("UINavigationBarAppearance");

/// UINavigationBarAppearance
class UINavigationBarAppearance extends objc.ObjCObjectBase {
  UINavigationBarAppearance._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UINavigationBarAppearance] that points to the same underlying object as [other].
  UINavigationBarAppearance.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UINavigationBarAppearance] that wraps the given raw object pointer.
  UINavigationBarAppearance.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UINavigationBarAppearance].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UINavigationBarAppearance);
  }
}

extension UINavigationBarAppearance$Methods on UINavigationBarAppearance {}

late final _sel_standardAppearance = objc.registerName("standardAppearance");
late final _sel_setStandardAppearance_ = objc.registerName("setStandardAppearance:");
late final _sel_compactAppearance = objc.registerName("compactAppearance");
late final _sel_setCompactAppearance_ = objc.registerName("setCompactAppearance:");
late final _sel_scrollEdgeAppearance = objc.registerName("scrollEdgeAppearance");
late final _sel_setScrollEdgeAppearance_ = objc.registerName("setScrollEdgeAppearance:");
late final _sel_compactScrollEdgeAppearance = objc.registerName("compactScrollEdgeAppearance");
late final _sel_setCompactScrollEdgeAppearance_ = objc.registerName("setCompactScrollEdgeAppearance:");

/// UINavigationItem
class UINavigationItem extends objc.NSObject implements objc.NSCoding {
  UINavigationItem._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [UINavigationItem] that points to the same underlying object as [other].
  UINavigationItem.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UINavigationItem] that wraps the given raw object pointer.
  UINavigationItem.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UINavigationItem].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UINavigationItem);
  }

  /// new
  static UINavigationItem new$() {
    final _ret = _objc_msgSend_151sglz(_class_UINavigationItem, _sel_new);
    return UINavigationItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UINavigationItem allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(_class_UINavigationItem, _sel_allocWithZone_, zone);
    return UINavigationItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UINavigationItem alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UINavigationItem, _sel_alloc);
    return UINavigationItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of UINavigationItem constructed with the default `new` method.
  factory UINavigationItem() => new$();
}

extension UINavigationItem$Methods on UINavigationItem {
  /// initWithTitle:
  UINavigationItem initWithTitle(objc.NSString title) {
    objc.checkOsVersionInternal('UINavigationItem.initWithTitle:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithTitle_, title.ref.pointer);
    return UINavigationItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCoder:
  UINavigationItem? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0 ? null : UINavigationItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// Title when topmost on the stack. default is nil
  objc.NSString? get title {
    objc.checkOsVersionInternal('UINavigationItem.title', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Title when topmost on the stack. default is nil
  set title(objc.NSString? value) {
    objc.checkOsVersionInternal('UINavigationItem.setTitle:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTitle_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Custom view to use in lieu of a title. May be sized horizontally. Only used when item is topmost on the stack.
  UIView? get titleView {
    objc.checkOsVersionInternal('UINavigationItem.titleView', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_titleView);
    return _ret.address == 0 ? null : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// Custom view to use in lieu of a title. May be sized horizontally. Only used when item is topmost on the stack.
  set titleView(UIView? value) {
    objc.checkOsVersionInternal('UINavigationItem.setTitleView:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTitleView_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Explanatory text to display above the navigation bar buttons.
  objc.NSString? get prompt {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_prompt);
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Explanatory text to display above the navigation bar buttons.
  set prompt(objc.NSString? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setPrompt_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Bar button item to use for the back button when this item is the navigation bar's backItem.
  UIBarButtonItem? get backBarButtonItem {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_backBarButtonItem);
    return _ret.address == 0 ? null : UIBarButtonItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// Bar button item to use for the back button when this item is the navigation bar's backItem.
  set backBarButtonItem(UIBarButtonItem? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setBackBarButtonItem_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Title to use when this item is the navigation bar's backItem. Default is nil. backBarButtonItem takes precedence if both are specified.
  objc.NSString? get backButtonTitle {
    objc.checkOsVersionInternal('UINavigationItem.backButtonTitle', iOS: (false, (11, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_backButtonTitle);
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Title to use when this item is the navigation bar's backItem. Default is nil. backBarButtonItem takes precedence if both are specified.
  set backButtonTitle(objc.NSString? value) {
    objc.checkOsVersionInternal('UINavigationItem.setBackButtonTitle:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setBackButtonTitle_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// If YES, this navigation item will hide the back button when it's on top of the stack.
  bool get hidesBackButton {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_hidesBackButton);
  }

  /// If YES, this navigation item will hide the back button when it's on top of the stack.
  set hidesBackButton(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHidesBackButton_, value);
  }

  /// setHidesBackButton:animated:
  void setHidesBackButton(bool hidesBackButton$1, {required bool animated}) {
    _objc_msgSend_14iqu8t(this.ref.pointer, _sel_setHidesBackButton_animated_, hidesBackButton$1, animated);
  }

  /// Controls how the back button sources its title.
  UINavigationItemBackButtonDisplayMode get backButtonDisplayMode {
    objc.checkOsVersionInternal('UINavigationItem.backButtonDisplayMode', iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_10bx5wy(this.ref.pointer, _sel_backButtonDisplayMode);
    return UINavigationItemBackButtonDisplayMode.fromValue(_ret);
  }

  /// Controls how the back button sources its title.
  set backButtonDisplayMode(UINavigationItemBackButtonDisplayMode value) {
    objc.checkOsVersionInternal('UINavigationItem.setBackButtonDisplayMode:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_1dph54c(this.ref.pointer, _sel_setBackButtonDisplayMode_, value.value);
  }

  /// leftBarButtonItems
  objc.NSArray? get leftBarButtonItems {
    objc.checkOsVersionInternal('UINavigationItem.leftBarButtonItems', iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_leftBarButtonItems);
    return _ret.address == 0 ? null : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// setLeftBarButtonItems:
  set leftBarButtonItems(objc.NSArray? value) {
    objc.checkOsVersionInternal('UINavigationItem.setLeftBarButtonItems:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setLeftBarButtonItems_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// rightBarButtonItems
  objc.NSArray? get rightBarButtonItems {
    objc.checkOsVersionInternal('UINavigationItem.rightBarButtonItems', iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_rightBarButtonItems);
    return _ret.address == 0 ? null : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// setRightBarButtonItems:
  set rightBarButtonItems(objc.NSArray? value) {
    objc.checkOsVersionInternal('UINavigationItem.setRightBarButtonItems:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setRightBarButtonItems_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setLeftBarButtonItems:animated:
  void setLeftBarButtonItems(objc.NSArray? items, {required bool animated}) {
    objc.checkOsVersionInternal('UINavigationItem.setLeftBarButtonItems:animated:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_6p7ndb(
      this.ref.pointer,
      _sel_setLeftBarButtonItems_animated_,
      items?.ref.pointer ?? ffi.nullptr,
      animated,
    );
  }

  /// setRightBarButtonItems:animated:
  void setRightBarButtonItems(objc.NSArray? items, {required bool animated}) {
    objc.checkOsVersionInternal('UINavigationItem.setRightBarButtonItems:animated:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_6p7ndb(
      this.ref.pointer,
      _sel_setRightBarButtonItems_animated_,
      items?.ref.pointer ?? ffi.nullptr,
      animated,
    );
  }

  /// leftItemsSupplementBackButton
  bool get leftItemsSupplementBackButton {
    objc.checkOsVersionInternal('UINavigationItem.leftItemsSupplementBackButton', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_leftItemsSupplementBackButton);
  }

  /// setLeftItemsSupplementBackButton:
  set leftItemsSupplementBackButton(bool value) {
    objc.checkOsVersionInternal('UINavigationItem.setLeftItemsSupplementBackButton:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setLeftItemsSupplementBackButton_, value);
  }

  /// Some navigation items want to display a custom left or right item when they're on top of the stack. A custom left item replaces the regular back button unless you set leftItemsSupplementBackButton to YES
  UIBarButtonItem? get leftBarButtonItem {
    objc.checkOsVersionInternal('UINavigationItem.leftBarButtonItem', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_leftBarButtonItem);
    return _ret.address == 0 ? null : UIBarButtonItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// Some navigation items want to display a custom left or right item when they're on top of the stack. A custom left item replaces the regular back button unless you set leftItemsSupplementBackButton to YES
  set leftBarButtonItem(UIBarButtonItem? value) {
    objc.checkOsVersionInternal('UINavigationItem.setLeftBarButtonItem:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setLeftBarButtonItem_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// rightBarButtonItem
  UIBarButtonItem? get rightBarButtonItem {
    objc.checkOsVersionInternal('UINavigationItem.rightBarButtonItem', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_rightBarButtonItem);
    return _ret.address == 0 ? null : UIBarButtonItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// setRightBarButtonItem:
  set rightBarButtonItem(UIBarButtonItem? value) {
    objc.checkOsVersionInternal('UINavigationItem.setRightBarButtonItem:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setRightBarButtonItem_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setLeftBarButtonItem:animated:
  void setLeftBarButtonItem(UIBarButtonItem? item, {required bool animated}) {
    objc.checkOsVersionInternal('UINavigationItem.setLeftBarButtonItem:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_6p7ndb(
      this.ref.pointer,
      _sel_setLeftBarButtonItem_animated_,
      item?.ref.pointer ?? ffi.nullptr,
      animated,
    );
  }

  /// setRightBarButtonItem:animated:
  void setRightBarButtonItem(UIBarButtonItem? item, {required bool animated}) {
    objc.checkOsVersionInternal('UINavigationItem.setRightBarButtonItem:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_6p7ndb(
      this.ref.pointer,
      _sel_setRightBarButtonItem_animated_,
      item?.ref.pointer ?? ffi.nullptr,
      animated,
    );
  }

  /// When UINavigationBar.prefersLargeTitles=YES, this property controls when the larger out-of-line title is displayed. If prefersLargeTitles=NO, this property has no effect. The default value is Automatic.
  UINavigationItemLargeTitleDisplayMode get largeTitleDisplayMode {
    objc.checkOsVersionInternal('UINavigationItem.largeTitleDisplayMode', iOS: (false, (11, 0, 0)));
    final _ret = _objc_msgSend_1j6d9um(this.ref.pointer, _sel_largeTitleDisplayMode);
    return UINavigationItemLargeTitleDisplayMode.fromValue(_ret);
  }

  /// When UINavigationBar.prefersLargeTitles=YES, this property controls when the larger out-of-line title is displayed. If prefersLargeTitles=NO, this property has no effect. The default value is Automatic.
  set largeTitleDisplayMode(UINavigationItemLargeTitleDisplayMode value) {
    objc.checkOsVersionInternal('UINavigationItem.setLargeTitleDisplayMode:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_1ddnfsg(this.ref.pointer, _sel_setLargeTitleDisplayMode_, value.value);
  }

  /// A view controller that will be shown inside of a navigation controller can assign a UISearchController to this property to display the search controllers search bar in its containing navigation controllers navigation bar.
  UISearchController? get searchController {
    objc.checkOsVersionInternal('UINavigationItem.searchController', iOS: (false, (11, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_searchController);
    return _ret.address == 0 ? null : UISearchController.castFromPointer(_ret, retain: true, release: true);
  }

  /// A view controller that will be shown inside of a navigation controller can assign a UISearchController to this property to display the search controllers search bar in its containing navigation controllers navigation bar.
  set searchController(UISearchController? value) {
    objc.checkOsVersionInternal('UINavigationItem.setSearchController:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setSearchController_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// If this property is true (the default), the searchControllers search bar will hide as the user scrolls in the top view controllers scroll view. If false, the search bar will remain visible and pinned underneath the navigation bar.
  bool get hidesSearchBarWhenScrolling {
    objc.checkOsVersionInternal('UINavigationItem.hidesSearchBarWhenScrolling', iOS: (false, (11, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_hidesSearchBarWhenScrolling);
  }

  /// If this property is true (the default), the searchControllers search bar will hide as the user scrolls in the top view controllers scroll view. If false, the search bar will remain visible and pinned underneath the navigation bar.
  set hidesSearchBarWhenScrolling(bool value) {
    objc.checkOsVersionInternal('UINavigationItem.setHidesSearchBarWhenScrolling:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHidesSearchBarWhenScrolling_, value);
  }

  /// When set and this item is topmost, overrides the hosting navigation bar's standardAppearance. See UINavigationBar.standardAppearance for further details.
  UINavigationBarAppearance? get standardAppearance {
    objc.checkOsVersionInternal('UINavigationItem.standardAppearance', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_standardAppearance);
    return _ret.address == 0 ? null : UINavigationBarAppearance.castFromPointer(_ret, retain: true, release: true);
  }

  /// When set and this item is topmost, overrides the hosting navigation bar's standardAppearance. See UINavigationBar.standardAppearance for further details.
  set standardAppearance(UINavigationBarAppearance? value) {
    objc.checkOsVersionInternal('UINavigationItem.setStandardAppearance:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setStandardAppearance_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// When set and this item is topmost, overrides the hosting navigation bar's compactAppearance. See UINavigationBar.compactAppearance for further details.
  UINavigationBarAppearance? get compactAppearance {
    objc.checkOsVersionInternal('UINavigationItem.compactAppearance', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_compactAppearance);
    return _ret.address == 0 ? null : UINavigationBarAppearance.castFromPointer(_ret, retain: true, release: true);
  }

  /// When set and this item is topmost, overrides the hosting navigation bar's compactAppearance. See UINavigationBar.compactAppearance for further details.
  set compactAppearance(UINavigationBarAppearance? value) {
    objc.checkOsVersionInternal('UINavigationItem.setCompactAppearance:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setCompactAppearance_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// When set and this item is topmost, overrides the hosting navigation bar's scrollEdgeAppearance. See UINavigationBar.scrollEdgeAppearance for further details.
  UINavigationBarAppearance? get scrollEdgeAppearance {
    objc.checkOsVersionInternal('UINavigationItem.scrollEdgeAppearance', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_scrollEdgeAppearance);
    return _ret.address == 0 ? null : UINavigationBarAppearance.castFromPointer(_ret, retain: true, release: true);
  }

  /// When set and this item is topmost, overrides the hosting navigation bar's scrollEdgeAppearance. See UINavigationBar.scrollEdgeAppearance for further details.
  set scrollEdgeAppearance(UINavigationBarAppearance? value) {
    objc.checkOsVersionInternal('UINavigationItem.setScrollEdgeAppearance:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setScrollEdgeAppearance_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// When set and this item is topmost, overrides the hosting navigation bar's compactScrollEdgeAppearance. See UINavigationBar.h for further details.
  UINavigationBarAppearance? get compactScrollEdgeAppearance {
    objc.checkOsVersionInternal('UINavigationItem.compactScrollEdgeAppearance', iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_compactScrollEdgeAppearance);
    return _ret.address == 0 ? null : UINavigationBarAppearance.castFromPointer(_ret, retain: true, release: true);
  }

  /// When set and this item is topmost, overrides the hosting navigation bar's compactScrollEdgeAppearance. See UINavigationBar.h for further details.
  set compactScrollEdgeAppearance(UINavigationBarAppearance? value) {
    objc.checkOsVersionInternal('UINavigationItem.setCompactScrollEdgeAppearance:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setCompactScrollEdgeAppearance_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// init
  UINavigationItem init() {
    objc.checkOsVersionInternal('UINavigationItem.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UINavigationItem.castFromPointer(_ret, retain: false, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }
}

late final _sel_navigationItem = objc.registerName("navigationItem");
late final _sel_hidesBottomBarWhenPushed = objc.registerName("hidesBottomBarWhenPushed");
late final _sel_setHidesBottomBarWhenPushed_ = objc.registerName("setHidesBottomBarWhenPushed:");
late final _class_UINavigationController = objc.getClass("UINavigationController");
late final _sel_initWithNavigationBarClass_toolbarClass_ = objc.registerName(
  "initWithNavigationBarClass:toolbarClass:",
);
late final _sel_initWithRootViewController_ = objc.registerName("initWithRootViewController:");
late final _sel_initWithNibName_bundle_ = objc.registerName("initWithNibName:bundle:");
late final _sel_pushViewController_animated_ = objc.registerName("pushViewController:animated:");
late final _sel_popViewControllerAnimated_ = objc.registerName("popViewControllerAnimated:");
final _objc_msgSend_1t6aok9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Bool)
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, bool)
    >();
late final _sel_popToViewController_animated_ = objc.registerName("popToViewController:animated:");
final _objc_msgSend_17amj0z = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        bool,
      )
    >();
late final _sel_popToRootViewControllerAnimated_ = objc.registerName("popToRootViewControllerAnimated:");
late final _sel_topViewController = objc.registerName("topViewController");
late final _sel_visibleViewController = objc.registerName("visibleViewController");
late final _sel_viewControllers = objc.registerName("viewControllers");
late final _sel_setViewControllers_ = objc.registerName("setViewControllers:");
late final _sel_setViewControllers_animated_ = objc.registerName("setViewControllers:animated:");
late final _sel_isNavigationBarHidden = objc.registerName("isNavigationBarHidden");
late final _sel_setNavigationBarHidden_ = objc.registerName("setNavigationBarHidden:");
late final _sel_setNavigationBarHidden_animated_ = objc.registerName("setNavigationBarHidden:animated:");

/// WARNING: UINavigationBar is a stub. To generate bindings for this class, include
/// UINavigationBar in your config's objc-interfaces list.
///
/// UINavigationBar
class UINavigationBar extends objc.ObjCObjectBase {
  UINavigationBar._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UINavigationBar] that points to the same underlying object as [other].
  UINavigationBar.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UINavigationBar] that wraps the given raw object pointer.
  UINavigationBar.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_navigationBar = objc.registerName("navigationBar");
late final _sel_isToolbarHidden = objc.registerName("isToolbarHidden");
late final _sel_setToolbarHidden_ = objc.registerName("setToolbarHidden:");
late final _sel_setToolbarHidden_animated_ = objc.registerName("setToolbarHidden:animated:");

/// WARNING: UIToolbar is a stub. To generate bindings for this class, include
/// UIToolbar in your config's objc-interfaces list.
///
/// UIToolbar
class UIToolbar extends objc.ObjCObjectBase {
  UIToolbar._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIToolbar] that points to the same underlying object as [other].
  UIToolbar.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIToolbar] that wraps the given raw object pointer.
  UIToolbar.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_toolbar = objc.registerName("toolbar");

/// WARNING: UINavigationControllerDelegate is a stub. To generate bindings for this class, include
/// UINavigationControllerDelegate in your config's objc-protocols list.
///
/// UINavigationControllerDelegate
interface class UINavigationControllerDelegate extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UINavigationControllerDelegate._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UINavigationControllerDelegate] that points to the same underlying object as [other].
  UINavigationControllerDelegate.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UINavigationControllerDelegate] that wraps the given raw object pointer.
  UINavigationControllerDelegate.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_delegate = objc.registerName("delegate");
late final _sel_setDelegate_ = objc.registerName("setDelegate:");

/// WARNING: UIGestureRecognizer is a stub. To generate bindings for this class, include
/// UIGestureRecognizer in your config's objc-interfaces list.
///
/// UIGestureRecognizer
class UIGestureRecognizer extends objc.NSObject {
  UIGestureRecognizer._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [UIGestureRecognizer] that points to the same underlying object as [other].
  UIGestureRecognizer.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIGestureRecognizer] that wraps the given raw object pointer.
  UIGestureRecognizer.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_interactivePopGestureRecognizer = objc.registerName("interactivePopGestureRecognizer");
late final _sel_showViewController_sender_ = objc.registerName("showViewController:sender:");
late final _sel_hidesBarsWhenKeyboardAppears = objc.registerName("hidesBarsWhenKeyboardAppears");
late final _sel_setHidesBarsWhenKeyboardAppears_ = objc.registerName("setHidesBarsWhenKeyboardAppears:");
late final _sel_hidesBarsOnSwipe = objc.registerName("hidesBarsOnSwipe");
late final _sel_setHidesBarsOnSwipe_ = objc.registerName("setHidesBarsOnSwipe:");

/// WARNING: UIPanGestureRecognizer is a stub. To generate bindings for this class, include
/// UIPanGestureRecognizer in your config's objc-interfaces list.
///
/// UIPanGestureRecognizer
class UIPanGestureRecognizer extends UIGestureRecognizer {
  UIPanGestureRecognizer._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIPanGestureRecognizer', iOS: (false, (3, 2, 0)));
  }

  /// Constructs a [UIPanGestureRecognizer] that points to the same underlying object as [other].
  UIPanGestureRecognizer.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIPanGestureRecognizer] that wraps the given raw object pointer.
  UIPanGestureRecognizer.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_barHideOnSwipeGestureRecognizer = objc.registerName("barHideOnSwipeGestureRecognizer");
late final _sel_hidesBarsWhenVerticallyCompact = objc.registerName("hidesBarsWhenVerticallyCompact");
late final _sel_setHidesBarsWhenVerticallyCompact_ = objc.registerName("setHidesBarsWhenVerticallyCompact:");
late final _sel_hidesBarsOnTap = objc.registerName("hidesBarsOnTap");
late final _sel_setHidesBarsOnTap_ = objc.registerName("setHidesBarsOnTap:");

/// WARNING: UITapGestureRecognizer is a stub. To generate bindings for this class, include
/// UITapGestureRecognizer in your config's objc-interfaces list.
///
/// UITapGestureRecognizer
class UITapGestureRecognizer extends UIGestureRecognizer {
  UITapGestureRecognizer._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITapGestureRecognizer', iOS: (false, (3, 2, 0)));
  }

  /// Constructs a [UITapGestureRecognizer] that points to the same underlying object as [other].
  UITapGestureRecognizer.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITapGestureRecognizer] that wraps the given raw object pointer.
  UITapGestureRecognizer.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_barHideOnTapGestureRecognizer = objc.registerName("barHideOnTapGestureRecognizer");

/// UINavigationController
class UINavigationController extends UIViewController {
  UINavigationController._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UINavigationController', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UINavigationController] that points to the same underlying object as [other].
  UINavigationController.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UINavigationController] that wraps the given raw object pointer.
  UINavigationController.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UINavigationController].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UINavigationController);
  }

  static UINavigationController new$() {
    final _ret = _objc_msgSend_151sglz(_class_UINavigationController, _sel_new);
    return UINavigationController.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of UINavigationController constructed with the default `new` method.
  factory UINavigationController() => new$();
}

extension UINavigationController$Methods on UINavigationController {
  /// initWithNavigationBarClass:toolbarClass:
  UINavigationController initWithNavigationBarClass(
    objc.ObjCObjectBase? navigationBarClass, {
    objc.ObjCObjectBase? toolbarClass,
  }) {
    objc.checkOsVersionInternal(
      'UINavigationController.initWithNavigationBarClass:toolbarClass:',
      iOS: (false, (5, 0, 0)),
    );
    final _ret = _objc_msgSend_15qeuct(
      this.ref.retainAndReturnPointer(),
      _sel_initWithNavigationBarClass_toolbarClass_,
      navigationBarClass?.ref.pointer ?? ffi.nullptr,
      toolbarClass?.ref.pointer ?? ffi.nullptr,
    );
    return UINavigationController.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithRootViewController:
  UINavigationController initWithRootViewController(UIViewController rootViewController) {
    objc.checkOsVersionInternal('UINavigationController.initWithRootViewController:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
      this.ref.retainAndReturnPointer(),
      _sel_initWithRootViewController_,
      rootViewController.ref.pointer,
    );
    return UINavigationController.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithNibName:bundle:
  UINavigationController initWithNibName(objc.NSString? nibNameOrNil, {NSBundle? bundle}) {
    objc.checkOsVersionInternal('UINavigationController.initWithNibName:bundle:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_15qeuct(
      this.ref.retainAndReturnPointer(),
      _sel_initWithNibName_bundle_,
      nibNameOrNil?.ref.pointer ?? ffi.nullptr,
      bundle?.ref.pointer ?? ffi.nullptr,
    );
    return UINavigationController.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCoder:
  UINavigationController? initWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal('UINavigationController.initWithCoder:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0 ? null : UINavigationController.castFromPointer(_ret, retain: false, release: true);
  }

  /// pushViewController:animated:
  void pushViewController(UIViewController viewController, {required bool animated}) {
    objc.checkOsVersionInternal('UINavigationController.pushViewController:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_6p7ndb(this.ref.pointer, _sel_pushViewController_animated_, viewController.ref.pointer, animated);
  }

  /// popViewControllerAnimated:
  UIViewController? popViewControllerAnimated(bool animated) {
    objc.checkOsVersionInternal('UINavigationController.popViewControllerAnimated:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1t6aok9(this.ref.pointer, _sel_popViewControllerAnimated_, animated);
    return _ret.address == 0 ? null : UIViewController.castFromPointer(_ret, retain: true, release: true);
  }

  /// popToViewController:animated:
  objc.NSArray? popToViewController(UIViewController viewController, {required bool animated}) {
    objc.checkOsVersionInternal('UINavigationController.popToViewController:animated:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_17amj0z(
      this.ref.pointer,
      _sel_popToViewController_animated_,
      viewController.ref.pointer,
      animated,
    );
    return _ret.address == 0 ? null : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// popToRootViewControllerAnimated:
  objc.NSArray? popToRootViewControllerAnimated(bool animated) {
    objc.checkOsVersionInternal('UINavigationController.popToRootViewControllerAnimated:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1t6aok9(this.ref.pointer, _sel_popToRootViewControllerAnimated_, animated);
    return _ret.address == 0 ? null : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// topViewController
  UIViewController? get topViewController {
    objc.checkOsVersionInternal('UINavigationController.topViewController', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_topViewController);
    return _ret.address == 0 ? null : UIViewController.castFromPointer(_ret, retain: true, release: true);
  }

  /// visibleViewController
  UIViewController? get visibleViewController {
    objc.checkOsVersionInternal('UINavigationController.visibleViewController', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_visibleViewController);
    return _ret.address == 0 ? null : UIViewController.castFromPointer(_ret, retain: true, release: true);
  }

  /// viewControllers
  objc.NSArray get viewControllers {
    objc.checkOsVersionInternal('UINavigationController.viewControllers', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_viewControllers);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// setViewControllers:
  set viewControllers(objc.NSArray value) {
    objc.checkOsVersionInternal('UINavigationController.setViewControllers:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setViewControllers_, value.ref.pointer);
  }

  /// setViewControllers:animated:
  void setViewControllers(objc.NSArray viewControllers$1, {required bool animated}) {
    objc.checkOsVersionInternal('UINavigationController.setViewControllers:animated:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_6p7ndb(this.ref.pointer, _sel_setViewControllers_animated_, viewControllers$1.ref.pointer, animated);
  }

  /// isNavigationBarHidden
  bool get navigationBarHidden {
    objc.checkOsVersionInternal('UINavigationController.isNavigationBarHidden', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isNavigationBarHidden);
  }

  /// setNavigationBarHidden:
  set navigationBarHidden(bool value) {
    objc.checkOsVersionInternal('UINavigationController.setNavigationBarHidden:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setNavigationBarHidden_, value);
  }

  /// setNavigationBarHidden:animated:
  void setNavigationBarHidden(bool hidden, {required bool animated}) {
    objc.checkOsVersionInternal('UINavigationController.setNavigationBarHidden:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_14iqu8t(this.ref.pointer, _sel_setNavigationBarHidden_animated_, hidden, animated);
  }

  /// navigationBar
  UINavigationBar get navigationBar {
    objc.checkOsVersionInternal('UINavigationController.navigationBar', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_navigationBar);
    return UINavigationBar.castFromPointer(_ret, retain: true, release: true);
  }

  /// isToolbarHidden
  bool get toolbarHidden {
    objc.checkOsVersionInternal('UINavigationController.isToolbarHidden', iOS: (false, (3, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isToolbarHidden);
  }

  /// setToolbarHidden:
  set toolbarHidden(bool value) {
    objc.checkOsVersionInternal('UINavigationController.setToolbarHidden:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setToolbarHidden_, value);
  }

  /// setToolbarHidden:animated:
  void setToolbarHidden(bool hidden, {required bool animated}) {
    objc.checkOsVersionInternal('UINavigationController.setToolbarHidden:animated:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_14iqu8t(this.ref.pointer, _sel_setToolbarHidden_animated_, hidden, animated);
  }

  /// toolbar
  UIToolbar get toolbar {
    objc.checkOsVersionInternal('UINavigationController.toolbar', iOS: (false, (3, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_toolbar);
    return UIToolbar.castFromPointer(_ret, retain: true, release: true);
  }

  /// delegate
  UINavigationControllerDelegate? get delegate {
    objc.checkOsVersionInternal('UINavigationController.delegate', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_delegate);
    return _ret.address == 0 ? null : UINavigationControllerDelegate.castFromPointer(_ret, retain: true, release: true);
  }

  /// setDelegate:
  set delegate(UINavigationControllerDelegate? value) {
    objc.checkOsVersionInternal('UINavigationController.setDelegate:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setDelegate_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// interactivePopGestureRecognizer
  UIGestureRecognizer? get interactivePopGestureRecognizer {
    objc.checkOsVersionInternal('UINavigationController.interactivePopGestureRecognizer', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_interactivePopGestureRecognizer);
    return _ret.address == 0 ? null : UIGestureRecognizer.castFromPointer(_ret, retain: true, release: true);
  }

  /// showViewController:sender:
  void showViewController(UIViewController vc, {objc.ObjCObjectBase? sender}) {
    objc.checkOsVersionInternal('UINavigationController.showViewController:sender:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_showViewController_sender_,
      vc.ref.pointer,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// When the keyboard appears, the navigation controller's navigationBar toolbar will be hidden. The bars will remain hidden when the keyboard dismisses, but a tap in the content area will show them.
  bool get hidesBarsWhenKeyboardAppears {
    objc.checkOsVersionInternal('UINavigationController.hidesBarsWhenKeyboardAppears', iOS: (false, (8, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_hidesBarsWhenKeyboardAppears);
  }

  /// When the keyboard appears, the navigation controller's navigationBar toolbar will be hidden. The bars will remain hidden when the keyboard dismisses, but a tap in the content area will show them.
  set hidesBarsWhenKeyboardAppears(bool value) {
    objc.checkOsVersionInternal('UINavigationController.setHidesBarsWhenKeyboardAppears:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHidesBarsWhenKeyboardAppears_, value);
  }

  /// When the user swipes, the navigation controller's navigationBar & toolbar will be hidden (on a swipe up) or shown (on a swipe down). The toolbar only participates if it has items.
  bool get hidesBarsOnSwipe {
    objc.checkOsVersionInternal('UINavigationController.hidesBarsOnSwipe', iOS: (false, (8, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_hidesBarsOnSwipe);
  }

  /// When the user swipes, the navigation controller's navigationBar & toolbar will be hidden (on a swipe up) or shown (on a swipe down). The toolbar only participates if it has items.
  set hidesBarsOnSwipe(bool value) {
    objc.checkOsVersionInternal('UINavigationController.setHidesBarsOnSwipe:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHidesBarsOnSwipe_, value);
  }

  /// The gesture recognizer that triggers if the bars will hide or show due to a swipe. Do not change the delegate or attempt to replace this gesture by overriding this method.
  UIPanGestureRecognizer get barHideOnSwipeGestureRecognizer {
    objc.checkOsVersionInternal('UINavigationController.barHideOnSwipeGestureRecognizer', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_barHideOnSwipeGestureRecognizer);
    return UIPanGestureRecognizer.castFromPointer(_ret, retain: true, release: true);
  }

  /// When the UINavigationController's vertical size class is compact, hide the UINavigationBar and UIToolbar. Unhandled taps in the regions that would normally be occupied by these bars will reveal the bars.
  bool get hidesBarsWhenVerticallyCompact {
    objc.checkOsVersionInternal('UINavigationController.hidesBarsWhenVerticallyCompact', iOS: (false, (8, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_hidesBarsWhenVerticallyCompact);
  }

  /// When the UINavigationController's vertical size class is compact, hide the UINavigationBar and UIToolbar. Unhandled taps in the regions that would normally be occupied by these bars will reveal the bars.
  set hidesBarsWhenVerticallyCompact(bool value) {
    objc.checkOsVersionInternal('UINavigationController.setHidesBarsWhenVerticallyCompact:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHidesBarsWhenVerticallyCompact_, value);
  }

  /// When the user taps, the navigation controller's navigationBar & toolbar will be hidden or shown, depending on the hidden state of the navigationBar. The toolbar will only be shown if it has items to display.
  bool get hidesBarsOnTap {
    objc.checkOsVersionInternal('UINavigationController.hidesBarsOnTap', iOS: (false, (8, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_hidesBarsOnTap);
  }

  /// When the user taps, the navigation controller's navigationBar & toolbar will be hidden or shown, depending on the hidden state of the navigationBar. The toolbar will only be shown if it has items to display.
  set hidesBarsOnTap(bool value) {
    objc.checkOsVersionInternal('UINavigationController.setHidesBarsOnTap:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHidesBarsOnTap_, value);
  }

  /// The gesture recognizer used to recognize if the bars will hide or show due to a tap in content. Do not change the delegate or attempt to replace this gesture by overriding this method.
  UITapGestureRecognizer get barHideOnTapGestureRecognizer {
    objc.checkOsVersionInternal('UINavigationController.barHideOnTapGestureRecognizer', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_barHideOnTapGestureRecognizer);
    return UITapGestureRecognizer.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_navigationController = objc.registerName("navigationController");

/// UINavigationControllerItem
extension UINavigationControllerItem on UIViewController {
  /// navigationItem
  UINavigationItem get navigationItem {
    objc.checkOsVersionInternal('UIViewController.navigationItem', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_navigationItem);
    return UINavigationItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// hidesBottomBarWhenPushed
  bool get hidesBottomBarWhenPushed {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_hidesBottomBarWhenPushed);
  }

  /// setHidesBottomBarWhenPushed:
  set hidesBottomBarWhenPushed(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHidesBottomBarWhenPushed_, value);
  }

  /// navigationController
  UINavigationController? get navigationController {
    objc.checkOsVersionInternal('UIViewController.navigationController', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_navigationController);
    return _ret.address == 0 ? null : UINavigationController.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_toolbarItems = objc.registerName("toolbarItems");
late final _sel_setToolbarItems_ = objc.registerName("setToolbarItems:");
late final _sel_setToolbarItems_animated_ = objc.registerName("setToolbarItems:animated:");

/// UINavigationControllerContextualToolbarItems
extension UINavigationControllerContextualToolbarItems on UIViewController {
  /// toolbarItems
  objc.NSArray? get toolbarItems {
    objc.checkOsVersionInternal('UIViewController.toolbarItems', iOS: (false, (3, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_toolbarItems);
    return _ret.address == 0 ? null : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// setToolbarItems:
  set toolbarItems(objc.NSArray? value) {
    objc.checkOsVersionInternal('UIViewController.setToolbarItems:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setToolbarItems_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setToolbarItems:animated:
  void setToolbarItems(objc.NSArray? toolbarItems$1, {required bool animated}) {
    objc.checkOsVersionInternal('UIViewController.setToolbarItems:animated:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_6p7ndb(
      this.ref.pointer,
      _sel_setToolbarItems_animated_,
      toolbarItems$1?.ref.pointer ?? ffi.nullptr,
      animated,
    );
  }
}

late final _sel_view = objc.registerName("view");
late final _sel_setView_ = objc.registerName("setView:");
late final _sel_loadView = objc.registerName("loadView");
late final _sel_loadViewIfNeeded = objc.registerName("loadViewIfNeeded");
late final _sel_viewIfLoaded = objc.registerName("viewIfLoaded");
late final _sel_viewWillUnload = objc.registerName("viewWillUnload");
late final _sel_viewDidUnload = objc.registerName("viewDidUnload");
late final _sel_viewDidLoad = objc.registerName("viewDidLoad");
late final _sel_isViewLoaded = objc.registerName("isViewLoaded");
late final _sel_nibName = objc.registerName("nibName");
late final _sel_nibBundle = objc.registerName("nibBundle");

/// WARNING: UIStoryboard is a stub. To generate bindings for this class, include
/// UIStoryboard in your config's objc-interfaces list.
///
/// UIStoryboard
class UIStoryboard extends objc.ObjCObjectBase {
  UIStoryboard._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIStoryboard] that points to the same underlying object as [other].
  UIStoryboard.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIStoryboard] that wraps the given raw object pointer.
  UIStoryboard.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_storyboard = objc.registerName("storyboard");
late final _sel_performSegueWithIdentifier_sender_ = objc.registerName("performSegueWithIdentifier:sender:");
late final _sel_shouldPerformSegueWithIdentifier_sender_ = objc.registerName(
  "shouldPerformSegueWithIdentifier:sender:",
);
final _objc_msgSend_1lsax7n = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();

/// WARNING: UIStoryboardSegue is a stub. To generate bindings for this class, include
/// UIStoryboardSegue in your config's objc-interfaces list.
///
/// UIStoryboardSegue
class UIStoryboardSegue extends objc.ObjCObjectBase {
  UIStoryboardSegue._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIStoryboardSegue] that points to the same underlying object as [other].
  UIStoryboardSegue.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIStoryboardSegue] that wraps the given raw object pointer.
  UIStoryboardSegue.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_prepareForSegue_sender_ = objc.registerName("prepareForSegue:sender:");
late final _sel_canPerformUnwindSegueAction_fromViewController_sender_ = objc.registerName(
  "canPerformUnwindSegueAction:fromViewController:sender:",
);
final _objc_msgSend_iv7uhk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_canPerformUnwindSegueAction_fromViewController_withSender_ = objc.registerName(
  "canPerformUnwindSegueAction:fromViewController:withSender:",
);

/// WARNING: UIStoryboardUnwindSegueSource is a stub. To generate bindings for this class, include
/// UIStoryboardUnwindSegueSource in your config's objc-interfaces list.
///
/// UIStoryboardUnwindSegueSource
class UIStoryboardUnwindSegueSource extends objc.ObjCObjectBase {
  UIStoryboardUnwindSegueSource._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIStoryboardUnwindSegueSource] that points to the same underlying object as [other].
  UIStoryboardUnwindSegueSource.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIStoryboardUnwindSegueSource] that wraps the given raw object pointer.
  UIStoryboardUnwindSegueSource.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_allowedChildViewControllersForUnwindingFromSource_ = objc.registerName(
  "allowedChildViewControllersForUnwindingFromSource:",
);
late final _sel_childViewControllerContainingSegueSource_ = objc.registerName(
  "childViewControllerContainingSegueSource:",
);
late final _sel_viewControllerForUnwindSegueAction_fromViewController_withSender_ = objc.registerName(
  "viewControllerForUnwindSegueAction:fromViewController:withSender:",
);
final _objc_msgSend_cfx8ce = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_unwindForSegue_towardsViewController_ = objc.registerName("unwindForSegue:towardsViewController:");
late final _sel_segueForUnwindingToViewController_fromViewController_identifier_ = objc.registerName(
  "segueForUnwindingToViewController:fromViewController:identifier:",
);
late final _sel_viewWillAppear_ = objc.registerName("viewWillAppear:");
late final _sel_viewDidAppear_ = objc.registerName("viewDidAppear:");
late final _sel_viewWillDisappear_ = objc.registerName("viewWillDisappear:");
late final _sel_viewDidDisappear_ = objc.registerName("viewDidDisappear:");
late final _sel_viewWillLayoutSubviews = objc.registerName("viewWillLayoutSubviews");
late final _sel_viewDidLayoutSubviews = objc.registerName("viewDidLayoutSubviews");
late final _sel_didReceiveMemoryWarning = objc.registerName("didReceiveMemoryWarning");
late final _sel_parentViewController = objc.registerName("parentViewController");
late final _sel_modalViewController = objc.registerName("modalViewController");
late final _sel_presentedViewController = objc.registerName("presentedViewController");
late final _sel_presentingViewController = objc.registerName("presentingViewController");
late final _sel_definesPresentationContext = objc.registerName("definesPresentationContext");
late final _sel_setDefinesPresentationContext_ = objc.registerName("setDefinesPresentationContext:");
late final _sel_providesPresentationContextTransitionStyle = objc.registerName(
  "providesPresentationContextTransitionStyle",
);
late final _sel_setProvidesPresentationContextTransitionStyle_ = objc.registerName(
  "setProvidesPresentationContextTransitionStyle:",
);
late final _sel_restoresFocusAfterTransition = objc.registerName("restoresFocusAfterTransition");
late final _sel_setRestoresFocusAfterTransition_ = objc.registerName("setRestoresFocusAfterTransition:");
late final _sel_focusGroupIdentifier = objc.registerName("focusGroupIdentifier");
late final _sel_setFocusGroupIdentifier_ = objc.registerName("setFocusGroupIdentifier:");
late final _sel_isBeingPresented = objc.registerName("isBeingPresented");
late final _sel_isBeingDismissed = objc.registerName("isBeingDismissed");
late final _sel_isMovingToParentViewController = objc.registerName("isMovingToParentViewController");
late final _sel_isMovingFromParentViewController = objc.registerName("isMovingFromParentViewController");
late final _sel_presentViewController_animated_completion_ = objc.registerName(
  "presentViewController:animated:completion:",
);
final _objc_msgSend_na2nx0 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Bool,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        bool,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_dismissViewControllerAnimated_completion_ = objc.registerName(
  "dismissViewControllerAnimated:completion:",
);
final _objc_msgSend_1ocak7a = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, bool, ffi.Pointer<objc.ObjCBlockImpl>)
    >();
late final _sel_presentModalViewController_animated_ = objc.registerName("presentModalViewController:animated:");
late final _sel_dismissModalViewControllerAnimated_ = objc.registerName("dismissModalViewControllerAnimated:");

enum UIModalTransitionStyle {
  UIModalTransitionStyleCoverVertical(0),
  UIModalTransitionStyleFlipHorizontal(1),
  UIModalTransitionStyleCrossDissolve(2),
  UIModalTransitionStylePartialCurl(3);

  final int value;
  const UIModalTransitionStyle(this.value);

  static UIModalTransitionStyle fromValue(int value) => switch (value) {
    0 => UIModalTransitionStyleCoverVertical,
    1 => UIModalTransitionStyleFlipHorizontal,
    2 => UIModalTransitionStyleCrossDissolve,
    3 => UIModalTransitionStylePartialCurl,
    _ => throw ArgumentError('Unknown value for UIModalTransitionStyle: $value'),
  };
}

late final _sel_modalTransitionStyle = objc.registerName("modalTransitionStyle");
final _objc_msgSend_17t73u4 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setModalTransitionStyle_ = objc.registerName("setModalTransitionStyle:");
final _objc_msgSend_gt147a = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();

enum UIModalPresentationStyle {
  UIModalPresentationFullScreen(0),
  UIModalPresentationPageSheet(1),
  UIModalPresentationFormSheet(2),
  UIModalPresentationCurrentContext(3),
  UIModalPresentationCustom(4),
  UIModalPresentationOverFullScreen(5),
  UIModalPresentationOverCurrentContext(6),
  UIModalPresentationPopover(7),
  UIModalPresentationBlurOverFullScreen(8),
  UIModalPresentationNone(-1),
  UIModalPresentationAutomatic(-2);

  final int value;
  const UIModalPresentationStyle(this.value);

  static UIModalPresentationStyle fromValue(int value) => switch (value) {
    0 => UIModalPresentationFullScreen,
    1 => UIModalPresentationPageSheet,
    2 => UIModalPresentationFormSheet,
    3 => UIModalPresentationCurrentContext,
    4 => UIModalPresentationCustom,
    5 => UIModalPresentationOverFullScreen,
    6 => UIModalPresentationOverCurrentContext,
    7 => UIModalPresentationPopover,
    8 => UIModalPresentationBlurOverFullScreen,
    -1 => UIModalPresentationNone,
    -2 => UIModalPresentationAutomatic,
    _ => throw ArgumentError('Unknown value for UIModalPresentationStyle: $value'),
  };
}

late final _sel_modalPresentationStyle = objc.registerName("modalPresentationStyle");
final _objc_msgSend_1jdzuw5 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setModalPresentationStyle_ = objc.registerName("setModalPresentationStyle:");
final _objc_msgSend_19sk1nl = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_modalPresentationCapturesStatusBarAppearance = objc.registerName(
  "modalPresentationCapturesStatusBarAppearance",
);
late final _sel_setModalPresentationCapturesStatusBarAppearance_ = objc.registerName(
  "setModalPresentationCapturesStatusBarAppearance:",
);
late final _sel_disablesAutomaticKeyboardDismissal = objc.registerName("disablesAutomaticKeyboardDismissal");
late final _sel_wantsFullScreenLayout = objc.registerName("wantsFullScreenLayout");
late final _sel_setWantsFullScreenLayout_ = objc.registerName("setWantsFullScreenLayout:");
late final _sel_edgesForExtendedLayout = objc.registerName("edgesForExtendedLayout");
late final _sel_setEdgesForExtendedLayout_ = objc.registerName("setEdgesForExtendedLayout:");
final _objc_msgSend_1xy78x6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_extendedLayoutIncludesOpaqueBars = objc.registerName("extendedLayoutIncludesOpaqueBars");
late final _sel_setExtendedLayoutIncludesOpaqueBars_ = objc.registerName("setExtendedLayoutIncludesOpaqueBars:");
late final _sel_automaticallyAdjustsScrollViewInsets = objc.registerName("automaticallyAdjustsScrollViewInsets");
late final _sel_setAutomaticallyAdjustsScrollViewInsets_ = objc.registerName(
  "setAutomaticallyAdjustsScrollViewInsets:",
);
late final _class_UIScrollView = objc.getClass("UIScrollView");

/// WARNING: UIFocusItemScrollableContainer is a stub. To generate bindings for this class, include
/// UIFocusItemScrollableContainer in your config's objc-protocols list.
///
/// Objects conforming to UIFocusItemScrollableContainer are updated accordingly to ensure the
/// focused item remains visible on the screen.
interface class UIFocusItemScrollableContainer extends objc.ObjCProtocolBase implements UIFocusItemContainer {
  UIFocusItemScrollableContainer._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIFocusItemScrollableContainer] that points to the same underlying object as [other].
  UIFocusItemScrollableContainer.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusItemScrollableContainer] that wraps the given raw object pointer.
  UIFocusItemScrollableContainer.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_contentOffset = objc.registerName("contentOffset");
objc.CGPoint _ObjCBlock_NSPoint_ffiVoid_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => block.ref.target
    .cast<ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<ffi.Void> arg0)>>()
    .asFunction<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSPoint_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
      _ObjCBlock_NSPoint_ffiVoid_fnPtrTrampoline,
    ).cast();
objc.CGPoint _ObjCBlock_NSPoint_ffiVoid_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => (objc.getBlockClosure(block) as objc.CGPoint Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSPoint_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
      _ObjCBlock_NSPoint_ffiVoid_closureTrampoline,
    ).cast();

/// Construction methods for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSPoint_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_ObjCBlock_NSPoint_ffiVoid_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)> fromFunction(
    objc.CGPoint Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _ObjCBlock_NSPoint_ffiVoid_closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSPoint_ffiVoid_CallExtension on objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)> {
  objc.CGPoint call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>
      >()
      .asFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_setContentOffset_ = objc.registerName("setContentOffset:");
void _ObjCBlock_ffiVoid_ffiVoid_NSPoint_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGPoint arg1,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1)>>()
    .asFunction<void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSPoint_fnPtrCallable =
    ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, objc.CGPoint)>(
      _ObjCBlock_ffiVoid_ffiVoid_NSPoint_fnPtrTrampoline,
    ).cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSPoint_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGPoint arg1,
) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, objc.CGPoint))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSPoint_closureCallable =
    ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, objc.CGPoint)>(
      _ObjCBlock_ffiVoid_ffiVoid_NSPoint_closureTrampoline,
    ).cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSPoint_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGPoint arg1,
) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, objc.CGPoint))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, objc.CGPoint)>
_ObjCBlock_ffiVoid_ffiVoid_NSPoint_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, objc.CGPoint)
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_NSPoint_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_NSPoint_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGPoint arg1,
) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, objc.CGPoint))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, objc.CGPoint)
>
_ObjCBlock_ffiVoid_ffiVoid_NSPoint_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, objc.CGPoint)
      >.isolateLocal(_ObjCBlock_ffiVoid_ffiVoid_NSPoint_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, objc.CGPoint)
>
_ObjCBlock_ffiVoid_ffiVoid_NSPoint_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, objc.CGPoint)
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_NSPoint_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSPoint {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(
    objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSPoint_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.CGPoint) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(
    objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_NSPoint_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)> listener(
    void Function(ffi.Pointer<ffi.Void>, objc.CGPoint) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_NSPoint_listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_1bktu2(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)> blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.CGPoint) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_NSPoint_blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_NSPoint_blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_1bktu2(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(
      wrapper,
      retain: false,
      release: true,
    );
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSPoint_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1)
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, objc.CGPoint)>()(
        ref.pointer,
        arg0,
        arg1,
      );
}

late final _sel_contentSize = objc.registerName("contentSize");
final _objc_msgSend_1vdfken = objc.msgSendPointer
    .cast<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1vdfkenStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.CGSize>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.CGSize>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
objc.CGSize _ObjCBlock_CGSize_ffiVoid_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => block.ref.target
    .cast<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<ffi.Void> arg0)>>()
    .asFunction<objc.CGSize Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CGSize_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
      _ObjCBlock_CGSize_ffiVoid_fnPtrTrampoline,
    ).cast();
objc.CGSize _ObjCBlock_CGSize_ffiVoid_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => (objc.getBlockClosure(block) as objc.CGSize Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CGSize_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
      _ObjCBlock_CGSize_ffiVoid_closureTrampoline,
    ).cast();

/// Construction methods for `objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_CGSize_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_ObjCBlock_CGSize_ffiVoid_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)> fromFunction(
    objc.CGSize Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _ObjCBlock_CGSize_ffiVoid_closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_CGSize_ffiVoid_CallExtension on objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)> {
  objc.CGSize call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>
      >()
      .asFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_setContentSize_ = objc.registerName("setContentSize:");
final _objc_msgSend_13lgpwz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGSize)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGSize)>();
late final _sel_contentInset = objc.registerName("contentInset");
late final _sel_setContentInset_ = objc.registerName("setContentInset:");
late final _sel_adjustedContentInset = objc.registerName("adjustedContentInset");
late final _sel_adjustedContentInsetDidChange = objc.registerName("adjustedContentInsetDidChange");

enum UIScrollViewContentInsetAdjustmentBehavior {
  UIScrollViewContentInsetAdjustmentAutomatic(0),
  UIScrollViewContentInsetAdjustmentScrollableAxes(1),
  UIScrollViewContentInsetAdjustmentNever(2),
  UIScrollViewContentInsetAdjustmentAlways(3);

  final int value;
  const UIScrollViewContentInsetAdjustmentBehavior(this.value);

  static UIScrollViewContentInsetAdjustmentBehavior fromValue(int value) => switch (value) {
    0 => UIScrollViewContentInsetAdjustmentAutomatic,
    1 => UIScrollViewContentInsetAdjustmentScrollableAxes,
    2 => UIScrollViewContentInsetAdjustmentNever,
    3 => UIScrollViewContentInsetAdjustmentAlways,
    _ => throw ArgumentError('Unknown value for UIScrollViewContentInsetAdjustmentBehavior: $value'),
  };
}

late final _sel_contentInsetAdjustmentBehavior = objc.registerName("contentInsetAdjustmentBehavior");
final _objc_msgSend_1ubvjfk = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setContentInsetAdjustmentBehavior_ = objc.registerName("setContentInsetAdjustmentBehavior:");
final _objc_msgSend_1l2otbm = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_automaticallyAdjustsScrollIndicatorInsets = objc.registerName(
  "automaticallyAdjustsScrollIndicatorInsets",
);
late final _sel_setAutomaticallyAdjustsScrollIndicatorInsets_ = objc.registerName(
  "setAutomaticallyAdjustsScrollIndicatorInsets:",
);

/// WARNING: UILayoutGuide is a stub. To generate bindings for this class, include
/// UILayoutGuide in your config's objc-interfaces list.
///
/// UILayoutGuide
class UILayoutGuide extends objc.NSObject implements objc.NSCoding {
  UILayoutGuide._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UILayoutGuide', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UILayoutGuide] that points to the same underlying object as [other].
  UILayoutGuide.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UILayoutGuide] that wraps the given raw object pointer.
  UILayoutGuide.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_contentLayoutGuide = objc.registerName("contentLayoutGuide");
late final _sel_frameLayoutGuide = objc.registerName("frameLayoutGuide");

/// WARNING: UIScrollViewDelegate is a stub. To generate bindings for this class, include
/// UIScrollViewDelegate in your config's objc-protocols list.
///
/// UIScrollViewDelegate
interface class UIScrollViewDelegate extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIScrollViewDelegate._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIScrollViewDelegate] that points to the same underlying object as [other].
  UIScrollViewDelegate.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIScrollViewDelegate] that wraps the given raw object pointer.
  UIScrollViewDelegate.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_isDirectionalLockEnabled = objc.registerName("isDirectionalLockEnabled");
late final _sel_setDirectionalLockEnabled_ = objc.registerName("setDirectionalLockEnabled:");
late final _sel_bounces = objc.registerName("bounces");
late final _sel_setBounces_ = objc.registerName("setBounces:");
late final _sel_alwaysBounceVertical = objc.registerName("alwaysBounceVertical");
late final _sel_setAlwaysBounceVertical_ = objc.registerName("setAlwaysBounceVertical:");
late final _sel_alwaysBounceHorizontal = objc.registerName("alwaysBounceHorizontal");
late final _sel_setAlwaysBounceHorizontal_ = objc.registerName("setAlwaysBounceHorizontal:");
late final _sel_isPagingEnabled = objc.registerName("isPagingEnabled");
late final _sel_setPagingEnabled_ = objc.registerName("setPagingEnabled:");
late final _sel_isScrollEnabled = objc.registerName("isScrollEnabled");
late final _sel_setScrollEnabled_ = objc.registerName("setScrollEnabled:");
late final _sel_showsVerticalScrollIndicator = objc.registerName("showsVerticalScrollIndicator");
late final _sel_setShowsVerticalScrollIndicator_ = objc.registerName("setShowsVerticalScrollIndicator:");
late final _sel_showsHorizontalScrollIndicator = objc.registerName("showsHorizontalScrollIndicator");
late final _sel_setShowsHorizontalScrollIndicator_ = objc.registerName("setShowsHorizontalScrollIndicator:");

enum UIScrollViewIndicatorStyle {
  UIScrollViewIndicatorStyleDefault(0),
  UIScrollViewIndicatorStyleBlack(1),
  UIScrollViewIndicatorStyleWhite(2);

  final int value;
  const UIScrollViewIndicatorStyle(this.value);

  static UIScrollViewIndicatorStyle fromValue(int value) => switch (value) {
    0 => UIScrollViewIndicatorStyleDefault,
    1 => UIScrollViewIndicatorStyleBlack,
    2 => UIScrollViewIndicatorStyleWhite,
    _ => throw ArgumentError('Unknown value for UIScrollViewIndicatorStyle: $value'),
  };
}

late final _sel_indicatorStyle = objc.registerName("indicatorStyle");
final _objc_msgSend_10fw709 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setIndicatorStyle_ = objc.registerName("setIndicatorStyle:");
final _objc_msgSend_10eov2d = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_verticalScrollIndicatorInsets = objc.registerName("verticalScrollIndicatorInsets");
late final _sel_setVerticalScrollIndicatorInsets_ = objc.registerName("setVerticalScrollIndicatorInsets:");
late final _sel_horizontalScrollIndicatorInsets = objc.registerName("horizontalScrollIndicatorInsets");
late final _sel_setHorizontalScrollIndicatorInsets_ = objc.registerName("setHorizontalScrollIndicatorInsets:");
late final _sel_scrollIndicatorInsets = objc.registerName("scrollIndicatorInsets");
late final _sel_setScrollIndicatorInsets_ = objc.registerName("setScrollIndicatorInsets:");
late final _sel_decelerationRate = objc.registerName("decelerationRate");
late final _sel_setDecelerationRate_ = objc.registerName("setDecelerationRate:");

enum UIScrollViewIndexDisplayMode {
  UIScrollViewIndexDisplayModeAutomatic(0),
  UIScrollViewIndexDisplayModeAlwaysHidden(1);

  final int value;
  const UIScrollViewIndexDisplayMode(this.value);

  static UIScrollViewIndexDisplayMode fromValue(int value) => switch (value) {
    0 => UIScrollViewIndexDisplayModeAutomatic,
    1 => UIScrollViewIndexDisplayModeAlwaysHidden,
    _ => throw ArgumentError('Unknown value for UIScrollViewIndexDisplayMode: $value'),
  };
}

late final _sel_indexDisplayMode = objc.registerName("indexDisplayMode");
final _objc_msgSend_1vmqitm = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setIndexDisplayMode_ = objc.registerName("setIndexDisplayMode:");
final _objc_msgSend_r5kwx4 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setContentOffset_animated_ = objc.registerName("setContentOffset:animated:");
final _objc_msgSend_uyhzs2 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGPoint, ffi.Bool)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGPoint, bool)>();
late final _sel_scrollRectToVisible_animated_ = objc.registerName("scrollRectToVisible:animated:");
final _objc_msgSend_1sfhlx6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect, ffi.Bool)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect, bool)>();
late final _sel_flashScrollIndicators = objc.registerName("flashScrollIndicators");
late final _sel_isTracking = objc.registerName("isTracking");
late final _sel_isDragging = objc.registerName("isDragging");
late final _sel_isDecelerating = objc.registerName("isDecelerating");
late final _sel_delaysContentTouches = objc.registerName("delaysContentTouches");
late final _sel_setDelaysContentTouches_ = objc.registerName("setDelaysContentTouches:");
late final _sel_canCancelContentTouches = objc.registerName("canCancelContentTouches");
late final _sel_setCanCancelContentTouches_ = objc.registerName("setCanCancelContentTouches:");
late final _sel_touchesShouldBegin_withEvent_inContentView_ = objc.registerName(
  "touchesShouldBegin:withEvent:inContentView:",
);
final _objc_msgSend_gtxojt = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_touchesShouldCancelInContentView_ = objc.registerName("touchesShouldCancelInContentView:");
late final _sel_minimumZoomScale = objc.registerName("minimumZoomScale");
late final _sel_setMinimumZoomScale_ = objc.registerName("setMinimumZoomScale:");
late final _sel_maximumZoomScale = objc.registerName("maximumZoomScale");
late final _sel_setMaximumZoomScale_ = objc.registerName("setMaximumZoomScale:");
late final _sel_zoomScale = objc.registerName("zoomScale");
late final _sel_setZoomScale_ = objc.registerName("setZoomScale:");
late final _sel_setZoomScale_animated_ = objc.registerName("setZoomScale:animated:");
final _objc_msgSend_ghxo7e = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Double, ffi.Bool)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, double, bool)>();
late final _sel_zoomToRect_animated_ = objc.registerName("zoomToRect:animated:");
late final _sel_bouncesZoom = objc.registerName("bouncesZoom");
late final _sel_setBouncesZoom_ = objc.registerName("setBouncesZoom:");
late final _sel_isZooming = objc.registerName("isZooming");
late final _sel_isZoomBouncing = objc.registerName("isZoomBouncing");
late final _sel_scrollsToTop = objc.registerName("scrollsToTop");
late final _sel_setScrollsToTop_ = objc.registerName("setScrollsToTop:");
late final _sel_panGestureRecognizer = objc.registerName("panGestureRecognizer");

/// WARNING: UIPinchGestureRecognizer is a stub. To generate bindings for this class, include
/// UIPinchGestureRecognizer in your config's objc-interfaces list.
///
/// UIPinchGestureRecognizer
class UIPinchGestureRecognizer extends objc.ObjCObjectBase {
  UIPinchGestureRecognizer._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIPinchGestureRecognizer] that points to the same underlying object as [other].
  UIPinchGestureRecognizer.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIPinchGestureRecognizer] that wraps the given raw object pointer.
  UIPinchGestureRecognizer.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_pinchGestureRecognizer = objc.registerName("pinchGestureRecognizer");
late final _sel_directionalPressGestureRecognizer = objc.registerName("directionalPressGestureRecognizer");

enum UIScrollViewKeyboardDismissMode {
  UIScrollViewKeyboardDismissModeNone(0),
  UIScrollViewKeyboardDismissModeOnDrag(1),
  UIScrollViewKeyboardDismissModeInteractive(2);

  final int value;
  const UIScrollViewKeyboardDismissMode(this.value);

  static UIScrollViewKeyboardDismissMode fromValue(int value) => switch (value) {
    0 => UIScrollViewKeyboardDismissModeNone,
    1 => UIScrollViewKeyboardDismissModeOnDrag,
    2 => UIScrollViewKeyboardDismissModeInteractive,
    _ => throw ArgumentError('Unknown value for UIScrollViewKeyboardDismissMode: $value'),
  };
}

late final _sel_keyboardDismissMode = objc.registerName("keyboardDismissMode");
final _objc_msgSend_1v83s9d = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setKeyboardDismissMode_ = objc.registerName("setKeyboardDismissMode:");
final _objc_msgSend_1c75p8t = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();

/// WARNING: UIRefreshControl is a stub. To generate bindings for this class, include
/// UIRefreshControl in your config's objc-interfaces list.
///
/// UIRefreshControl
class UIRefreshControl extends UIControl {
  UIRefreshControl._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIRefreshControl', iOS: (false, (6, 0, 0)));
  }

  /// Constructs a [UIRefreshControl] that points to the same underlying object as [other].
  UIRefreshControl.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIRefreshControl] that wraps the given raw object pointer.
  UIRefreshControl.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_refreshControl = objc.registerName("refreshControl");
late final _sel_setRefreshControl_ = objc.registerName("setRefreshControl:");
late final _sel_layerClass = objc.registerName("layerClass");
late final _sel_initWithFrame_ = objc.registerName("initWithFrame:");
final _objc_msgSend_15yz4e6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect)
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect)
    >();

enum UIUserInterfaceLayoutDirection {
  UIUserInterfaceLayoutDirectionLeftToRight(0),
  UIUserInterfaceLayoutDirectionRightToLeft(1);

  final int value;
  const UIUserInterfaceLayoutDirection(this.value);

  static UIUserInterfaceLayoutDirection fromValue(int value) => switch (value) {
    0 => UIUserInterfaceLayoutDirectionLeftToRight,
    1 => UIUserInterfaceLayoutDirectionRightToLeft,
    _ => throw ArgumentError('Unknown value for UIUserInterfaceLayoutDirection: $value'),
  };
}

enum UISemanticContentAttribute {
  UISemanticContentAttributeUnspecified(0),
  UISemanticContentAttributePlayback(1),
  UISemanticContentAttributeSpatial(2),
  UISemanticContentAttributeForceLeftToRight(3),
  UISemanticContentAttributeForceRightToLeft(4);

  final int value;
  const UISemanticContentAttribute(this.value);

  static UISemanticContentAttribute fromValue(int value) => switch (value) {
    0 => UISemanticContentAttributeUnspecified,
    1 => UISemanticContentAttributePlayback,
    2 => UISemanticContentAttributeSpatial,
    3 => UISemanticContentAttributeForceLeftToRight,
    4 => UISemanticContentAttributeForceRightToLeft,
    _ => throw ArgumentError('Unknown value for UISemanticContentAttribute: $value'),
  };
}

late final _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_ = objc.registerName(
  "userInterfaceLayoutDirectionForSemanticContentAttribute:",
);
final _objc_msgSend_racczx = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_ = objc.registerName(
  "userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:",
);
final _objc_msgSend_tz4p54 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long, ffi.Long)
      >
    >()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int, int)>();
late final _sel_visibleSize = objc.registerName("visibleSize");
late final _sel_coordinateSpace = objc.registerName("coordinateSpace");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_idUICoordinateSpace_ffiVoid_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>>()
    .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_idUICoordinateSpace_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
        >(_ObjCBlock_idUICoordinateSpace_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_idUICoordinateSpace_ffiVoid_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_idUICoordinateSpace_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
        >(_ObjCBlock_idUICoordinateSpace_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUICoordinateSpace_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_ObjCBlock_idUICoordinateSpace_ffiVoid_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> fromFunction(
    UICoordinateSpace Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _ObjCBlock_idUICoordinateSpace_ffiVoid_closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUICoordinateSpace_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> {
  UICoordinateSpace call(ffi.Pointer<ffi.Void> arg0) => UICoordinateSpace.castFromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)
          >
        >()
        .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(
      ref.pointer,
      arg0,
    ),
    retain: true,
    release: true,
  );
}

late final _sel_focusItemsInRect_ = objc.registerName("focusItemsInRect:");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSArray_ffiVoid_CGRect_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGRect arg1,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1)>>()
    .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.CGRect)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_NSArray_ffiVoid_CGRect_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, objc.CGRect)
        >(_ObjCBlock_NSArray_ffiVoid_CGRect_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSArray_ffiVoid_CGRect_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGRect arg1,
) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.CGRect))(
  arg0,
  arg1,
);
ffi.Pointer<ffi.Void> _ObjCBlock_NSArray_ffiVoid_CGRect_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, objc.CGRect)
        >(_ObjCBlock_NSArray_ffiVoid_CGRect_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>`.
abstract final class ObjCBlock_NSArray_ffiVoid_CGRect {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1)>>
    ptr,
  ) => objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>(
    objc.newPointerBlock(_ObjCBlock_NSArray_ffiVoid_CGRect_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)> fromFunction(
    objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>(
    objc.newClosureBlock(
      _ObjCBlock_NSArray_ffiVoid_CGRect_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1) => fn(arg0, arg1).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>`.
extension ObjCBlock_NSArray_ffiVoid_CGRect_CallExtension
    on objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)> {
  objc.NSArray call(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1) => objc.NSArray.castFromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
              objc.CGRect arg1,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, objc.CGRect)
        >()(ref.pointer, arg0, arg1),
    retain: true,
    release: true,
  );
}

/// UIScrollView
class UIScrollView extends UIView implements objc.NSCoding, UIFocusItemScrollableContainer {
  UIScrollView._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [UIScrollView] that points to the same underlying object as [other].
  UIScrollView.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIScrollView] that wraps the given raw object pointer.
  UIScrollView.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIScrollView].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIScrollView);
  }

      static UIScrollView new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIScrollView, _sel_new);
    return UIScrollView.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of UIScrollView constructed with the default `new` method.
  factory UIScrollView() => new$();

  /// layerClass
  static objc.ObjCObjectBase getLayerClass() {
    objc.checkOsVersionInternal('UIScrollView.layerClass', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIScrollView, _sel_layerClass);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute(
    UISemanticContentAttribute attribute,
  ) {
    objc.checkOsVersionInternal(
      'UIScrollView.userInterfaceLayoutDirectionForSemanticContentAttribute:',
      iOS: (false, (9, 0, 0)),
    );
    final _ret = _objc_msgSend_racczx(
      _class_UIScrollView,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
      attribute.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute$1(
    UISemanticContentAttribute semanticContentAttribute, {
    required UIUserInterfaceLayoutDirection relativeToLayoutDirection,
  }) {
    objc.checkOsVersionInternal(
      'UIScrollView.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
      iOS: (false, (10, 0, 0)),
    );
    final _ret = _objc_msgSend_tz4p54(
      _class_UIScrollView,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
      semanticContentAttribute.value,
      relativeToLayoutDirection.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }
}

extension UIScrollView$Methods on UIScrollView {
  /// The current content offset of this scrollable container. If the scrollable container has a `bounds` property, `bounds.origin` must be equal to `contentOffset`.
  objc.CGPoint get contentOffset {
    objc.checkOsVersionInternal('UIScrollView.contentOffset', iOS: (false, (12, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret(_ptr, this.ref.pointer, _sel_contentOffset)
        : _ptr.ref = _objc_msgSend_1uwdhlk(this.ref.pointer, _sel_contentOffset);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// The current content offset of this scrollable container. If the scrollable container has a `bounds` property, `bounds.origin` must be equal to `contentOffset`.
  set contentOffset(objc.CGPoint value) {
    objc.checkOsVersionInternal('UIScrollView.setContentOffset:', iOS: (false, (12, 0, 0)));
    _objc_msgSend_iy8iz6(this.ref.pointer, _sel_setContentOffset_, value);
  }

  /// The total size of the content contained by this container. If this size exceeds the size of
  /// this container's visible size, then scrolling is possible.
  objc.CGSize get contentSize {
    objc.checkOsVersionInternal('UIScrollView.contentSize', iOS: (false, (12, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1vdfkenStret(_ptr, this.ref.pointer, _sel_contentSize)
        : _ptr.ref = _objc_msgSend_1vdfken(this.ref.pointer, _sel_contentSize);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// setContentSize:
  set contentSize$1(objc.CGSize value) {
    objc.checkOsVersionInternal('UIScrollView.setContentSize:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_13lgpwz(this.ref.pointer, _sel_setContentSize_, value);
  }

  /// contentInset
  UIEdgeInsets get contentInset {
    objc.checkOsVersionInternal('UIScrollView.contentInset', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(_ptr, this.ref.pointer, _sel_contentInset)
        : _ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_contentInset);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>(_finalizable);
  }

  /// setContentInset:
  set contentInset(UIEdgeInsets value) {
    objc.checkOsVersionInternal('UIScrollView.setContentInset:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1g8fos5(this.ref.pointer, _sel_setContentInset_, value);
  }

  /// adjustedContentInset
  UIEdgeInsets get adjustedContentInset {
    objc.checkOsVersionInternal('UIScrollView.adjustedContentInset', iOS: (false, (11, 0, 0)));
    final _ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(_ptr, this.ref.pointer, _sel_adjustedContentInset)
        : _ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_adjustedContentInset);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>(_finalizable);
  }

  /// adjustedContentInsetDidChange
  void adjustedContentInsetDidChange() {
    objc.checkOsVersionInternal('UIScrollView.adjustedContentInsetDidChange', iOS: (false, (11, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_adjustedContentInsetDidChange);
  }

  /// contentInsetAdjustmentBehavior
  UIScrollViewContentInsetAdjustmentBehavior get contentInsetAdjustmentBehavior {
    objc.checkOsVersionInternal('UIScrollView.contentInsetAdjustmentBehavior', iOS: (false, (11, 0, 0)));
    final _ret = _objc_msgSend_1ubvjfk(this.ref.pointer, _sel_contentInsetAdjustmentBehavior);
    return UIScrollViewContentInsetAdjustmentBehavior.fromValue(_ret);
  }

  /// setContentInsetAdjustmentBehavior:
  set contentInsetAdjustmentBehavior(UIScrollViewContentInsetAdjustmentBehavior value) {
    objc.checkOsVersionInternal('UIScrollView.setContentInsetAdjustmentBehavior:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_1l2otbm(this.ref.pointer, _sel_setContentInsetAdjustmentBehavior_, value.value);
  }

  /// automaticallyAdjustsScrollIndicatorInsets
  bool get automaticallyAdjustsScrollIndicatorInsets {
    objc.checkOsVersionInternal('UIScrollView.automaticallyAdjustsScrollIndicatorInsets', iOS: (false, (13, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_automaticallyAdjustsScrollIndicatorInsets);
  }

  /// setAutomaticallyAdjustsScrollIndicatorInsets:
  set automaticallyAdjustsScrollIndicatorInsets(bool value) {
    objc.checkOsVersionInternal('UIScrollView.setAutomaticallyAdjustsScrollIndicatorInsets:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setAutomaticallyAdjustsScrollIndicatorInsets_, value);
  }

  /// contentLayoutGuide
  UILayoutGuide get contentLayoutGuide {
    objc.checkOsVersionInternal('UIScrollView.contentLayoutGuide', iOS: (false, (11, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_contentLayoutGuide);
    return UILayoutGuide.castFromPointer(_ret, retain: true, release: true);
  }

  /// frameLayoutGuide
  UILayoutGuide get frameLayoutGuide {
    objc.checkOsVersionInternal('UIScrollView.frameLayoutGuide', iOS: (false, (11, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_frameLayoutGuide);
    return UILayoutGuide.castFromPointer(_ret, retain: true, release: true);
  }

  /// delegate
  UIScrollViewDelegate? get delegate {
    objc.checkOsVersionInternal('UIScrollView.delegate', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_delegate);
    return _ret.address == 0 ? null : UIScrollViewDelegate.castFromPointer(_ret, retain: true, release: true);
  }

  /// setDelegate:
  set delegate(UIScrollViewDelegate? value) {
    objc.checkOsVersionInternal('UIScrollView.setDelegate:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setDelegate_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// isDirectionalLockEnabled
  bool get directionalLockEnabled {
    objc.checkOsVersionInternal('UIScrollView.isDirectionalLockEnabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isDirectionalLockEnabled);
  }

  /// setDirectionalLockEnabled:
  set directionalLockEnabled(bool value) {
    objc.checkOsVersionInternal('UIScrollView.setDirectionalLockEnabled:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setDirectionalLockEnabled_, value);
  }

  /// bounces
  bool get bounces {
    objc.checkOsVersionInternal('UIScrollView.bounces', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_bounces);
  }

  /// setBounces:
  set bounces(bool value) {
    objc.checkOsVersionInternal('UIScrollView.setBounces:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setBounces_, value);
  }

  /// alwaysBounceVertical
  bool get alwaysBounceVertical {
    objc.checkOsVersionInternal('UIScrollView.alwaysBounceVertical', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_alwaysBounceVertical);
  }

  /// setAlwaysBounceVertical:
  set alwaysBounceVertical(bool value) {
    objc.checkOsVersionInternal('UIScrollView.setAlwaysBounceVertical:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setAlwaysBounceVertical_, value);
  }

  /// alwaysBounceHorizontal
  bool get alwaysBounceHorizontal {
    objc.checkOsVersionInternal('UIScrollView.alwaysBounceHorizontal', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_alwaysBounceHorizontal);
  }

  /// setAlwaysBounceHorizontal:
  set alwaysBounceHorizontal(bool value) {
    objc.checkOsVersionInternal('UIScrollView.setAlwaysBounceHorizontal:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setAlwaysBounceHorizontal_, value);
  }

  /// isPagingEnabled
  bool get pagingEnabled {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isPagingEnabled);
  }

  /// setPagingEnabled:
  set pagingEnabled(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setPagingEnabled_, value);
  }

  /// isScrollEnabled
  bool get scrollEnabled {
    objc.checkOsVersionInternal('UIScrollView.isScrollEnabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isScrollEnabled);
  }

  /// setScrollEnabled:
  set scrollEnabled(bool value) {
    objc.checkOsVersionInternal('UIScrollView.setScrollEnabled:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setScrollEnabled_, value);
  }

  /// showsVerticalScrollIndicator
  bool get showsVerticalScrollIndicator {
    objc.checkOsVersionInternal('UIScrollView.showsVerticalScrollIndicator', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_showsVerticalScrollIndicator);
  }

  /// setShowsVerticalScrollIndicator:
  set showsVerticalScrollIndicator(bool value) {
    objc.checkOsVersionInternal('UIScrollView.setShowsVerticalScrollIndicator:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setShowsVerticalScrollIndicator_, value);
  }

  /// showsHorizontalScrollIndicator
  bool get showsHorizontalScrollIndicator {
    objc.checkOsVersionInternal('UIScrollView.showsHorizontalScrollIndicator', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_showsHorizontalScrollIndicator);
  }

  /// setShowsHorizontalScrollIndicator:
  set showsHorizontalScrollIndicator(bool value) {
    objc.checkOsVersionInternal('UIScrollView.setShowsHorizontalScrollIndicator:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setShowsHorizontalScrollIndicator_, value);
  }

  /// indicatorStyle
  UIScrollViewIndicatorStyle get indicatorStyle {
    objc.checkOsVersionInternal('UIScrollView.indicatorStyle', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_10fw709(this.ref.pointer, _sel_indicatorStyle);
    return UIScrollViewIndicatorStyle.fromValue(_ret);
  }

  /// setIndicatorStyle:
  set indicatorStyle(UIScrollViewIndicatorStyle value) {
    objc.checkOsVersionInternal('UIScrollView.setIndicatorStyle:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_10eov2d(this.ref.pointer, _sel_setIndicatorStyle_, value.value);
  }

  /// verticalScrollIndicatorInsets
  UIEdgeInsets get verticalScrollIndicatorInsets {
    objc.checkOsVersionInternal('UIScrollView.verticalScrollIndicatorInsets', iOS: (false, (11, 1, 0)));
    final _ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(_ptr, this.ref.pointer, _sel_verticalScrollIndicatorInsets)
        : _ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_verticalScrollIndicatorInsets);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>(_finalizable);
  }

  /// setVerticalScrollIndicatorInsets:
  set verticalScrollIndicatorInsets(UIEdgeInsets value) {
    objc.checkOsVersionInternal('UIScrollView.setVerticalScrollIndicatorInsets:', iOS: (false, (11, 1, 0)));
    _objc_msgSend_1g8fos5(this.ref.pointer, _sel_setVerticalScrollIndicatorInsets_, value);
  }

  /// horizontalScrollIndicatorInsets
  UIEdgeInsets get horizontalScrollIndicatorInsets {
    objc.checkOsVersionInternal('UIScrollView.horizontalScrollIndicatorInsets', iOS: (false, (11, 1, 0)));
    final _ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(_ptr, this.ref.pointer, _sel_horizontalScrollIndicatorInsets)
        : _ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_horizontalScrollIndicatorInsets);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>(_finalizable);
  }

  /// setHorizontalScrollIndicatorInsets:
  set horizontalScrollIndicatorInsets(UIEdgeInsets value) {
    objc.checkOsVersionInternal('UIScrollView.setHorizontalScrollIndicatorInsets:', iOS: (false, (11, 1, 0)));
    _objc_msgSend_1g8fos5(this.ref.pointer, _sel_setHorizontalScrollIndicatorInsets_, value);
  }

  /// scrollIndicatorInsets
  UIEdgeInsets get scrollIndicatorInsets {
    objc.checkOsVersionInternal('UIScrollView.scrollIndicatorInsets', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(_ptr, this.ref.pointer, _sel_scrollIndicatorInsets)
        : _ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_scrollIndicatorInsets);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>(_finalizable);
  }

  /// setScrollIndicatorInsets:
  set scrollIndicatorInsets(UIEdgeInsets value) {
    objc.checkOsVersionInternal('UIScrollView.setScrollIndicatorInsets:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1g8fos5(this.ref.pointer, _sel_setScrollIndicatorInsets_, value);
  }

  /// decelerationRate
  double get decelerationRate {
    objc.checkOsVersionInternal('UIScrollView.decelerationRate', iOS: (false, (3, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_decelerationRate)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_decelerationRate);
  }

  /// setDecelerationRate:
  set decelerationRate(double value) {
    objc.checkOsVersionInternal('UIScrollView.setDecelerationRate:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setDecelerationRate_, value);
  }

  /// indexDisplayMode
  UIScrollViewIndexDisplayMode get indexDisplayMode {
    final _ret = _objc_msgSend_1vmqitm(this.ref.pointer, _sel_indexDisplayMode);
    return UIScrollViewIndexDisplayMode.fromValue(_ret);
  }

  /// setIndexDisplayMode:
  set indexDisplayMode(UIScrollViewIndexDisplayMode value) {
    _objc_msgSend_r5kwx4(this.ref.pointer, _sel_setIndexDisplayMode_, value.value);
  }

  /// setContentOffset:animated:
  void setContentOffset(objc.CGPoint contentOffset$1, {required bool animated}) {
    objc.checkOsVersionInternal('UIScrollView.setContentOffset:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_uyhzs2(this.ref.pointer, _sel_setContentOffset_animated_, contentOffset$1, animated);
  }

  /// scrollRectToVisible:animated:
  void scrollRectToVisible(objc.CGRect rect, {required bool animated}) {
    objc.checkOsVersionInternal('UIScrollView.scrollRectToVisible:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1sfhlx6(this.ref.pointer, _sel_scrollRectToVisible_animated_, rect, animated);
  }

  /// flashScrollIndicators
  void flashScrollIndicators() {
    objc.checkOsVersionInternal('UIScrollView.flashScrollIndicators', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_flashScrollIndicators);
  }

  /// isTracking
  bool get tracking {
    objc.checkOsVersionInternal('UIScrollView.isTracking', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isTracking);
  }

  /// isDragging
  bool get dragging {
    objc.checkOsVersionInternal('UIScrollView.isDragging', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isDragging);
  }

  /// isDecelerating
  bool get decelerating {
    objc.checkOsVersionInternal('UIScrollView.isDecelerating', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isDecelerating);
  }

  /// delaysContentTouches
  bool get delaysContentTouches {
    objc.checkOsVersionInternal('UIScrollView.delaysContentTouches', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_delaysContentTouches);
  }

  /// setDelaysContentTouches:
  set delaysContentTouches(bool value) {
    objc.checkOsVersionInternal('UIScrollView.setDelaysContentTouches:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setDelaysContentTouches_, value);
  }

  /// canCancelContentTouches
  bool get canCancelContentTouches {
    objc.checkOsVersionInternal('UIScrollView.canCancelContentTouches', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_canCancelContentTouches);
  }

  /// setCanCancelContentTouches:
  set canCancelContentTouches(bool value) {
    objc.checkOsVersionInternal('UIScrollView.setCanCancelContentTouches:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setCanCancelContentTouches_, value);
  }

  /// touchesShouldBegin:withEvent:inContentView:
  bool touchesShouldBegin(objc.NSSet touches, {UIEvent? withEvent, required UIView inContentView}) {
    objc.checkOsVersionInternal('UIScrollView.touchesShouldBegin:withEvent:inContentView:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_gtxojt(
      this.ref.pointer,
      _sel_touchesShouldBegin_withEvent_inContentView_,
      touches.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
      inContentView.ref.pointer,
    );
  }

  /// touchesShouldCancelInContentView:
  bool touchesShouldCancelInContentView(UIView view) {
    objc.checkOsVersionInternal('UIScrollView.touchesShouldCancelInContentView:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_19nvye5(this.ref.pointer, _sel_touchesShouldCancelInContentView_, view.ref.pointer);
  }

  /// minimumZoomScale
  double get minimumZoomScale {
    objc.checkOsVersionInternal('UIScrollView.minimumZoomScale', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_minimumZoomScale)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_minimumZoomScale);
  }

  /// setMinimumZoomScale:
  set minimumZoomScale(double value) {
    objc.checkOsVersionInternal('UIScrollView.setMinimumZoomScale:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setMinimumZoomScale_, value);
  }

  /// maximumZoomScale
  double get maximumZoomScale {
    objc.checkOsVersionInternal('UIScrollView.maximumZoomScale', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_maximumZoomScale)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_maximumZoomScale);
  }

  /// setMaximumZoomScale:
  set maximumZoomScale(double value) {
    objc.checkOsVersionInternal('UIScrollView.setMaximumZoomScale:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setMaximumZoomScale_, value);
  }

  /// zoomScale
  double get zoomScale {
    objc.checkOsVersionInternal('UIScrollView.zoomScale', iOS: (false, (3, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_zoomScale)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_zoomScale);
  }

  /// setZoomScale:
  set zoomScale(double value) {
    objc.checkOsVersionInternal('UIScrollView.setZoomScale:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setZoomScale_, value);
  }

  /// setZoomScale:animated:
  void setZoomScale(double scale, {required bool animated}) {
    objc.checkOsVersionInternal('UIScrollView.setZoomScale:animated:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_ghxo7e(this.ref.pointer, _sel_setZoomScale_animated_, scale, animated);
  }

  /// zoomToRect:animated:
  void zoomToRect(objc.CGRect rect, {required bool animated}) {
    objc.checkOsVersionInternal('UIScrollView.zoomToRect:animated:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_1sfhlx6(this.ref.pointer, _sel_zoomToRect_animated_, rect, animated);
  }

  /// bouncesZoom
  bool get bouncesZoom {
    objc.checkOsVersionInternal('UIScrollView.bouncesZoom', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_bouncesZoom);
  }

  /// setBouncesZoom:
  set bouncesZoom(bool value) {
    objc.checkOsVersionInternal('UIScrollView.setBouncesZoom:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setBouncesZoom_, value);
  }

  /// isZooming
  bool get zooming {
    objc.checkOsVersionInternal('UIScrollView.isZooming', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isZooming);
  }

  /// isZoomBouncing
  bool get zoomBouncing {
    objc.checkOsVersionInternal('UIScrollView.isZoomBouncing', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isZoomBouncing);
  }

  /// scrollsToTop
  bool get scrollsToTop {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_scrollsToTop);
  }

  /// setScrollsToTop:
  set scrollsToTop(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setScrollsToTop_, value);
  }

  /// panGestureRecognizer
  UIPanGestureRecognizer get panGestureRecognizer {
    objc.checkOsVersionInternal('UIScrollView.panGestureRecognizer', iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_panGestureRecognizer);
    return UIPanGestureRecognizer.castFromPointer(_ret, retain: true, release: true);
  }

  /// pinchGestureRecognizer
  UIPinchGestureRecognizer? get pinchGestureRecognizer {
    objc.checkOsVersionInternal('UIScrollView.pinchGestureRecognizer', iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_pinchGestureRecognizer);
    return _ret.address == 0 ? null : UIPinchGestureRecognizer.castFromPointer(_ret, retain: true, release: true);
  }

  /// directionalPressGestureRecognizer
  UIGestureRecognizer get directionalPressGestureRecognizer {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_directionalPressGestureRecognizer);
    return UIGestureRecognizer.castFromPointer(_ret, retain: true, release: true);
  }

  /// keyboardDismissMode
  UIScrollViewKeyboardDismissMode get keyboardDismissMode {
    objc.checkOsVersionInternal('UIScrollView.keyboardDismissMode', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_1v83s9d(this.ref.pointer, _sel_keyboardDismissMode);
    return UIScrollViewKeyboardDismissMode.fromValue(_ret);
  }

  /// setKeyboardDismissMode:
  set keyboardDismissMode(UIScrollViewKeyboardDismissMode value) {
    objc.checkOsVersionInternal('UIScrollView.setKeyboardDismissMode:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_1c75p8t(this.ref.pointer, _sel_setKeyboardDismissMode_, value.value);
  }

  /// refreshControl
  UIRefreshControl? get refreshControl {
    objc.checkOsVersionInternal('UIScrollView.refreshControl', iOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_refreshControl);
    return _ret.address == 0 ? null : UIRefreshControl.castFromPointer(_ret, retain: true, release: true);
  }

  /// setRefreshControl:
  set refreshControl(UIRefreshControl? value) {
    objc.checkOsVersionInternal('UIScrollView.setRefreshControl:', iOS: (false, (10, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setRefreshControl_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// initWithFrame:
  UIScrollView initWithFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal('UIScrollView.initWithFrame:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_15yz4e6(this.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return UIScrollView.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIScrollView? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0 ? null : UIScrollView.castFromPointer(_ret, retain: false, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// The visible size of this scrollable container.
  objc.CGSize get visibleSize {
    objc.checkOsVersionInternal('UIScrollView.visibleSize', iOS: (false, (12, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1vdfkenStret(_ptr, this.ref.pointer, _sel_visibleSize)
        : _ptr.ref = _objc_msgSend_1vdfken(this.ref.pointer, _sel_visibleSize);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// The coordinate space of the focus items contained in this container. The focus items returned by focusItemsInRect: should report their frames in this coordinate space.
  /// If you are implementing this protocol, you may find it convenient to return the UIScreen as your coordinate space, and ensure that your contained items report their frames in screen space.
  /// Similarly, you might find that your focus items' containing UIView or UIWindow is the most convenient coordinate space to use.
  /// You may also choose to implement your own object that conforms to UICoordinateSpace, if that is the most natural solution for your architecture.
  UICoordinateSpace get coordinateSpace {
    objc.checkOsVersionInternal('UIScrollView.coordinateSpace', iOS: (false, (12, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_coordinateSpace);
    return UICoordinateSpace.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an array of all focus items within this container that intersect with the provided rect. `rect` is expressed in `coordinateSpace`.
  objc.NSArray focusItemsInRect(objc.CGRect rect) {
    objc.checkOsVersionInternal('UIScrollView.focusItemsInRect:', iOS: (false, (12, 0, 0)));
    final _ret = _objc_msgSend_15yz4e6(this.ref.pointer, _sel_focusItemsInRect_, rect);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }
}

enum NSDirectionalRectEdge {
  NSDirectionalRectEdgeNone(0),
  NSDirectionalRectEdgeTop(1),
  NSDirectionalRectEdgeLeading(2),
  NSDirectionalRectEdgeBottom(4),
  NSDirectionalRectEdgeTrailing(8),
  NSDirectionalRectEdgeAll(15);

  final int value;
  const NSDirectionalRectEdge(this.value);

  static NSDirectionalRectEdge fromValue(int value) => switch (value) {
    0 => NSDirectionalRectEdgeNone,
    1 => NSDirectionalRectEdgeTop,
    2 => NSDirectionalRectEdgeLeading,
    4 => NSDirectionalRectEdgeBottom,
    8 => NSDirectionalRectEdgeTrailing,
    15 => NSDirectionalRectEdgeAll,
    _ => throw ArgumentError('Unknown value for NSDirectionalRectEdge: $value'),
  };
}

late final _sel_setContentScrollView_forEdge_ = objc.registerName("setContentScrollView:forEdge:");
final _objc_msgSend_13y7vr7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>, int)
    >();
late final _sel_contentScrollViewForEdge_ = objc.registerName("contentScrollViewForEdge:");
final _objc_msgSend_kh1gvt = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)
    >();
late final _sel_preferredContentSize = objc.registerName("preferredContentSize");
late final _sel_setPreferredContentSize_ = objc.registerName("setPreferredContentSize:");

enum UIStatusBarStyle {
  UIStatusBarStyleDefault(0),
  UIStatusBarStyleLightContent(1),
  UIStatusBarStyleDarkContent(3),
  UIStatusBarStyleBlackOpaque(2);

  static const UIStatusBarStyleBlackTranslucent = UIStatusBarStyleLightContent;

  final int value;
  const UIStatusBarStyle(this.value);

  static UIStatusBarStyle fromValue(int value) => switch (value) {
    0 => UIStatusBarStyleDefault,
    1 => UIStatusBarStyleLightContent,
    3 => UIStatusBarStyleDarkContent,
    2 => UIStatusBarStyleBlackOpaque,
    _ => throw ArgumentError('Unknown value for UIStatusBarStyle: $value'),
  };

  @override
  String toString() {
    if (this == UIStatusBarStyleLightContent)
      return "UIStatusBarStyle.UIStatusBarStyleLightContent, UIStatusBarStyle.UIStatusBarStyleBlackTranslucent";
    return super.toString();
  }
}

late final _sel_preferredStatusBarStyle = objc.registerName("preferredStatusBarStyle");
final _objc_msgSend_czyja3 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_prefersStatusBarHidden = objc.registerName("prefersStatusBarHidden");

enum UIStatusBarAnimation {
  UIStatusBarAnimationNone(0),
  UIStatusBarAnimationFade(1),
  UIStatusBarAnimationSlide(2);

  final int value;
  const UIStatusBarAnimation(this.value);

  static UIStatusBarAnimation fromValue(int value) => switch (value) {
    0 => UIStatusBarAnimationNone,
    1 => UIStatusBarAnimationFade,
    2 => UIStatusBarAnimationSlide,
    _ => throw ArgumentError('Unknown value for UIStatusBarAnimation: $value'),
  };
}

late final _sel_preferredStatusBarUpdateAnimation = objc.registerName("preferredStatusBarUpdateAnimation");
final _objc_msgSend_14wdvus = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setNeedsStatusBarAppearanceUpdate = objc.registerName("setNeedsStatusBarAppearanceUpdate");
late final _sel_targetViewControllerForAction_sender_ = objc.registerName("targetViewControllerForAction:sender:");
final _objc_msgSend_gx50so = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_showDetailViewController_sender_ = objc.registerName("showDetailViewController:sender:");

enum UIUserInterfaceStyle {
  UIUserInterfaceStyleUnspecified(0),
  UIUserInterfaceStyleLight(1),
  UIUserInterfaceStyleDark(2);

  final int value;
  const UIUserInterfaceStyle(this.value);

  static UIUserInterfaceStyle fromValue(int value) => switch (value) {
    0 => UIUserInterfaceStyleUnspecified,
    1 => UIUserInterfaceStyleLight,
    2 => UIUserInterfaceStyleDark,
    _ => throw ArgumentError('Unknown value for UIUserInterfaceStyle: $value'),
  };
}

late final _sel_preferredUserInterfaceStyle = objc.registerName("preferredUserInterfaceStyle");
final _objc_msgSend_2x5ago = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setNeedsUserInterfaceAppearanceUpdate = objc.registerName("setNeedsUserInterfaceAppearanceUpdate");
late final _sel_overrideUserInterfaceStyle = objc.registerName("overrideUserInterfaceStyle");
late final _sel_setOverrideUserInterfaceStyle_ = objc.registerName("setOverrideUserInterfaceStyle:");
final _objc_msgSend_15dz1ky = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_traitCollection = objc.registerName("traitCollection");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_UITraitCollection_ffiVoid_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>>()
    .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UITraitCollection_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
        >(_ObjCBlock_UITraitCollection_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_UITraitCollection_ffiVoid_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UITraitCollection_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
        >(_ObjCBlock_UITraitCollection_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UITraitCollection_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_ObjCBlock_UITraitCollection_ffiVoid_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)> fromFunction(
    UITraitCollection Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _ObjCBlock_UITraitCollection_ffiVoid_closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UITraitCollection_ffiVoid_CallExtension
    on objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)> {
  UITraitCollection call(ffi.Pointer<ffi.Void> arg0) => UITraitCollection.castFromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)
          >
        >()
        .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(
      ref.pointer,
      arg0,
    ),
    retain: true,
    release: true,
  );
}

late final _sel_traitCollectionDidChange_ = objc.registerName("traitCollectionDidChange:");
void _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
    .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
>
_ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.isolateLocal(_ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UITraitCollection {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>(
    objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, UITraitCollection?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>(
    objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, arg1.address == 0 ? null : UITraitCollection.castFromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)> listener(
    void Function(ffi.Pointer<ffi.Void>, UITraitCollection?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, arg1.address == 0 ? null : UITraitCollection.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)> blocking(
    void Function(ffi.Pointer<ffi.Void>, UITraitCollection?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, arg1.address == 0 ? null : UITraitCollection.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, arg1.address == 0 ? null : UITraitCollection.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)> {
  void call(ffi.Pointer<ffi.Void> arg0, UITraitCollection? arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_preferredContentSizeDidChangeForChildContentContainer_ = objc.registerName(
  "preferredContentSizeDidChangeForChildContentContainer:",
);
void _ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
    .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
>
_ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.isolateLocal(_ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
    objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, UIContentContainer) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
    objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, UIContentContainer.castFromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> listener(
    void Function(ffi.Pointer<ffi.Void>, UIContentContainer) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer_listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, UIContentContainer.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> blocking(
    void Function(ffi.Pointer<ffi.Void>, UIContentContainer) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer_blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, UIContentContainer.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer_blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, UIContentContainer.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> {
  void call(ffi.Pointer<ffi.Void> arg0, UIContentContainer arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_systemLayoutFittingSizeDidChangeForChildContentContainer_ = objc.registerName(
  "systemLayoutFittingSizeDidChangeForChildContentContainer:",
);
late final _sel_sizeForChildContentContainer_withParentContainerSize_ = objc.registerName(
  "sizeForChildContentContainer:withParentContainerSize:",
);
final _objc_msgSend_xq5db9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGSize Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          objc.CGSize,
        )
      >
    >()
    .asFunction<
      objc.CGSize Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        objc.CGSize,
      )
    >();
final _objc_msgSend_xq5db9Stret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGSize>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          objc.CGSize,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGSize>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        objc.CGSize,
      )
    >();
objc.CGSize _ObjCBlock_CGSize_ffiVoid_idUIContentContainer_CGSize_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  objc.CGSize arg2,
) =>
    block.ref.target
        .cast<
          ffi.NativeFunction<
            objc.CGSize Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, objc.CGSize arg2)
          >
        >()
        .asFunction<objc.CGSize Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize)>()(
      arg0,
      arg1,
      arg2,
    );
ffi.Pointer<ffi.Void> _ObjCBlock_CGSize_ffiVoid_idUIContentContainer_CGSize_fnPtrCallable =
    ffi.Pointer.fromFunction<
          objc.CGSize Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            objc.CGSize,
          )
        >(_ObjCBlock_CGSize_ffiVoid_idUIContentContainer_CGSize_fnPtrTrampoline)
        .cast();
objc.CGSize _ObjCBlock_CGSize_ffiVoid_idUIContentContainer_CGSize_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  objc.CGSize arg2,
) =>
    (objc.getBlockClosure(block)
        as objc.CGSize Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void> _ObjCBlock_CGSize_ffiVoid_idUIContentContainer_CGSize_closureCallable =
    ffi.Pointer.fromFunction<
          objc.CGSize Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            objc.CGSize,
          )
        >(_ObjCBlock_CGSize_ffiVoid_idUIContentContainer_CGSize_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize)>`.
abstract final class ObjCBlock_CGSize_ffiVoid_idUIContentContainer_CGSize {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        objc.CGSize Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, objc.CGSize arg2)
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize)>(
    objc.newPointerBlock(_ObjCBlock_CGSize_ffiVoid_idUIContentContainer_CGSize_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize)>
  fromFunction(
    objc.CGSize Function(ffi.Pointer<ffi.Void>, UIContentContainer, objc.CGSize) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize)>(
    objc.newClosureBlock(
      _ObjCBlock_CGSize_ffiVoid_idUIContentContainer_CGSize_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, objc.CGSize arg2) =>
          fn(arg0, UIContentContainer.castFromPointer(arg1, retain: true, release: true), arg2),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize)>`.
extension ObjCBlock_CGSize_ffiVoid_idUIContentContainer_CGSize_CallExtension
    on objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize)> {
  objc.CGSize call(ffi.Pointer<ffi.Void> arg0, UIContentContainer arg1, objc.CGSize arg2) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          objc.CGSize Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            objc.CGSize arg2,
          )
        >
      >()
      .asFunction<
        objc.CGSize Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          objc.CGSize,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2);
}

/// WARNING: UIViewControllerTransitionCoordinator is a stub. To generate bindings for this class, include
/// UIViewControllerTransitionCoordinator in your config's objc-protocols list.
///
/// UIViewControllerTransitionCoordinator
interface class UIViewControllerTransitionCoordinator extends objc.ObjCProtocolBase {
  UIViewControllerTransitionCoordinator._(
    ffi.Pointer<objc.ObjCObject> pointer, {
    bool retain = false,
    bool release = false,
  }) : super(pointer, retain: retain, release: release);

  /// Constructs a [UIViewControllerTransitionCoordinator] that points to the same underlying object as [other].
  UIViewControllerTransitionCoordinator.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIViewControllerTransitionCoordinator] that wraps the given raw object pointer.
  UIViewControllerTransitionCoordinator.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_viewWillTransitionToSize_withTransitionCoordinator_ = objc.registerName(
  "viewWillTransitionToSize:withTransitionCoordinator:",
);
final _objc_msgSend_11tcc61 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGSize,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGSize,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
void _ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGSize arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) => block.ref.target
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> arg0, objc.CGSize arg1, ffi.Pointer<objc.ObjCObject> arg2)
      >
    >()
    .asFunction<void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            objc.CGSize,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGSize arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>))(
  arg0,
  arg1,
  arg2,
);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            objc.CGSize,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGSize arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>))(
    arg0,
    arg1,
    arg2,
  );
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)
>
_ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          objc.CGSize,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGSize arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>))(
      arg0,
      arg1,
      arg2,
    );
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    objc.CGSize,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          objc.CGSize,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.isolateLocal(_ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    objc.CGSize,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          objc.CGSize,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> arg0, objc.CGSize arg1, ffi.Pointer<objc.ObjCObject> arg2)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)>(
    objc.newPointerBlock(
      _ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator_fnPtrCallable,
      ptr.cast(),
    ),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.CGSize, UIViewControllerTransitionCoordinator) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)>(
    objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, objc.CGSize arg1, ffi.Pointer<objc.ObjCObject> arg2) =>
          fn(arg0, arg1, UIViewControllerTransitionCoordinator.castFromPointer(arg2, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)> listener(
    void Function(ffi.Pointer<ffi.Void>, objc.CGSize, UIViewControllerTransitionCoordinator) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator_listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.CGSize arg1, ffi.Pointer<objc.ObjCObject> arg2) =>
          fn(arg0, arg1, UIViewControllerTransitionCoordinator.castFromPointer(arg2, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_1rn6eap(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)> blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.CGSize, UIViewControllerTransitionCoordinator) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator_blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.CGSize arg1, ffi.Pointer<objc.ObjCObject> arg2) =>
          fn(arg0, arg1, UIViewControllerTransitionCoordinator.castFromPointer(arg2, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator_blockingListenerCallable.nativeFunction
          .cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.CGSize arg1, ffi.Pointer<objc.ObjCObject> arg2) =>
          fn(arg0, arg1, UIViewControllerTransitionCoordinator.castFromPointer(arg2, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_1rn6eap(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.CGSize arg1, UIViewControllerTransitionCoordinator arg2) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.CGSize arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0, arg1, arg2.ref.pointer);
}

late final _sel_willTransitionToTraitCollection_withTransitionCoordinator_ = objc.registerName(
  "willTransitionToTraitCollection:withTransitionCoordinator:",
);
void _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) =>
    block.ref.target
        .cast<
          ffi.NativeFunction<
            ffi.Void Function(
              ffi.Pointer<ffi.Void> arg0,
              ffi.Pointer<objc.ObjCObject> arg1,
              ffi.Pointer<objc.ObjCObject> arg2,
            )
          >
        >()
        .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>()(
      arg0,
      arg1,
      arg2,
    );
ffi.Pointer<ffi.Void>
_ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) =>
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
      arg0,
      arg1,
      arg2,
    );
ffi.Pointer<ffi.Void>
_ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) {
  (objc.getBlockClosure(block)
      as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
    arg0,
    arg1,
    arg2,
  );
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator_listenerTrampoline,
      )
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) {
  try {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
      arg0,
      arg1,
      arg2,
    );
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator_blockingTrampoline,
      )
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(
        _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator_blockingTrampoline,
      )
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>(
    objc.newPointerBlock(
      _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator_fnPtrCallable,
      ptr.cast(),
    ),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, UITraitCollection, UIViewControllerTransitionCoordinator) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>(
    objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UITraitCollection.castFromPointer(arg1, retain: true, release: true),
        UIViewControllerTransitionCoordinator.castFromPointer(arg2, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, UITraitCollection, UIViewControllerTransitionCoordinator) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator_listenerCallable
          .nativeFunction
          .cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UITraitCollection.castFromPointer(arg1, retain: false, release: true),
        UIViewControllerTransitionCoordinator.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, UITraitCollection, UIViewControllerTransitionCoordinator) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator_blockingCallable
          .nativeFunction
          .cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UITraitCollection.castFromPointer(arg1, retain: false, release: true),
        UIViewControllerTransitionCoordinator.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator_blockingListenerCallable
          .nativeFunction
          .cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UITraitCollection.castFromPointer(arg1, retain: false, release: true),
        UIViewControllerTransitionCoordinator.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_fjrv01(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)> {
  void call(ffi.Pointer<ffi.Void> arg0, UITraitCollection arg1, UIViewControllerTransitionCoordinator arg2) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_preferredFocusEnvironments = objc.registerName("preferredFocusEnvironments");
late final _sel_parentFocusEnvironment = objc.registerName("parentFocusEnvironment");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_idUIFocusEnvironment_ffiVoid_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>>()
    .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_idUIFocusEnvironment_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
        >(_ObjCBlock_idUIFocusEnvironment_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_idUIFocusEnvironment_ffiVoid_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_idUIFocusEnvironment_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
        >(_ObjCBlock_idUIFocusEnvironment_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUIFocusEnvironment_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_ObjCBlock_idUIFocusEnvironment_ffiVoid_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> fromFunction(
    UIFocusEnvironment? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _ObjCBlock_idUIFocusEnvironment_ffiVoid_closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUIFocusEnvironment_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> {
  UIFocusEnvironment? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIFocusEnvironment.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_focusItemContainer = objc.registerName("focusItemContainer");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_idUIFocusItemContainer_ffiVoid_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>>()
    .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_idUIFocusItemContainer_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
        >(_ObjCBlock_idUIFocusItemContainer_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_idUIFocusItemContainer_ffiVoid_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_idUIFocusItemContainer_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
        >(_ObjCBlock_idUIFocusItemContainer_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUIFocusItemContainer_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_ObjCBlock_idUIFocusItemContainer_ffiVoid_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> fromFunction(
    UIFocusItemContainer? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _ObjCBlock_idUIFocusItemContainer_ffiVoid_closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUIFocusItemContainer_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> {
  UIFocusItemContainer? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIFocusItemContainer.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_setNeedsFocusUpdate = objc.registerName("setNeedsFocusUpdate");
void _ObjCBlock_ffiVoid_ffiVoid_fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<void Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
      _ObjCBlock_ffiVoid_ffiVoid_fnPtrTrampoline,
    ).cast();
void _ObjCBlock_ffiVoid_ffiVoid_closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
      _ObjCBlock_ffiVoid_ffiVoid_closureTrampoline,
    ).cast();
void _ObjCBlock_ffiVoid_ffiVoid_listenerTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>
_ObjCBlock_ffiVoid_ffiVoid_listenerCallable =
    ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>.listener(
      _ObjCBlock_ffiVoid_ffiVoid_listenerTrampoline,
    )..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>
_ObjCBlock_ffiVoid_ffiVoid_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
      >.isolateLocal(_ObjCBlock_ffiVoid_ffiVoid_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>
_ObjCBlock_ffiVoid_ffiVoid_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> listener(
    void Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_ovsamd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> blocking(
    void Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_ovsamd(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> {
  void call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_updateFocusIfNeeded = objc.registerName("updateFocusIfNeeded");

/// WARNING: UIFocusUpdateContext is a stub. To generate bindings for this class, include
/// UIFocusUpdateContext in your config's objc-interfaces list.
///
/// UIFocusUpdateContexts provide information relevant to a specific focus update from one view to another. They are ephemeral objects that are usually discarded after the update is finished.
class UIFocusUpdateContext extends objc.NSObject {
  UIFocusUpdateContext._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIFocusUpdateContext', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UIFocusUpdateContext] that points to the same underlying object as [other].
  UIFocusUpdateContext.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusUpdateContext] that wraps the given raw object pointer.
  UIFocusUpdateContext.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_shouldUpdateFocusInContext_ = objc.registerName("shouldUpdateFocusInContext:");
bool _ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
    .asFunction<bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_fnPtrTrampoline, false)
        .cast();
bool _ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_closureTrampoline, false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>`.
abstract final class ObjCBlock_bool_ffiVoid_UIFocusUpdateContext {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
    ptr,
  ) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(
    objc.newPointerBlock(_ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> fromFunction(
    bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(
    objc.newClosureBlock(
      _ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, UIFocusUpdateContext.castFromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>`.
extension ObjCBlock_bool_ffiVoid_UIFocusUpdateContext_CallExtension
    on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> {
  bool call(ffi.Pointer<ffi.Void> arg0, UIFocusUpdateContext arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// WARNING: UIFocusAnimationCoordinator is a stub. To generate bindings for this class, include
/// UIFocusAnimationCoordinator in your config's objc-interfaces list.
///
/// UIFocusAnimationCoordinator is used to coordinate disparate animations that are related to a focus update.
class UIFocusAnimationCoordinator extends objc.NSObject {
  UIFocusAnimationCoordinator._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIFocusAnimationCoordinator', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UIFocusAnimationCoordinator] that points to the same underlying object as [other].
  UIFocusAnimationCoordinator.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusAnimationCoordinator] that wraps the given raw object pointer.
  UIFocusAnimationCoordinator.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_didUpdateFocusInContext_withAnimationCoordinator_ = objc.registerName(
  "didUpdateFocusInContext:withAnimationCoordinator:",
);
void _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) =>
    block.ref.target
        .cast<
          ffi.NativeFunction<
            ffi.Void Function(
              ffi.Pointer<ffi.Void> arg0,
              ffi.Pointer<objc.ObjCObject> arg1,
              ffi.Pointer<objc.ObjCObject> arg2,
            )
          >
        >()
        .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>()(
      arg0,
      arg1,
      arg2,
    );
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) =>
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
      arg0,
      arg1,
      arg2,
    );
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) {
  (objc.getBlockClosure(block)
      as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
    arg0,
    arg1,
    arg2,
  );
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) {
  try {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
      arg0,
      arg1,
      arg2,
    );
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.isolateLocal(_ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>(
    objc.newPointerBlock(
      _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_fnPtrCallable,
      ptr.cast(),
    ),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>(
    objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UIFocusUpdateContext.castFromPointer(arg1, retain: true, release: true),
        UIFocusAnimationCoordinator.castFromPointer(arg2, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_listenerCallable.nativeFunction
          .cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UIFocusUpdateContext.castFromPointer(arg1, retain: false, release: true),
        UIFocusAnimationCoordinator.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_blockingCallable.nativeFunction
          .cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UIFocusUpdateContext.castFromPointer(arg1, retain: false, release: true),
        UIFocusAnimationCoordinator.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_blockingListenerCallable
          .nativeFunction
          .cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UIFocusUpdateContext.castFromPointer(arg1, retain: false, release: true),
        UIFocusAnimationCoordinator.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_fjrv01(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>(
      wrapper,
      retain: false,
      release: true,
    );
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)> {
  void call(ffi.Pointer<ffi.Void> arg0, UIFocusUpdateContext arg1, UIFocusAnimationCoordinator arg2) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_soundIdentifierForFocusUpdateInContext_ = objc.registerName("soundIdentifierForFocusUpdateInContext:");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) =>
    block.ref.target
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)
          >
        >()
        .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
      arg0,
      arg1,
    );
ffi.Pointer<ffi.Void> _ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) =>
    (objc.getBlockClosure(block)
        as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>`.
abstract final class ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(
    objc.newPointerBlock(_ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> fromFunction(
    objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(
    objc.newClosureBlock(
      _ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(
            arg0,
            UIFocusUpdateContext.castFromPointer(arg1, retain: true, release: true),
          )?.ref.retainAndAutorelease() ??
          ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>`.
extension ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext_CallExtension
    on objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> {
  objc.NSString? call(ffi.Pointer<ffi.Void> arg0, UIFocusUpdateContext arg1) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer)
              .address ==
          0
      ? null
      : objc.NSString.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer),
          retain: true,
          release: true,
        );
}

late final _sel_preferredFocusedView = objc.registerName("preferredFocusedView");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIView_ffiVoid_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>>()
    .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIView_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
        >(_ObjCBlock_UIView_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIView_ffiVoid_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIView_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
        >(_ObjCBlock_UIView_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIView_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_ObjCBlock_UIView_ffiVoid_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)> fromFunction(
    UIView? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _ObjCBlock_UIView_ffiVoid_closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIView_ffiVoid_CallExtension on objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)> {
  UIView? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIView.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_previewActionItems = objc.registerName("previewActionItems");

/// UIViewController
class UIViewController extends UIResponder
    implements objc.NSCoding, UIAppearanceContainer, UITraitEnvironment, UIContentContainer, UIFocusEnvironment {
  UIViewController._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [UIViewController] that points to the same underlying object as [other].
  UIViewController.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIViewController] that wraps the given raw object pointer.
  UIViewController.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIViewController].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIViewController);
  }

  static UIViewController new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIViewController, _sel_new);
    return UIViewController.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of UIViewController constructed with the default `new` method.
  factory UIViewController() => new$();
}

extension UIViewController$Methods on UIViewController {
  /// initWithNibName:bundle:
  UIViewController initWithNibName(objc.NSString? nibNameOrNil, {NSBundle? bundle}) {
    objc.checkOsVersionInternal('UIViewController.initWithNibName:bundle:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_15qeuct(
      this.ref.retainAndReturnPointer(),
      _sel_initWithNibName_bundle_,
      nibNameOrNil?.ref.pointer ?? ffi.nullptr,
      bundle?.ref.pointer ?? ffi.nullptr,
    );
    return UIViewController.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIViewController? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0 ? null : UIViewController.castFromPointer(_ret, retain: false, release: true);
  }

  /// view
  UIView get view {
    objc.checkOsVersionInternal('UIViewController.view', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_view);
    return UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// setView:
  set view(UIView value) {
    objc.checkOsVersionInternal('UIViewController.setView:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setView_, value.ref.pointer);
  }

  /// loadView
  void loadView() {
    objc.checkOsVersionInternal('UIViewController.loadView', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_loadView);
  }

  /// loadViewIfNeeded
  void loadViewIfNeeded() {
    objc.checkOsVersionInternal('UIViewController.loadViewIfNeeded', iOS: (false, (9, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_loadViewIfNeeded);
  }

  /// viewIfLoaded
  UIView? get viewIfLoaded {
    objc.checkOsVersionInternal('UIViewController.viewIfLoaded', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_viewIfLoaded);
    return _ret.address == 0 ? null : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// viewWillUnload
  void viewWillUnload() {
    objc.checkOsVersionInternal('UIViewController.viewWillUnload', iOS: (false, (5, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_viewWillUnload);
  }

  /// viewDidUnload
  void viewDidUnload() {
    objc.checkOsVersionInternal('UIViewController.viewDidUnload', iOS: (false, (3, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_viewDidUnload);
  }

  /// viewDidLoad
  void viewDidLoad() {
    objc.checkOsVersionInternal('UIViewController.viewDidLoad', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_viewDidLoad);
  }

  /// isViewLoaded
  bool get viewLoaded {
    objc.checkOsVersionInternal('UIViewController.isViewLoaded', iOS: (false, (3, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isViewLoaded);
  }

  /// nibName
  objc.NSString? get nibName {
    objc.checkOsVersionInternal('UIViewController.nibName', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_nibName);
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// nibBundle
  NSBundle? get nibBundle {
    objc.checkOsVersionInternal('UIViewController.nibBundle', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_nibBundle);
    return _ret.address == 0 ? null : NSBundle.castFromPointer(_ret, retain: true, release: true);
  }

  /// storyboard
  UIStoryboard? get storyboard {
    objc.checkOsVersionInternal('UIViewController.storyboard', iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_storyboard);
    return _ret.address == 0 ? null : UIStoryboard.castFromPointer(_ret, retain: true, release: true);
  }

  /// performSegueWithIdentifier:sender:
  void performSegueWithIdentifier(objc.NSString identifier, {objc.ObjCObjectBase? sender}) {
    objc.checkOsVersionInternal('UIViewController.performSegueWithIdentifier:sender:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_performSegueWithIdentifier_sender_,
      identifier.ref.pointer,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// shouldPerformSegueWithIdentifier:sender:
  bool shouldPerformSegueWithIdentifier(objc.NSString identifier, {objc.ObjCObjectBase? sender}) {
    objc.checkOsVersionInternal('UIViewController.shouldPerformSegueWithIdentifier:sender:', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_1lsax7n(
      this.ref.pointer,
      _sel_shouldPerformSegueWithIdentifier_sender_,
      identifier.ref.pointer,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// prepareForSegue:sender:
  void prepareForSegue(UIStoryboardSegue segue, {objc.ObjCObjectBase? sender}) {
    objc.checkOsVersionInternal('UIViewController.prepareForSegue:sender:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_prepareForSegue_sender_,
      segue.ref.pointer,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// canPerformUnwindSegueAction:fromViewController:sender:
  bool canPerformUnwindSegueAction(
    ffi.Pointer<objc.ObjCSelector> action, {
    required UIViewController fromViewController,
    objc.ObjCObjectBase? sender,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.canPerformUnwindSegueAction:fromViewController:sender:',
      iOS: (false, (13, 0, 0)),
    );
    return _objc_msgSend_iv7uhk(
      this.ref.pointer,
      _sel_canPerformUnwindSegueAction_fromViewController_sender_,
      action,
      fromViewController.ref.pointer,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// canPerformUnwindSegueAction:fromViewController:withSender:
  bool canPerformUnwindSegueAction$1(
    ffi.Pointer<objc.ObjCSelector> action, {
    required UIViewController fromViewController,
    required objc.ObjCObjectBase withSender,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.canPerformUnwindSegueAction:fromViewController:withSender:',
      iOS: (false, (6, 0, 0)),
    );
    return _objc_msgSend_iv7uhk(
      this.ref.pointer,
      _sel_canPerformUnwindSegueAction_fromViewController_withSender_,
      action,
      fromViewController.ref.pointer,
      withSender.ref.pointer,
    );
  }

  /// allowedChildViewControllersForUnwindingFromSource:
  objc.NSArray allowedChildViewControllersForUnwindingFromSource(UIStoryboardUnwindSegueSource source) {
    objc.checkOsVersionInternal(
      'UIViewController.allowedChildViewControllersForUnwindingFromSource:',
      iOS: (false, (9, 0, 0)),
    );
    final _ret = _objc_msgSend_1sotr3r(
      this.ref.pointer,
      _sel_allowedChildViewControllersForUnwindingFromSource_,
      source.ref.pointer,
    );
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// childViewControllerContainingSegueSource:
  UIViewController? childViewControllerContainingSegueSource(UIStoryboardUnwindSegueSource source) {
    objc.checkOsVersionInternal('UIViewController.childViewControllerContainingSegueSource:', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
      this.ref.pointer,
      _sel_childViewControllerContainingSegueSource_,
      source.ref.pointer,
    );
    return _ret.address == 0 ? null : UIViewController.castFromPointer(_ret, retain: true, release: true);
  }

  /// viewControllerForUnwindSegueAction:fromViewController:withSender:
  UIViewController? viewControllerForUnwindSegueAction(
    ffi.Pointer<objc.ObjCSelector> action, {
    required UIViewController fromViewController,
    objc.ObjCObjectBase? withSender,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.viewControllerForUnwindSegueAction:fromViewController:withSender:',
      iOS: (false, (6, 0, 0)),
    );
    final _ret = _objc_msgSend_cfx8ce(
      this.ref.pointer,
      _sel_viewControllerForUnwindSegueAction_fromViewController_withSender_,
      action,
      fromViewController.ref.pointer,
      withSender?.ref.pointer ?? ffi.nullptr,
    );
    return _ret.address == 0 ? null : UIViewController.castFromPointer(_ret, retain: true, release: true);
  }

  /// unwindForSegue:towardsViewController:
  void unwindForSegue(UIStoryboardSegue unwindSegue, {required UIViewController towardsViewController}) {
    objc.checkOsVersionInternal('UIViewController.unwindForSegue:towardsViewController:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_unwindForSegue_towardsViewController_,
      unwindSegue.ref.pointer,
      towardsViewController.ref.pointer,
    );
  }

  /// segueForUnwindingToViewController:fromViewController:identifier:
  UIStoryboardSegue? segueForUnwindingToViewController(
    UIViewController toViewController, {
    required UIViewController fromViewController,
    objc.NSString? identifier,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.segueForUnwindingToViewController:fromViewController:identifier:',
      iOS: (false, (6, 0, 0)),
    );
    final _ret = _objc_msgSend_11spmsz(
      this.ref.pointer,
      _sel_segueForUnwindingToViewController_fromViewController_identifier_,
      toViewController.ref.pointer,
      fromViewController.ref.pointer,
      identifier?.ref.pointer ?? ffi.nullptr,
    );
    return _ret.address == 0 ? null : UIStoryboardSegue.castFromPointer(_ret, retain: true, release: true);
  }

  /// viewWillAppear:
  void viewWillAppear(bool animated) {
    objc.checkOsVersionInternal('UIViewController.viewWillAppear:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_viewWillAppear_, animated);
  }

  /// viewDidAppear:
  void viewDidAppear(bool animated) {
    objc.checkOsVersionInternal('UIViewController.viewDidAppear:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_viewDidAppear_, animated);
  }

  /// viewWillDisappear:
  void viewWillDisappear(bool animated) {
    objc.checkOsVersionInternal('UIViewController.viewWillDisappear:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_viewWillDisappear_, animated);
  }

  /// viewDidDisappear:
  void viewDidDisappear(bool animated) {
    objc.checkOsVersionInternal('UIViewController.viewDidDisappear:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_viewDidDisappear_, animated);
  }

  /// viewWillLayoutSubviews
  void viewWillLayoutSubviews() {
    objc.checkOsVersionInternal('UIViewController.viewWillLayoutSubviews', iOS: (false, (5, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_viewWillLayoutSubviews);
  }

  /// viewDidLayoutSubviews
  void viewDidLayoutSubviews() {
    objc.checkOsVersionInternal('UIViewController.viewDidLayoutSubviews', iOS: (false, (5, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_viewDidLayoutSubviews);
  }

  /// title
  objc.NSString? get title {
    objc.checkOsVersionInternal('UIViewController.title', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTitle:
  set title(objc.NSString? value) {
    objc.checkOsVersionInternal('UIViewController.setTitle:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTitle_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// didReceiveMemoryWarning
  void didReceiveMemoryWarning() {
    objc.checkOsVersionInternal('UIViewController.didReceiveMemoryWarning', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_didReceiveMemoryWarning);
  }

  /// parentViewController
  UIViewController? get parentViewController {
    objc.checkOsVersionInternal('UIViewController.parentViewController', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_parentViewController);
    return _ret.address == 0 ? null : UIViewController.castFromPointer(_ret, retain: true, release: true);
  }

  /// modalViewController
  UIViewController? get modalViewController {
    objc.checkOsVersionInternal('UIViewController.modalViewController', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_modalViewController);
    return _ret.address == 0 ? null : UIViewController.castFromPointer(_ret, retain: true, release: true);
  }

  /// presentedViewController
  UIViewController? get presentedViewController {
    objc.checkOsVersionInternal('UIViewController.presentedViewController', iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_presentedViewController);
    return _ret.address == 0 ? null : UIViewController.castFromPointer(_ret, retain: true, release: true);
  }

  /// presentingViewController
  UIViewController? get presentingViewController {
    objc.checkOsVersionInternal('UIViewController.presentingViewController', iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_presentingViewController);
    return _ret.address == 0 ? null : UIViewController.castFromPointer(_ret, retain: true, release: true);
  }

  /// definesPresentationContext
  bool get definesPresentationContext {
    objc.checkOsVersionInternal('UIViewController.definesPresentationContext', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_definesPresentationContext);
  }

  /// setDefinesPresentationContext:
  set definesPresentationContext(bool value) {
    objc.checkOsVersionInternal('UIViewController.setDefinesPresentationContext:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setDefinesPresentationContext_, value);
  }

  /// providesPresentationContextTransitionStyle
  bool get providesPresentationContextTransitionStyle {
    objc.checkOsVersionInternal('UIViewController.providesPresentationContextTransitionStyle', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_providesPresentationContextTransitionStyle);
  }

  /// setProvidesPresentationContextTransitionStyle:
  set providesPresentationContextTransitionStyle(bool value) {
    objc.checkOsVersionInternal(
      'UIViewController.setProvidesPresentationContextTransitionStyle:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setProvidesPresentationContextTransitionStyle_, value);
  }

  /// restoresFocusAfterTransition
  bool get restoresFocusAfterTransition {
    objc.checkOsVersionInternal('UIViewController.restoresFocusAfterTransition', iOS: (false, (10, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_restoresFocusAfterTransition);
  }

  /// setRestoresFocusAfterTransition:
  set restoresFocusAfterTransition(bool value) {
    objc.checkOsVersionInternal('UIViewController.setRestoresFocusAfterTransition:', iOS: (false, (10, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setRestoresFocusAfterTransition_, value);
  }

  /// The identifier of the focus group that this view controller belongs to. If this is nil, the view controller inherits the focus group of its parent focus environment.
  objc.NSString? get focusGroupIdentifier {
    objc.checkOsVersionInternal('UIViewController.focusGroupIdentifier', iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_focusGroupIdentifier);
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The identifier of the focus group that this view controller belongs to. If this is nil, the view controller inherits the focus group of its parent focus environment.
  set focusGroupIdentifier(objc.NSString? value) {
    objc.checkOsVersionInternal('UIViewController.setFocusGroupIdentifier:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setFocusGroupIdentifier_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// isBeingPresented
  bool get beingPresented {
    objc.checkOsVersionInternal('UIViewController.isBeingPresented', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isBeingPresented);
  }

  /// isBeingDismissed
  bool get beingDismissed {
    objc.checkOsVersionInternal('UIViewController.isBeingDismissed', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isBeingDismissed);
  }

  /// isMovingToParentViewController
  bool get movingToParentViewController {
    objc.checkOsVersionInternal('UIViewController.isMovingToParentViewController', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isMovingToParentViewController);
  }

  /// isMovingFromParentViewController
  bool get movingFromParentViewController {
    objc.checkOsVersionInternal('UIViewController.isMovingFromParentViewController', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isMovingFromParentViewController);
  }

  /// presentViewController:animated:completion:
  void presentViewController(
    UIViewController viewControllerToPresent, {
    required bool animated,
    objc.ObjCBlock<ffi.Void Function()>? completion,
  }) {
    objc.checkOsVersionInternal('UIViewController.presentViewController:animated:completion:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_na2nx0(
      this.ref.pointer,
      _sel_presentViewController_animated_completion_,
      viewControllerToPresent.ref.pointer,
      animated,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// dismissViewControllerAnimated:completion:
  void dismissViewControllerAnimated(bool flag, {objc.ObjCBlock<ffi.Void Function()>? completion}) {
    objc.checkOsVersionInternal('UIViewController.dismissViewControllerAnimated:completion:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_1ocak7a(
      this.ref.pointer,
      _sel_dismissViewControllerAnimated_completion_,
      flag,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// presentModalViewController:animated:
  void presentModalViewController(UIViewController modalViewController$1, {required bool animated}) {
    objc.checkOsVersionInternal('UIViewController.presentModalViewController:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_6p7ndb(
      this.ref.pointer,
      _sel_presentModalViewController_animated_,
      modalViewController$1.ref.pointer,
      animated,
    );
  }

  /// dismissModalViewControllerAnimated:
  void dismissModalViewControllerAnimated(bool animated) {
    objc.checkOsVersionInternal('UIViewController.dismissModalViewControllerAnimated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_dismissModalViewControllerAnimated_, animated);
  }

  /// modalTransitionStyle
  UIModalTransitionStyle get modalTransitionStyle {
    objc.checkOsVersionInternal('UIViewController.modalTransitionStyle', iOS: (false, (3, 0, 0)));
    final _ret = _objc_msgSend_17t73u4(this.ref.pointer, _sel_modalTransitionStyle);
    return UIModalTransitionStyle.fromValue(_ret);
  }

  /// setModalTransitionStyle:
  set modalTransitionStyle(UIModalTransitionStyle value) {
    objc.checkOsVersionInternal('UIViewController.setModalTransitionStyle:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_gt147a(this.ref.pointer, _sel_setModalTransitionStyle_, value.value);
  }

  /// modalPresentationStyle
  UIModalPresentationStyle get modalPresentationStyle {
    objc.checkOsVersionInternal('UIViewController.modalPresentationStyle', iOS: (false, (3, 2, 0)));
    final _ret = _objc_msgSend_1jdzuw5(this.ref.pointer, _sel_modalPresentationStyle);
    return UIModalPresentationStyle.fromValue(_ret);
  }

  /// setModalPresentationStyle:
  set modalPresentationStyle(UIModalPresentationStyle value) {
    objc.checkOsVersionInternal('UIViewController.setModalPresentationStyle:', iOS: (false, (3, 2, 0)));
    _objc_msgSend_19sk1nl(this.ref.pointer, _sel_setModalPresentationStyle_, value.value);
  }

  /// modalPresentationCapturesStatusBarAppearance
  bool get modalPresentationCapturesStatusBarAppearance {
    objc.checkOsVersionInternal(
      'UIViewController.modalPresentationCapturesStatusBarAppearance',
      iOS: (false, (7, 0, 0)),
    );
    return _objc_msgSend_91o635(this.ref.pointer, _sel_modalPresentationCapturesStatusBarAppearance);
  }

  /// setModalPresentationCapturesStatusBarAppearance:
  set modalPresentationCapturesStatusBarAppearance(bool value) {
    objc.checkOsVersionInternal(
      'UIViewController.setModalPresentationCapturesStatusBarAppearance:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setModalPresentationCapturesStatusBarAppearance_, value);
  }

  /// disablesAutomaticKeyboardDismissal
  bool get disablesAutomaticKeyboardDismissal {
    objc.checkOsVersionInternal('UIViewController.disablesAutomaticKeyboardDismissal', iOS: (false, (4, 3, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_disablesAutomaticKeyboardDismissal);
  }

  /// wantsFullScreenLayout
  bool get wantsFullScreenLayout {
    objc.checkOsVersionInternal('UIViewController.wantsFullScreenLayout', iOS: (false, (3, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_wantsFullScreenLayout);
  }

  /// setWantsFullScreenLayout:
  set wantsFullScreenLayout(bool value) {
    objc.checkOsVersionInternal('UIViewController.setWantsFullScreenLayout:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setWantsFullScreenLayout_, value);
  }

  /// edgesForExtendedLayout
  UIRectEdge get edgesForExtendedLayout {
    objc.checkOsVersionInternal('UIViewController.edgesForExtendedLayout', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_qrqu1s(this.ref.pointer, _sel_edgesForExtendedLayout);
    return UIRectEdge.fromValue(_ret);
  }

  /// setEdgesForExtendedLayout:
  set edgesForExtendedLayout(UIRectEdge value) {
    objc.checkOsVersionInternal('UIViewController.setEdgesForExtendedLayout:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_1xy78x6(this.ref.pointer, _sel_setEdgesForExtendedLayout_, value.value);
  }

  /// extendedLayoutIncludesOpaqueBars
  bool get extendedLayoutIncludesOpaqueBars {
    objc.checkOsVersionInternal('UIViewController.extendedLayoutIncludesOpaqueBars', iOS: (false, (7, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_extendedLayoutIncludesOpaqueBars);
  }

  /// setExtendedLayoutIncludesOpaqueBars:
  set extendedLayoutIncludesOpaqueBars(bool value) {
    objc.checkOsVersionInternal('UIViewController.setExtendedLayoutIncludesOpaqueBars:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setExtendedLayoutIncludesOpaqueBars_, value);
  }

  /// automaticallyAdjustsScrollViewInsets
  bool get automaticallyAdjustsScrollViewInsets {
    objc.checkOsVersionInternal('UIViewController.automaticallyAdjustsScrollViewInsets', iOS: (false, (7, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_automaticallyAdjustsScrollViewInsets);
  }

  /// setAutomaticallyAdjustsScrollViewInsets:
  set automaticallyAdjustsScrollViewInsets(bool value) {
    objc.checkOsVersionInternal('UIViewController.setAutomaticallyAdjustsScrollViewInsets:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setAutomaticallyAdjustsScrollViewInsets_, value);
  }

  /// Aggregate values (e.g., NSDirectionalRectEdgeAll) are accepted in the `edge` parameter; NSDirectionalRectEdgeLeading and Trailing are ignored on iOS 15.0
  void setContentScrollView(UIScrollView? scrollView, {required NSDirectionalRectEdge forEdge}) {
    objc.checkOsVersionInternal('UIViewController.setContentScrollView:forEdge:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_13y7vr7(
      this.ref.pointer,
      _sel_setContentScrollView_forEdge_,
      scrollView?.ref.pointer ?? ffi.nullptr,
      forEdge.value,
    );
  }

  /// Pass only a single edge (e.g., NSDirectionalRectEdgeTop) in the `edge` parameter. Raises an exception when passed an aggregate edge (e.g., NSDirectionalRectEdgeAll)
  UIScrollView? contentScrollViewForEdge(NSDirectionalRectEdge edge) {
    objc.checkOsVersionInternal('UIViewController.contentScrollViewForEdge:', iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_kh1gvt(this.ref.pointer, _sel_contentScrollViewForEdge_, edge.value);
    return _ret.address == 0 ? null : UIScrollView.castFromPointer(_ret, retain: true, release: true);
  }

  /// preferredContentSize
  objc.CGSize get preferredContentSize {
    objc.checkOsVersionInternal('UIViewController.preferredContentSize', iOS: (false, (8, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1vdfkenStret(_ptr, this.ref.pointer, _sel_preferredContentSize)
        : _ptr.ref = _objc_msgSend_1vdfken(this.ref.pointer, _sel_preferredContentSize);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// setPreferredContentSize:
  set preferredContentSize$1(objc.CGSize value) {
    objc.checkOsVersionInternal('UIViewController.setPreferredContentSize:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_13lgpwz(this.ref.pointer, _sel_setPreferredContentSize_, value);
  }

  /// preferredStatusBarStyle
  UIStatusBarStyle get preferredStatusBarStyle {
    objc.checkOsVersionInternal('UIViewController.preferredStatusBarStyle', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_czyja3(this.ref.pointer, _sel_preferredStatusBarStyle);
    return UIStatusBarStyle.fromValue(_ret);
  }

  /// prefersStatusBarHidden
  bool get prefersStatusBarHidden {
    objc.checkOsVersionInternal('UIViewController.prefersStatusBarHidden', iOS: (false, (7, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_prefersStatusBarHidden);
  }

  /// preferredStatusBarUpdateAnimation
  UIStatusBarAnimation get preferredStatusBarUpdateAnimation {
    objc.checkOsVersionInternal('UIViewController.preferredStatusBarUpdateAnimation', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_14wdvus(this.ref.pointer, _sel_preferredStatusBarUpdateAnimation);
    return UIStatusBarAnimation.fromValue(_ret);
  }

  /// setNeedsStatusBarAppearanceUpdate
  void setNeedsStatusBarAppearanceUpdate() {
    objc.checkOsVersionInternal('UIViewController.setNeedsStatusBarAppearanceUpdate', iOS: (false, (7, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsStatusBarAppearanceUpdate);
  }

  /// targetViewControllerForAction:sender:
  UIViewController? targetViewControllerForAction(
    ffi.Pointer<objc.ObjCSelector> action, {
    objc.ObjCObjectBase? sender,
  }) {
    objc.checkOsVersionInternal('UIViewController.targetViewControllerForAction:sender:', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_gx50so(
      this.ref.pointer,
      _sel_targetViewControllerForAction_sender_,
      action,
      sender?.ref.pointer ?? ffi.nullptr,
    );
    return _ret.address == 0 ? null : UIViewController.castFromPointer(_ret, retain: true, release: true);
  }

  /// showViewController:sender:
  void showViewController(UIViewController vc, {objc.ObjCObjectBase? sender}) {
    objc.checkOsVersionInternal('UIViewController.showViewController:sender:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_showViewController_sender_,
      vc.ref.pointer,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// showDetailViewController:sender:
  void showDetailViewController(UIViewController vc, {objc.ObjCObjectBase? sender}) {
    objc.checkOsVersionInternal('UIViewController.showDetailViewController:sender:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_showDetailViewController_sender_,
      vc.ref.pointer,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// preferredUserInterfaceStyle
  UIUserInterfaceStyle get preferredUserInterfaceStyle {
    objc.checkOsVersionInternal('UIViewController.preferredUserInterfaceStyle', iOS: (true, null));
    final _ret = _objc_msgSend_2x5ago(this.ref.pointer, _sel_preferredUserInterfaceStyle);
    return UIUserInterfaceStyle.fromValue(_ret);
  }

  /// setNeedsUserInterfaceAppearanceUpdate
  void setNeedsUserInterfaceAppearanceUpdate() {
    objc.checkOsVersionInternal('UIViewController.setNeedsUserInterfaceAppearanceUpdate', iOS: (true, null));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsUserInterfaceAppearanceUpdate);
  }

  /// overrideUserInterfaceStyle
  UIUserInterfaceStyle get overrideUserInterfaceStyle {
    objc.checkOsVersionInternal('UIViewController.overrideUserInterfaceStyle', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_2x5ago(this.ref.pointer, _sel_overrideUserInterfaceStyle);
    return UIUserInterfaceStyle.fromValue(_ret);
  }

  /// setOverrideUserInterfaceStyle:
  set overrideUserInterfaceStyle(UIUserInterfaceStyle value) {
    objc.checkOsVersionInternal('UIViewController.setOverrideUserInterfaceStyle:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_15dz1ky(this.ref.pointer, _sel_setOverrideUserInterfaceStyle_, value.value);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// traitCollection
  UITraitCollection get traitCollection {
    objc.checkOsVersionInternal('UIViewController.traitCollection', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_traitCollection);
    return UITraitCollection.castFromPointer(_ret, retain: true, release: true);
  }

  /// ! To be overridden as needed to provide custom behavior when the environment's traits change.
  void traitCollectionDidChange(UITraitCollection? previousTraitCollection) {
    objc.checkOsVersionInternal('UIViewController.traitCollectionDidChange:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(
      this.ref.pointer,
      _sel_traitCollectionDidChange_,
      previousTraitCollection?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// preferredContentSizeDidChangeForChildContentContainer:
  void preferredContentSizeDidChangeForChildContentContainer(UIContentContainer container) {
    objc.checkOsVersionInternal(
      'UIViewController.preferredContentSizeDidChangeForChildContentContainer:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      this.ref.pointer,
      _sel_preferredContentSizeDidChangeForChildContentContainer_,
      container.ref.pointer,
    );
  }

  /// systemLayoutFittingSizeDidChangeForChildContentContainer:
  void systemLayoutFittingSizeDidChangeForChildContentContainer(UIContentContainer container) {
    objc.checkOsVersionInternal(
      'UIViewController.systemLayoutFittingSizeDidChangeForChildContentContainer:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      this.ref.pointer,
      _sel_systemLayoutFittingSizeDidChangeForChildContentContainer_,
      container.ref.pointer,
    );
  }

  /// sizeForChildContentContainer:withParentContainerSize:
  objc.CGSize sizeForChildContentContainer(
    UIContentContainer container, {
    required objc.CGSize withParentContainerSize,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.sizeForChildContentContainer:withParentContainerSize:',
      iOS: (false, (8, 0, 0)),
    );
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_xq5db9Stret(
            _ptr,
            this.ref.pointer,
            _sel_sizeForChildContentContainer_withParentContainerSize_,
            container.ref.pointer,
            withParentContainerSize,
          )
        : _ptr.ref = _objc_msgSend_xq5db9(
            this.ref.pointer,
            _sel_sizeForChildContentContainer_withParentContainerSize_,
            container.ref.pointer,
            withParentContainerSize,
          );
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// viewWillTransitionToSize:withTransitionCoordinator:
  void viewWillTransitionToSize(
    objc.CGSize size, {
    required UIViewControllerTransitionCoordinator withTransitionCoordinator,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.viewWillTransitionToSize:withTransitionCoordinator:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_11tcc61(
      this.ref.pointer,
      _sel_viewWillTransitionToSize_withTransitionCoordinator_,
      size,
      withTransitionCoordinator.ref.pointer,
    );
  }

  /// willTransitionToTraitCollection:withTransitionCoordinator:
  void willTransitionToTraitCollection(
    UITraitCollection newCollection, {
    required UIViewControllerTransitionCoordinator withTransitionCoordinator,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.willTransitionToTraitCollection:withTransitionCoordinator:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_willTransitionToTraitCollection_withTransitionCoordinator_,
      newCollection.ref.pointer,
      withTransitionCoordinator.ref.pointer,
    );
  }

  /// The preferred focus environments define where to search for the default focused item in an environment, such as when focus updates programmatically.
  /// Starting from the target environment, each preferred focus environment is recursively searched in the order of the array until an eligible, focusable item is found.
  /// Preferred focus environments can include focusable and non-focusable items, in addition to non-item environments. Returning an empty array is equivalent to returning an array containing only 'self'.
  objc.NSArray get preferredFocusEnvironments {
    objc.checkOsVersionInternal('UIViewController.preferredFocusEnvironments', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_preferredFocusEnvironments);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// The parent focus environment of this environment, or nil if no parent exists.
  /// NOTE: If you implement this method, you must return a non-nil value for parent focus environment, otherwise your focus environment will not participate in focus interactions.
  UIFocusEnvironment? get parentFocusEnvironment {
    objc.checkOsVersionInternal('UIViewController.parentFocusEnvironment', iOS: (false, (12, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_parentFocusEnvironment);
    return _ret.address == 0 ? null : UIFocusEnvironment.castFromPointer(_ret, retain: true, release: true);
  }

  /// The container of any child focus items in this focus environment, or nil if no container exists.
  UIFocusItemContainer? get focusItemContainer {
    objc.checkOsVersionInternal('UIViewController.focusItemContainer', iOS: (false, (12, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_focusItemContainer);
    return _ret.address == 0 ? null : UIFocusItemContainer.castFromPointer(_ret, retain: true, release: true);
  }

  /// Marks this environment as needing a focus update, which if accepted will attempt to reset focus to this environment, or one of its preferred focus environments, on the next update cycle. If this environment does not currently contain the focused item, then calling this method has no effect. If a parent of this environment is also requesting focus, then this environment's request is rejected in favor of the parent's.
  /// NOTE: If you provide your own implementation, it must call `[[UIFocusSystem focusSystemForEnvironment:self] requestFocusUpdateToEnvironment:self]`;
  void setNeedsFocusUpdate() {
    objc.checkOsVersionInternal('UIViewController.setNeedsFocusUpdate', iOS: (false, (9, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsFocusUpdate);
  }

  /// Forces focus to be updated immediately. If there is an environment that has requested a focus update via -setNeedsFocusUpdate, and the request was accepted, then focus will be updated to that environment or one of its preferred focus environments.
  /// NOTE: If you provide your own implementation, it must call `[[UIFocusSystem focusSystemForEnvironment:self] updateFocusIfNeeded];`.
  void updateFocusIfNeeded() {
    objc.checkOsVersionInternal('UIViewController.updateFocusIfNeeded', iOS: (false, (9, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_updateFocusIfNeeded);
  }

  /// Asks whether the system should allow a focus update to occur.
  bool shouldUpdateFocusInContext(UIFocusUpdateContext context) {
    objc.checkOsVersionInternal('UIViewController.shouldUpdateFocusInContext:', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_19nvye5(this.ref.pointer, _sel_shouldUpdateFocusInContext_, context.ref.pointer);
  }

  /// Called when the screens focused item has been updated to a new item. Use the animation coordinator to schedule focus-related animations in response to the update.
  void didUpdateFocusInContext(
    UIFocusUpdateContext context, {
    required UIFocusAnimationCoordinator withAnimationCoordinator,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.didUpdateFocusInContext:withAnimationCoordinator:',
      iOS: (false, (9, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_didUpdateFocusInContext_withAnimationCoordinator_,
      context.ref.pointer,
      withAnimationCoordinator.ref.pointer,
    );
  }

  /// Specifies an identifier corresponding to a sound that should be played for a focus update.
  /// Return UIFocusSoundIdentifierNone to opt out of sounds, UIFocusSoundIdentifierDefault for the system
  /// default sounds, a previously registered identifier for a custom sound, or nil to defer the decision
  /// to the parent.
  objc.NSString? soundIdentifierForFocusUpdateInContext(UIFocusUpdateContext context) {
    objc.checkOsVersionInternal('UIViewController.soundIdentifierForFocusUpdateInContext:', iOS: (true, null));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_soundIdentifierForFocusUpdateInContext_)) {
      throw objc.UnimplementedOptionalMethodException('UIViewController', 'soundIdentifierForFocusUpdateInContext:');
    }
    final _ret = _objc_msgSend_1sotr3r(
      this.ref.pointer,
      _sel_soundIdentifierForFocusUpdateInContext_,
      context.ref.pointer,
    );
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// preferredFocusedView
  UIView? get preferredFocusedView {
    objc.checkOsVersionInternal('UIViewController.preferredFocusedView', iOS: (false, (9, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_preferredFocusedView)) {
      throw objc.UnimplementedOptionalMethodException('UIViewController', 'preferredFocusedView');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_preferredFocusedView);
    return _ret.address == 0 ? null : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// previewActionItems
  objc.NSArray get previewActionItems {
    objc.checkOsVersionInternal('UIViewController.previewActionItems', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_previewActionItems);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_rootViewController = objc.registerName("rootViewController");
late final _sel_setRootViewController_ = objc.registerName("setRootViewController:");
late final _sel_sendEvent_ = objc.registerName("sendEvent:");
late final _sel_convertPoint_toWindow_ = objc.registerName("convertPoint:toWindow:");
late final _sel_convertPoint_fromWindow_ = objc.registerName("convertPoint:fromWindow:");
late final _sel_convertRect_toWindow_ = objc.registerName("convertRect:toWindow:");
late final _sel_convertRect_fromWindow_ = objc.registerName("convertRect:fromWindow:");

/// UIWindow
class UIWindow extends UIView {
  UIWindow._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [UIWindow] that points to the same underlying object as [other].
  UIWindow.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIWindow] that wraps the given raw object pointer.
  UIWindow.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIWindow].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIWindow);
  }

  /// layerClass
  static objc.ObjCObjectBase getLayerClass() {
    objc.checkOsVersionInternal('UIWindow.layerClass', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIWindow, _sel_layerClass);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute(
    UISemanticContentAttribute attribute,
  ) {
    objc.checkOsVersionInternal(
      'UIWindow.userInterfaceLayoutDirectionForSemanticContentAttribute:',
      iOS: (false, (9, 0, 0)),
    );
    final _ret = _objc_msgSend_racczx(
      _class_UIWindow,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
      attribute.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute$1(
    UISemanticContentAttribute semanticContentAttribute, {
    required UIUserInterfaceLayoutDirection relativeToLayoutDirection,
  }) {
    objc.checkOsVersionInternal(
      'UIWindow.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
      iOS: (false, (10, 0, 0)),
    );
    final _ret = _objc_msgSend_tz4p54(
      _class_UIWindow,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
      semanticContentAttribute.value,
      relativeToLayoutDirection.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }
}

extension UIWindow$Methods on UIWindow {
  /// initWithWindowScene:
  UIWindow initWithWindowScene(UIWindowScene windowScene) {
    objc.checkOsVersionInternal('UIWindow.initWithWindowScene:', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
      this.ref.retainAndReturnPointer(),
      _sel_initWithWindowScene_,
      windowScene.ref.pointer,
    );
    return UIWindow.castFromPointer(_ret, retain: false, release: true);
  }

  /// windowScene
  UIWindowScene? get windowScene {
    objc.checkOsVersionInternal('UIWindow.windowScene', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_windowScene);
    return _ret.address == 0 ? null : UIWindowScene.castFromPointer(_ret, retain: true, release: true);
  }

  /// setWindowScene:
  set windowScene(UIWindowScene? value) {
    objc.checkOsVersionInternal('UIWindow.setWindowScene:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setWindowScene_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// canResizeToFitContent
  bool get canResizeToFitContent {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_canResizeToFitContent);
  }

  /// setCanResizeToFitContent:
  set canResizeToFitContent(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setCanResizeToFitContent_, value);
  }

  /// screen
  UIScreen get screen {
    objc.checkOsVersionInternal('UIWindow.screen', iOS: (false, (3, 2, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_screen);
    return UIScreen.castFromPointer(_ret, retain: true, release: true);
  }

  /// setScreen:
  set screen(UIScreen value) {
    objc.checkOsVersionInternal('UIWindow.setScreen:', iOS: (false, (3, 2, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setScreen_, value.ref.pointer);
  }

  /// windowLevel
  double get windowLevel {
    objc.checkOsVersionInternal('UIWindow.windowLevel', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_windowLevel)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_windowLevel);
  }

  /// setWindowLevel:
  set windowLevel(double value) {
    objc.checkOsVersionInternal('UIWindow.setWindowLevel:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setWindowLevel_, value);
  }

  /// isKeyWindow
  bool get keyWindow {
    objc.checkOsVersionInternal('UIWindow.isKeyWindow', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isKeyWindow);
  }

  /// canBecomeKeyWindow
  bool get canBecomeKeyWindow {
    objc.checkOsVersionInternal('UIWindow.canBecomeKeyWindow', iOS: (false, (15, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_canBecomeKeyWindow);
  }

  /// becomeKeyWindow
  void becomeKeyWindow() {
    objc.checkOsVersionInternal('UIWindow.becomeKeyWindow', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_becomeKeyWindow);
  }

  /// resignKeyWindow
  void resignKeyWindow() {
    objc.checkOsVersionInternal('UIWindow.resignKeyWindow', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_resignKeyWindow);
  }

  /// makeKeyWindow
  void makeKeyWindow() {
    objc.checkOsVersionInternal('UIWindow.makeKeyWindow', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_makeKeyWindow);
  }

  /// makeKeyAndVisible
  void makeKeyAndVisible() {
    objc.checkOsVersionInternal('UIWindow.makeKeyAndVisible', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_makeKeyAndVisible);
  }

  /// rootViewController
  UIViewController? get rootViewController {
    objc.checkOsVersionInternal('UIWindow.rootViewController', iOS: (false, (4, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_rootViewController);
    return _ret.address == 0 ? null : UIViewController.castFromPointer(_ret, retain: true, release: true);
  }

  /// setRootViewController:
  set rootViewController(UIViewController? value) {
    objc.checkOsVersionInternal('UIWindow.setRootViewController:', iOS: (false, (4, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setRootViewController_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// sendEvent:
  void sendEvent(UIEvent event) {
    objc.checkOsVersionInternal('UIWindow.sendEvent:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_sendEvent_, event.ref.pointer);
  }

  /// convertPoint:toWindow:
  objc.CGPoint convertPoint(objc.CGPoint point, {UIWindow? toWindow}) {
    objc.checkOsVersionInternal('UIWindow.convertPoint:toWindow:', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            _ptr,
            this.ref.pointer,
            _sel_convertPoint_toWindow_,
            point,
            toWindow?.ref.pointer ?? ffi.nullptr,
          )
        : _ptr.ref = _objc_msgSend_3l1tu1(
            this.ref.pointer,
            _sel_convertPoint_toWindow_,
            point,
            toWindow?.ref.pointer ?? ffi.nullptr,
          );
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// convertPoint:fromWindow:
  objc.CGPoint convertPoint$1(objc.CGPoint point, {UIWindow? fromWindow}) {
    objc.checkOsVersionInternal('UIWindow.convertPoint:fromWindow:', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            _ptr,
            this.ref.pointer,
            _sel_convertPoint_fromWindow_,
            point,
            fromWindow?.ref.pointer ?? ffi.nullptr,
          )
        : _ptr.ref = _objc_msgSend_3l1tu1(
            this.ref.pointer,
            _sel_convertPoint_fromWindow_,
            point,
            fromWindow?.ref.pointer ?? ffi.nullptr,
          );
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// convertRect:toWindow:
  objc.CGRect convertRect(objc.CGRect rect, {UIWindow? toWindow}) {
    objc.checkOsVersionInternal('UIWindow.convertRect:toWindow:', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            _ptr,
            this.ref.pointer,
            _sel_convertRect_toWindow_,
            rect,
            toWindow?.ref.pointer ?? ffi.nullptr,
          )
        : _ptr.ref = _objc_msgSend_2olghr(
            this.ref.pointer,
            _sel_convertRect_toWindow_,
            rect,
            toWindow?.ref.pointer ?? ffi.nullptr,
          );
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// convertRect:fromWindow:
  objc.CGRect convertRect$1(objc.CGRect rect, {UIWindow? fromWindow}) {
    objc.checkOsVersionInternal('UIWindow.convertRect:fromWindow:', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            _ptr,
            this.ref.pointer,
            _sel_convertRect_fromWindow_,
            rect,
            fromWindow?.ref.pointer ?? ffi.nullptr,
          )
        : _ptr.ref = _objc_msgSend_2olghr(
            this.ref.pointer,
            _sel_convertRect_fromWindow_,
            rect,
            fromWindow?.ref.pointer ?? ffi.nullptr,
          );
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// initWithFrame:
  UIWindow initWithFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal('UIWindow.initWithFrame:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_15yz4e6(this.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return UIWindow.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIWindow? initWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal('UIWindow.initWithCoder:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0 ? null : UIWindow.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _sel_window = objc.registerName("window");
late final _sel_removeFromSuperview = objc.registerName("removeFromSuperview");
late final _sel_insertSubview_atIndex_ = objc.registerName("insertSubview:atIndex:");
final _objc_msgSend_1nvl641 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>, int)
    >();
late final _sel_exchangeSubviewAtIndex_withSubviewAtIndex_ = objc.registerName(
  "exchangeSubviewAtIndex:withSubviewAtIndex:",
);
final _objc_msgSend_1w5k0al = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long, ffi.Long)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int, int)>();
late final _sel_addSubview_ = objc.registerName("addSubview:");
late final _sel_insertSubview_belowSubview_ = objc.registerName("insertSubview:belowSubview:");
late final _sel_insertSubview_aboveSubview_ = objc.registerName("insertSubview:aboveSubview:");
late final _sel_bringSubviewToFront_ = objc.registerName("bringSubviewToFront:");
late final _sel_sendSubviewToBack_ = objc.registerName("sendSubviewToBack:");
late final _sel_didAddSubview_ = objc.registerName("didAddSubview:");
late final _sel_willRemoveSubview_ = objc.registerName("willRemoveSubview:");
late final _sel_willMoveToSuperview_ = objc.registerName("willMoveToSuperview:");
late final _sel_didMoveToSuperview = objc.registerName("didMoveToSuperview");
late final _sel_willMoveToWindow_ = objc.registerName("willMoveToWindow:");
late final _sel_didMoveToWindow = objc.registerName("didMoveToWindow");
late final _sel_isDescendantOfView_ = objc.registerName("isDescendantOfView:");
late final _sel_viewWithTag_ = objc.registerName("viewWithTag:");
final _objc_msgSend_qugqlf = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)
    >();
late final _sel_setNeedsLayout = objc.registerName("setNeedsLayout");
late final _sel_layoutIfNeeded = objc.registerName("layoutIfNeeded");
late final _sel_layoutSubviews = objc.registerName("layoutSubviews");
late final _sel_layoutMargins = objc.registerName("layoutMargins");
late final _sel_setLayoutMargins_ = objc.registerName("setLayoutMargins:");
late final _sel_directionalLayoutMargins = objc.registerName("directionalLayoutMargins");
late final _sel_setDirectionalLayoutMargins_ = objc.registerName("setDirectionalLayoutMargins:");
final _objc_msgSend_s0isf8 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, NSDirectionalEdgeInsets)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, NSDirectionalEdgeInsets)>();
late final _sel_preservesSuperviewLayoutMargins = objc.registerName("preservesSuperviewLayoutMargins");
late final _sel_setPreservesSuperviewLayoutMargins_ = objc.registerName("setPreservesSuperviewLayoutMargins:");
late final _sel_insetsLayoutMarginsFromSafeArea = objc.registerName("insetsLayoutMarginsFromSafeArea");
late final _sel_setInsetsLayoutMarginsFromSafeArea_ = objc.registerName("setInsetsLayoutMarginsFromSafeArea:");
late final _sel_layoutMarginsDidChange = objc.registerName("layoutMarginsDidChange");
late final _sel_safeAreaInsets = objc.registerName("safeAreaInsets");
late final _sel_safeAreaInsetsDidChange = objc.registerName("safeAreaInsetsDidChange");
late final _sel_layoutMarginsGuide = objc.registerName("layoutMarginsGuide");
late final _sel_readableContentGuide = objc.registerName("readableContentGuide");
late final _sel_safeAreaLayoutGuide = objc.registerName("safeAreaLayoutGuide");

/// WARNING: UIKeyboardLayoutGuide is a stub. To generate bindings for this class, include
/// UIKeyboardLayoutGuide in your config's objc-interfaces list.
///
/// UIKeyboardLayoutGuide
class UIKeyboardLayoutGuide extends objc.ObjCObjectBase {
  UIKeyboardLayoutGuide._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIKeyboardLayoutGuide] that points to the same underlying object as [other].
  UIKeyboardLayoutGuide.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIKeyboardLayoutGuide] that wraps the given raw object pointer.
  UIKeyboardLayoutGuide.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_keyboardLayoutGuide = objc.registerName("keyboardLayoutGuide");

/// UIViewHierarchy
extension UIViewHierarchy on UIView {
  /// superview
  UIView? get superview {
    objc.checkOsVersionInternal('UIView.superview', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_superview);
    return _ret.address == 0 ? null : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// subviews
  objc.NSArray get subviews {
    objc.checkOsVersionInternal('UIView.subviews', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subviews);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// window
  UIWindow? get window {
    objc.checkOsVersionInternal('UIView.window', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_window);
    return _ret.address == 0 ? null : UIWindow.castFromPointer(_ret, retain: true, release: true);
  }

  /// removeFromSuperview
  void removeFromSuperview() {
    objc.checkOsVersionInternal('UIView.removeFromSuperview', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_removeFromSuperview);
  }

  /// insertSubview:atIndex:
  void insertSubview(UIView view, {required int atIndex}) {
    objc.checkOsVersionInternal('UIView.insertSubview:atIndex:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1nvl641(this.ref.pointer, _sel_insertSubview_atIndex_, view.ref.pointer, atIndex);
  }

  /// exchangeSubviewAtIndex:withSubviewAtIndex:
  void exchangeSubviewAtIndex(int index1, {required int withSubviewAtIndex}) {
    objc.checkOsVersionInternal('UIView.exchangeSubviewAtIndex:withSubviewAtIndex:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1w5k0al(
      this.ref.pointer,
      _sel_exchangeSubviewAtIndex_withSubviewAtIndex_,
      index1,
      withSubviewAtIndex,
    );
  }

  /// addSubview:
  void addSubview(UIView view) {
    objc.checkOsVersionInternal('UIView.addSubview:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addSubview_, view.ref.pointer);
  }

  /// insertSubview:belowSubview:
  void insertSubview$1(UIView view, {required UIView belowSubview}) {
    objc.checkOsVersionInternal('UIView.insertSubview:belowSubview:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_insertSubview_belowSubview_,
      view.ref.pointer,
      belowSubview.ref.pointer,
    );
  }

  /// insertSubview:aboveSubview:
  void insertSubview$2(UIView view, {required UIView aboveSubview}) {
    objc.checkOsVersionInternal('UIView.insertSubview:aboveSubview:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_insertSubview_aboveSubview_,
      view.ref.pointer,
      aboveSubview.ref.pointer,
    );
  }

  /// bringSubviewToFront:
  void bringSubviewToFront(UIView view) {
    objc.checkOsVersionInternal('UIView.bringSubviewToFront:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_bringSubviewToFront_, view.ref.pointer);
  }

  /// sendSubviewToBack:
  void sendSubviewToBack(UIView view) {
    objc.checkOsVersionInternal('UIView.sendSubviewToBack:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_sendSubviewToBack_, view.ref.pointer);
  }

  /// didAddSubview:
  void didAddSubview(UIView subview) {
    objc.checkOsVersionInternal('UIView.didAddSubview:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_didAddSubview_, subview.ref.pointer);
  }

  /// willRemoveSubview:
  void willRemoveSubview(UIView subview) {
    objc.checkOsVersionInternal('UIView.willRemoveSubview:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_willRemoveSubview_, subview.ref.pointer);
  }

  /// willMoveToSuperview:
  void willMoveToSuperview(UIView? newSuperview) {
    objc.checkOsVersionInternal('UIView.willMoveToSuperview:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_willMoveToSuperview_, newSuperview?.ref.pointer ?? ffi.nullptr);
  }

  /// didMoveToSuperview
  void didMoveToSuperview() {
    objc.checkOsVersionInternal('UIView.didMoveToSuperview', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_didMoveToSuperview);
  }

  /// willMoveToWindow:
  void willMoveToWindow(UIWindow? newWindow) {
    objc.checkOsVersionInternal('UIView.willMoveToWindow:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_willMoveToWindow_, newWindow?.ref.pointer ?? ffi.nullptr);
  }

  /// didMoveToWindow
  void didMoveToWindow() {
    objc.checkOsVersionInternal('UIView.didMoveToWindow', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_didMoveToWindow);
  }

  /// isDescendantOfView:
  bool isDescendantOfView(UIView view) {
    objc.checkOsVersionInternal('UIView.isDescendantOfView:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_19nvye5(this.ref.pointer, _sel_isDescendantOfView_, view.ref.pointer);
  }

  /// viewWithTag:
  UIView? viewWithTag(int tag) {
    objc.checkOsVersionInternal('UIView.viewWithTag:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_qugqlf(this.ref.pointer, _sel_viewWithTag_, tag);
    return _ret.address == 0 ? null : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// setNeedsLayout
  void setNeedsLayout() {
    objc.checkOsVersionInternal('UIView.setNeedsLayout', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsLayout);
  }

  /// layoutIfNeeded
  void layoutIfNeeded() {
    objc.checkOsVersionInternal('UIView.layoutIfNeeded', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_layoutIfNeeded);
  }

  /// layoutSubviews
  void layoutSubviews() {
    objc.checkOsVersionInternal('UIView.layoutSubviews', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_layoutSubviews);
  }

  /// layoutMargins
  UIEdgeInsets get layoutMargins {
    objc.checkOsVersionInternal('UIView.layoutMargins', iOS: (false, (8, 0, 0)));
    final _ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(_ptr, this.ref.pointer, _sel_layoutMargins)
        : _ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_layoutMargins);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>(_finalizable);
  }

  /// setLayoutMargins:
  set layoutMargins(UIEdgeInsets value) {
    objc.checkOsVersionInternal('UIView.setLayoutMargins:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_1g8fos5(this.ref.pointer, _sel_setLayoutMargins_, value);
  }

  /// directionalLayoutMargins
  NSDirectionalEdgeInsets get directionalLayoutMargins {
    objc.checkOsVersionInternal('UIView.directionalLayoutMargins', iOS: (false, (11, 0, 0)));
    final _ptr = pkg_ffi.calloc<NSDirectionalEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_12yjd2mStret(_ptr, this.ref.pointer, _sel_directionalLayoutMargins)
        : _ptr.ref = _objc_msgSend_12yjd2m(this.ref.pointer, _sel_directionalLayoutMargins);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<NSDirectionalEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<NSDirectionalEdgeInsets>(_finalizable);
  }

  /// setDirectionalLayoutMargins:
  set directionalLayoutMargins(NSDirectionalEdgeInsets value) {
    objc.checkOsVersionInternal('UIView.setDirectionalLayoutMargins:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_s0isf8(this.ref.pointer, _sel_setDirectionalLayoutMargins_, value);
  }

  /// preservesSuperviewLayoutMargins
  bool get preservesSuperviewLayoutMargins {
    objc.checkOsVersionInternal('UIView.preservesSuperviewLayoutMargins', iOS: (false, (8, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_preservesSuperviewLayoutMargins);
  }

  /// setPreservesSuperviewLayoutMargins:
  set preservesSuperviewLayoutMargins(bool value) {
    objc.checkOsVersionInternal('UIView.setPreservesSuperviewLayoutMargins:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setPreservesSuperviewLayoutMargins_, value);
  }

  /// insetsLayoutMarginsFromSafeArea
  bool get insetsLayoutMarginsFromSafeArea {
    objc.checkOsVersionInternal('UIView.insetsLayoutMarginsFromSafeArea', iOS: (false, (11, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_insetsLayoutMarginsFromSafeArea);
  }

  /// setInsetsLayoutMarginsFromSafeArea:
  set insetsLayoutMarginsFromSafeArea(bool value) {
    objc.checkOsVersionInternal('UIView.setInsetsLayoutMarginsFromSafeArea:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setInsetsLayoutMarginsFromSafeArea_, value);
  }

  /// layoutMarginsDidChange
  void layoutMarginsDidChange() {
    objc.checkOsVersionInternal('UIView.layoutMarginsDidChange', iOS: (false, (8, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_layoutMarginsDidChange);
  }

  /// safeAreaInsets
  UIEdgeInsets get safeAreaInsets {
    objc.checkOsVersionInternal('UIView.safeAreaInsets', iOS: (false, (11, 0, 0)));
    final _ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(_ptr, this.ref.pointer, _sel_safeAreaInsets)
        : _ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_safeAreaInsets);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>(_finalizable);
  }

  /// safeAreaInsetsDidChange
  void safeAreaInsetsDidChange() {
    objc.checkOsVersionInternal('UIView.safeAreaInsetsDidChange', iOS: (false, (11, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_safeAreaInsetsDidChange);
  }

  /// layoutMarginsGuide
  UILayoutGuide get layoutMarginsGuide {
    objc.checkOsVersionInternal('UIView.layoutMarginsGuide', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_layoutMarginsGuide);
    return UILayoutGuide.castFromPointer(_ret, retain: true, release: true);
  }

  /// This content guide provides a layout area that you can use to place text and related content whose width should generally be constrained to a size that is easy for the user to read. This guide provides a centered region that you can place content within to get this behavior for this view.
  UILayoutGuide get readableContentGuide {
    objc.checkOsVersionInternal('UIView.readableContentGuide', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_readableContentGuide);
    return UILayoutGuide.castFromPointer(_ret, retain: true, release: true);
  }

  /// safeAreaLayoutGuide
  UILayoutGuide get safeAreaLayoutGuide {
    objc.checkOsVersionInternal('UIView.safeAreaLayoutGuide', iOS: (false, (11, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_safeAreaLayoutGuide);
    return UILayoutGuide.castFromPointer(_ret, retain: true, release: true);
  }

  /// Follows the keyboard when on screen and docked. When the keyboard is offscreen or undocked, keyboardLayoutGuide.topAnchor matches the view's safeAreaLayoutGuide.bottomAnchor.
  UIKeyboardLayoutGuide get keyboardLayoutGuide {
    objc.checkOsVersionInternal('UIView.keyboardLayoutGuide', iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_keyboardLayoutGuide);
    return UIKeyboardLayoutGuide.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_drawRect_ = objc.registerName("drawRect:");
late final _sel_setNeedsDisplay = objc.registerName("setNeedsDisplay");
late final _sel_setNeedsDisplayInRect_ = objc.registerName("setNeedsDisplayInRect:");
late final _sel_clipsToBounds = objc.registerName("clipsToBounds");
late final _sel_setClipsToBounds_ = objc.registerName("setClipsToBounds:");
late final _sel_backgroundColor = objc.registerName("backgroundColor");
late final _sel_setBackgroundColor_ = objc.registerName("setBackgroundColor:");
late final _sel_alpha = objc.registerName("alpha");
late final _sel_setAlpha_ = objc.registerName("setAlpha:");
late final _sel_isOpaque = objc.registerName("isOpaque");
late final _sel_setOpaque_ = objc.registerName("setOpaque:");
late final _sel_clearsContextBeforeDrawing = objc.registerName("clearsContextBeforeDrawing");
late final _sel_setClearsContextBeforeDrawing_ = objc.registerName("setClearsContextBeforeDrawing:");
late final _sel_isHidden = objc.registerName("isHidden");
late final _sel_setHidden_ = objc.registerName("setHidden:");

enum UIViewContentMode {
  UIViewContentModeScaleToFill(0),
  UIViewContentModeScaleAspectFit(1),
  UIViewContentModeScaleAspectFill(2),
  UIViewContentModeRedraw(3),
  UIViewContentModeCenter(4),
  UIViewContentModeTop(5),
  UIViewContentModeBottom(6),
  UIViewContentModeLeft(7),
  UIViewContentModeRight(8),
  UIViewContentModeTopLeft(9),
  UIViewContentModeTopRight(10),
  UIViewContentModeBottomLeft(11),
  UIViewContentModeBottomRight(12);

  final int value;
  const UIViewContentMode(this.value);

  static UIViewContentMode fromValue(int value) => switch (value) {
    0 => UIViewContentModeScaleToFill,
    1 => UIViewContentModeScaleAspectFit,
    2 => UIViewContentModeScaleAspectFill,
    3 => UIViewContentModeRedraw,
    4 => UIViewContentModeCenter,
    5 => UIViewContentModeTop,
    6 => UIViewContentModeBottom,
    7 => UIViewContentModeLeft,
    8 => UIViewContentModeRight,
    9 => UIViewContentModeTopLeft,
    10 => UIViewContentModeTopRight,
    11 => UIViewContentModeBottomLeft,
    12 => UIViewContentModeBottomRight,
    _ => throw ArgumentError('Unknown value for UIViewContentMode: $value'),
  };
}

late final _sel_contentMode = objc.registerName("contentMode");
final _objc_msgSend_12r2l30 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setContentMode_ = objc.registerName("setContentMode:");
final _objc_msgSend_26z7iq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_contentStretch = objc.registerName("contentStretch");
late final _sel_setContentStretch_ = objc.registerName("setContentStretch:");
late final _sel_maskView = objc.registerName("maskView");
late final _sel_setMaskView_ = objc.registerName("setMaskView:");

enum UIViewTintAdjustmentMode {
  UIViewTintAdjustmentModeAutomatic(0),
  UIViewTintAdjustmentModeNormal(1),
  UIViewTintAdjustmentModeDimmed(2);

  final int value;
  const UIViewTintAdjustmentMode(this.value);

  static UIViewTintAdjustmentMode fromValue(int value) => switch (value) {
    0 => UIViewTintAdjustmentModeAutomatic,
    1 => UIViewTintAdjustmentModeNormal,
    2 => UIViewTintAdjustmentModeDimmed,
    _ => throw ArgumentError('Unknown value for UIViewTintAdjustmentMode: $value'),
  };
}

late final _sel_tintAdjustmentMode = objc.registerName("tintAdjustmentMode");
final _objc_msgSend_1tlsbkb = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTintAdjustmentMode_ = objc.registerName("setTintAdjustmentMode:");
final _objc_msgSend_15t6owj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_tintColorDidChange = objc.registerName("tintColorDidChange");

/// UIViewRendering
extension UIViewRendering on UIView {
  /// drawRect:
  void drawRect(objc.CGRect rect) {
    objc.checkOsVersionInternal('UIView.drawRect:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1okkq16(this.ref.pointer, _sel_drawRect_, rect);
  }

  /// setNeedsDisplay
  void setNeedsDisplay() {
    objc.checkOsVersionInternal('UIView.setNeedsDisplay', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsDisplay);
  }

  /// setNeedsDisplayInRect:
  void setNeedsDisplayInRect(objc.CGRect rect) {
    objc.checkOsVersionInternal('UIView.setNeedsDisplayInRect:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1okkq16(this.ref.pointer, _sel_setNeedsDisplayInRect_, rect);
  }

  /// clipsToBounds
  bool get clipsToBounds {
    objc.checkOsVersionInternal('UIView.clipsToBounds', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_clipsToBounds);
  }

  /// setClipsToBounds:
  set clipsToBounds(bool value) {
    objc.checkOsVersionInternal('UIView.setClipsToBounds:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setClipsToBounds_, value);
  }

  /// backgroundColor
  UIColor? get backgroundColor {
    objc.checkOsVersionInternal('UIView.backgroundColor', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_backgroundColor);
    return _ret.address == 0 ? null : UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// setBackgroundColor:
  set backgroundColor(UIColor? value) {
    objc.checkOsVersionInternal('UIView.setBackgroundColor:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setBackgroundColor_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// alpha
  double get alpha {
    objc.checkOsVersionInternal('UIView.alpha', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_alpha)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_alpha);
  }

  /// setAlpha:
  set alpha(double value) {
    objc.checkOsVersionInternal('UIView.setAlpha:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setAlpha_, value);
  }

  /// isOpaque
  bool get opaque {
    objc.checkOsVersionInternal('UIView.isOpaque', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isOpaque);
  }

  /// setOpaque:
  set opaque(bool value) {
    objc.checkOsVersionInternal('UIView.setOpaque:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setOpaque_, value);
  }

  /// clearsContextBeforeDrawing
  bool get clearsContextBeforeDrawing {
    objc.checkOsVersionInternal('UIView.clearsContextBeforeDrawing', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_clearsContextBeforeDrawing);
  }

  /// setClearsContextBeforeDrawing:
  set clearsContextBeforeDrawing(bool value) {
    objc.checkOsVersionInternal('UIView.setClearsContextBeforeDrawing:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setClearsContextBeforeDrawing_, value);
  }

  /// isHidden
  bool get hidden {
    objc.checkOsVersionInternal('UIView.isHidden', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isHidden);
  }

  /// setHidden:
  set hidden(bool value) {
    objc.checkOsVersionInternal('UIView.setHidden:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHidden_, value);
  }

  /// contentMode
  UIViewContentMode get contentMode {
    objc.checkOsVersionInternal('UIView.contentMode', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_12r2l30(this.ref.pointer, _sel_contentMode);
    return UIViewContentMode.fromValue(_ret);
  }

  /// setContentMode:
  set contentMode(UIViewContentMode value) {
    objc.checkOsVersionInternal('UIView.setContentMode:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_26z7iq(this.ref.pointer, _sel_setContentMode_, value.value);
  }

  /// contentStretch
  objc.CGRect get contentStretch {
    objc.checkOsVersionInternal('UIView.contentStretch', iOS: (false, (3, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(_ptr, this.ref.pointer, _sel_contentStretch)
        : _ptr.ref = _objc_msgSend_bu1hbw(this.ref.pointer, _sel_contentStretch);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// setContentStretch:
  set contentStretch(objc.CGRect value) {
    objc.checkOsVersionInternal('UIView.setContentStretch:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_1okkq16(this.ref.pointer, _sel_setContentStretch_, value);
  }

  /// maskView
  UIView? get maskView {
    objc.checkOsVersionInternal('UIView.maskView', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_maskView);
    return _ret.address == 0 ? null : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// setMaskView:
  set maskView(UIView? value) {
    objc.checkOsVersionInternal('UIView.setMaskView:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setMaskView_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// tintColor
  UIColor get tintColor {
    objc.checkOsVersionInternal('UIView.tintColor', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_tintColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTintColor:
  set tintColor(UIColor value) {
    objc.checkOsVersionInternal('UIView.setTintColor:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTintColor_, value.ref.pointer);
  }

  /// tintAdjustmentMode
  UIViewTintAdjustmentMode get tintAdjustmentMode {
    objc.checkOsVersionInternal('UIView.tintAdjustmentMode', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_1tlsbkb(this.ref.pointer, _sel_tintAdjustmentMode);
    return UIViewTintAdjustmentMode.fromValue(_ret);
  }

  /// setTintAdjustmentMode:
  set tintAdjustmentMode(UIViewTintAdjustmentMode value) {
    objc.checkOsVersionInternal('UIView.setTintAdjustmentMode:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_15t6owj(this.ref.pointer, _sel_setTintAdjustmentMode_, value.value);
  }

  /// tintColorDidChange
  void tintColorDidChange() {
    objc.checkOsVersionInternal('UIView.tintColorDidChange', iOS: (false, (7, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_tintColorDidChange);
  }
}

late final _sel_setAnimationsEnabled_ = objc.registerName("setAnimationsEnabled:");
late final _sel_areAnimationsEnabled = objc.registerName("areAnimationsEnabled");
late final _sel_performWithoutAnimation_ = objc.registerName("performWithoutAnimation:");
final _objc_msgSend_f167m6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCBlockImpl>)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCBlockImpl>)
    >();
late final _sel_inheritedAnimationDuration = objc.registerName("inheritedAnimationDuration");

/// UIViewAnimation
extension UIViewAnimation on UIView {
  /// setAnimationsEnabled:
  static void setAnimationsEnabled(bool enabled) {
    objc.checkOsVersionInternal('UIView.setAnimationsEnabled:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(_class_UIView, _sel_setAnimationsEnabled_, enabled);
  }

  /// areAnimationsEnabled
  static bool getAreAnimationsEnabled() {
    objc.checkOsVersionInternal('UIView.areAnimationsEnabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(_class_UIView, _sel_areAnimationsEnabled);
  }

  /// performWithoutAnimation:
  static void performWithoutAnimation(objc.ObjCBlock<ffi.Void Function()> actionsWithoutAnimation) {
    objc.checkOsVersionInternal('UIView.performWithoutAnimation:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_f167m6(_class_UIView, _sel_performWithoutAnimation_, actionsWithoutAnimation.ref.pointer);
  }

  /// inheritedAnimationDuration
  static double getInheritedAnimationDuration() {
    objc.checkOsVersionInternal('UIView.inheritedAnimationDuration', iOS: (false, (9, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(_class_UIView, _sel_inheritedAnimationDuration)
        : _objc_msgSend_1ukqyt8(_class_UIView, _sel_inheritedAnimationDuration);
  }
}

late final _sel_animateWithDuration_delay_options_animations_completion_ = objc.registerName(
  "animateWithDuration:delay:options:animations:completion:",
);
final _objc_msgSend_1pforg = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        double,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_animateWithDuration_animations_completion_ = objc.registerName(
  "animateWithDuration:animations:completion:",
);
final _objc_msgSend_1isavsq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_animateWithDuration_animations_ = objc.registerName("animateWithDuration:animations:");
final _objc_msgSend_16dy26p = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_animateWithDuration_delay_usingSpringWithDamping_initialSpringVelocity_options_animations_completion_ =
    objc.registerName(
      "animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:",
    );
final _objc_msgSend_r4l13g = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Double,
          ffi.Double,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        double,
        double,
        double,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_transitionWithView_duration_options_animations_completion_ = objc.registerName(
  "transitionWithView:duration:options:animations:completion:",
);
final _objc_msgSend_q6v4dl = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        double,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_transitionFromView_toView_duration_options_completion_ = objc.registerName(
  "transitionFromView:toView:duration:options:completion:",
);
final _objc_msgSend_1eh0loo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        double,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

enum UISystemAnimation {
  UISystemAnimationDelete(0);

  final int value;
  const UISystemAnimation(this.value);

  static UISystemAnimation fromValue(int value) => switch (value) {
    0 => UISystemAnimationDelete,
    _ => throw ArgumentError('Unknown value for UISystemAnimation: $value'),
  };
}

late final _sel_performSystemAnimation_onViews_options_animations_completion_ = objc.registerName(
  "performSystemAnimation:onViews:options:animations:completion:",
);
final _objc_msgSend_fqrtz5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_modifyAnimationsWithRepeatCount_autoreverses_animations_ = objc.registerName(
  "modifyAnimationsWithRepeatCount:autoreverses:animations:",
);
final _objc_msgSend_nxk2e9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Bool,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        bool,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// UIViewAnimationWithBlocks
extension UIViewAnimationWithBlocks on UIView {
  /// animateWithDuration:delay:options:animations:completion:
  static void animateWithDuration(
    double duration, {
    required double delay,
    required UIViewAnimationOptions options,
    required objc.ObjCBlock<ffi.Void Function()> animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.animateWithDuration:delay:options:animations:completion:',
      iOS: (false, (4, 0, 0)),
    );
    _objc_msgSend_1pforg(
      _class_UIView,
      _sel_animateWithDuration_delay_options_animations_completion_,
      duration,
      delay,
      options.value,
      animations.ref.pointer,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// animateWithDuration:animations:completion:
  static void animateWithDuration$1(
    double duration, {
    required objc.ObjCBlock<ffi.Void Function()> animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal('UIView.animateWithDuration:animations:completion:', iOS: (false, (4, 0, 0)));
    _objc_msgSend_1isavsq(
      _class_UIView,
      _sel_animateWithDuration_animations_completion_,
      duration,
      animations.ref.pointer,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// animateWithDuration:animations:
  static void animateWithDuration$2(double duration, {required objc.ObjCBlock<ffi.Void Function()> animations}) {
    objc.checkOsVersionInternal('UIView.animateWithDuration:animations:', iOS: (false, (4, 0, 0)));
    _objc_msgSend_16dy26p(_class_UIView, _sel_animateWithDuration_animations_, duration, animations.ref.pointer);
  }

  /// animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:
  static void animateWithDuration$3(
    double duration, {
    required double delay,
    required double usingSpringWithDamping,
    required double initialSpringVelocity,
    required UIViewAnimationOptions options,
    required objc.ObjCBlock<ffi.Void Function()> animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_r4l13g(
      _class_UIView,
      _sel_animateWithDuration_delay_usingSpringWithDamping_initialSpringVelocity_options_animations_completion_,
      duration,
      delay,
      usingSpringWithDamping,
      initialSpringVelocity,
      options.value,
      animations.ref.pointer,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// transitionWithView:duration:options:animations:completion:
  static void transitionWithView(
    UIView view, {
    required double duration,
    required UIViewAnimationOptions options,
    objc.ObjCBlock<ffi.Void Function()>? animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.transitionWithView:duration:options:animations:completion:',
      iOS: (false, (4, 0, 0)),
    );
    _objc_msgSend_q6v4dl(
      _class_UIView,
      _sel_transitionWithView_duration_options_animations_completion_,
      view.ref.pointer,
      duration,
      options.value,
      animations?.ref.pointer ?? ffi.nullptr,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// transitionFromView:toView:duration:options:completion:
  static void transitionFromView(
    UIView fromView, {
    required UIView toView,
    required double duration,
    required UIViewAnimationOptions options,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.transitionFromView:toView:duration:options:completion:',
      iOS: (false, (4, 0, 0)),
    );
    _objc_msgSend_1eh0loo(
      _class_UIView,
      _sel_transitionFromView_toView_duration_options_completion_,
      fromView.ref.pointer,
      toView.ref.pointer,
      duration,
      options.value,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// performSystemAnimation:onViews:options:animations:completion:
  static void performSystemAnimation(
    UISystemAnimation animation, {
    required objc.NSArray onViews,
    required UIViewAnimationOptions options,
    objc.ObjCBlock<ffi.Void Function()>? animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.performSystemAnimation:onViews:options:animations:completion:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_fqrtz5(
      _class_UIView,
      _sel_performSystemAnimation_onViews_options_animations_completion_,
      animation.value,
      onViews.ref.pointer,
      options.value,
      animations?.ref.pointer ?? ffi.nullptr,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// modifyAnimationsWithRepeatCount:autoreverses:animations:
  static void modifyAnimationsWithRepeatCount(
    double count, {
    required bool autoreverses,
    required objc.ObjCBlock<ffi.Void Function()> animations,
  }) {
    objc.checkOsVersionInternal(
      'UIView.modifyAnimationsWithRepeatCount:autoreverses:animations:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_nxk2e9(
      _class_UIView,
      _sel_modifyAnimationsWithRepeatCount_autoreverses_animations_,
      count,
      autoreverses,
      animations.ref.pointer,
    );
  }
}

enum UIViewKeyframeAnimationOptions {
  UIViewKeyframeAnimationOptionLayoutSubviews(1),
  UIViewKeyframeAnimationOptionAllowUserInteraction(2),
  UIViewKeyframeAnimationOptionBeginFromCurrentState(4),
  UIViewKeyframeAnimationOptionRepeat(8),
  UIViewKeyframeAnimationOptionAutoreverse(16),
  UIViewKeyframeAnimationOptionOverrideInheritedDuration(32),
  UIViewKeyframeAnimationOptionOverrideInheritedOptions(512),
  UIViewKeyframeAnimationOptionCalculationModeLinear(0),
  UIViewKeyframeAnimationOptionCalculationModeDiscrete(1024),
  UIViewKeyframeAnimationOptionCalculationModePaced(2048),
  UIViewKeyframeAnimationOptionCalculationModeCubic(3072),
  UIViewKeyframeAnimationOptionCalculationModeCubicPaced(4096);

  final int value;
  const UIViewKeyframeAnimationOptions(this.value);

  static UIViewKeyframeAnimationOptions fromValue(int value) => switch (value) {
    1 => UIViewKeyframeAnimationOptionLayoutSubviews,
    2 => UIViewKeyframeAnimationOptionAllowUserInteraction,
    4 => UIViewKeyframeAnimationOptionBeginFromCurrentState,
    8 => UIViewKeyframeAnimationOptionRepeat,
    16 => UIViewKeyframeAnimationOptionAutoreverse,
    32 => UIViewKeyframeAnimationOptionOverrideInheritedDuration,
    512 => UIViewKeyframeAnimationOptionOverrideInheritedOptions,
    0 => UIViewKeyframeAnimationOptionCalculationModeLinear,
    1024 => UIViewKeyframeAnimationOptionCalculationModeDiscrete,
    2048 => UIViewKeyframeAnimationOptionCalculationModePaced,
    3072 => UIViewKeyframeAnimationOptionCalculationModeCubic,
    4096 => UIViewKeyframeAnimationOptionCalculationModeCubicPaced,
    _ => throw ArgumentError('Unknown value for UIViewKeyframeAnimationOptions: $value'),
  };
}

late final _sel_animateKeyframesWithDuration_delay_options_animations_completion_ = objc.registerName(
  "animateKeyframesWithDuration:delay:options:animations:completion:",
);
final _objc_msgSend_ciuhtc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        double,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_addKeyframeWithRelativeStartTime_relativeDuration_animations_ = objc.registerName(
  "addKeyframeWithRelativeStartTime:relativeDuration:animations:",
);
final _objc_msgSend_6jt11a = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Double,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        double,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// UIViewKeyframeAnimations
extension UIViewKeyframeAnimations on UIView {
  /// animateKeyframesWithDuration:delay:options:animations:completion:
  static void animateKeyframesWithDuration(
    double duration, {
    required double delay,
    required UIViewKeyframeAnimationOptions options,
    required objc.ObjCBlock<ffi.Void Function()> animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.animateKeyframesWithDuration:delay:options:animations:completion:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_ciuhtc(
      _class_UIView,
      _sel_animateKeyframesWithDuration_delay_options_animations_completion_,
      duration,
      delay,
      options.value,
      animations.ref.pointer,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// addKeyframeWithRelativeStartTime:relativeDuration:animations:
  static void addKeyframeWithRelativeStartTime(
    double frameStartTime, {
    required double relativeDuration,
    required objc.ObjCBlock<ffi.Void Function()> animations,
  }) {
    objc.checkOsVersionInternal(
      'UIView.addKeyframeWithRelativeStartTime:relativeDuration:animations:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_6jt11a(
      _class_UIView,
      _sel_addKeyframeWithRelativeStartTime_relativeDuration_animations_,
      frameStartTime,
      relativeDuration,
      animations.ref.pointer,
    );
  }
}

late final _sel_gestureRecognizers = objc.registerName("gestureRecognizers");
late final _sel_setGestureRecognizers_ = objc.registerName("setGestureRecognizers:");
late final _sel_addGestureRecognizer_ = objc.registerName("addGestureRecognizer:");
late final _sel_removeGestureRecognizer_ = objc.registerName("removeGestureRecognizer:");
late final _sel_gestureRecognizerShouldBegin_ = objc.registerName("gestureRecognizerShouldBegin:");

/// UIViewGestureRecognizers
extension UIViewGestureRecognizers on UIView {
  /// gestureRecognizers
  objc.NSArray? get gestureRecognizers {
    objc.checkOsVersionInternal('UIView.gestureRecognizers', iOS: (false, (3, 2, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_gestureRecognizers);
    return _ret.address == 0 ? null : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// setGestureRecognizers:
  set gestureRecognizers(objc.NSArray? value) {
    objc.checkOsVersionInternal('UIView.setGestureRecognizers:', iOS: (false, (3, 2, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setGestureRecognizers_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// addGestureRecognizer:
  void addGestureRecognizer(UIGestureRecognizer gestureRecognizer) {
    objc.checkOsVersionInternal('UIView.addGestureRecognizer:', iOS: (false, (3, 2, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addGestureRecognizer_, gestureRecognizer.ref.pointer);
  }

  /// removeGestureRecognizer:
  void removeGestureRecognizer(UIGestureRecognizer gestureRecognizer) {
    objc.checkOsVersionInternal('UIView.removeGestureRecognizer:', iOS: (false, (3, 2, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_removeGestureRecognizer_, gestureRecognizer.ref.pointer);
  }

  /// gestureRecognizerShouldBegin:
  bool gestureRecognizerShouldBegin(UIGestureRecognizer gestureRecognizer) {
    objc.checkOsVersionInternal('UIView.gestureRecognizerShouldBegin:', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_19nvye5(this.ref.pointer, _sel_gestureRecognizerShouldBegin_, gestureRecognizer.ref.pointer);
  }
}

/// WARNING: UIMotionEffect is a stub. To generate bindings for this class, include
/// UIMotionEffect in your config's objc-interfaces list.
///
/// UIMotionEffect
class UIMotionEffect extends objc.ObjCObjectBase {
  UIMotionEffect._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIMotionEffect] that points to the same underlying object as [other].
  UIMotionEffect.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIMotionEffect] that wraps the given raw object pointer.
  UIMotionEffect.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_addMotionEffect_ = objc.registerName("addMotionEffect:");
late final _sel_removeMotionEffect_ = objc.registerName("removeMotionEffect:");
late final _sel_motionEffects = objc.registerName("motionEffects");
late final _sel_setMotionEffects_ = objc.registerName("setMotionEffects:");

/// UIViewMotionEffects
extension UIViewMotionEffects on UIView {
  /// ! Begins applying `effect` to the receiver. The effect's emitted keyPath/value pairs will be
  /// applied to the view's presentation layer.
  ///
  /// Animates the transition to the motion effect's values using the present UIView animation
  /// context.
  void addMotionEffect(UIMotionEffect effect) {
    objc.checkOsVersionInternal('UIView.addMotionEffect:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addMotionEffect_, effect.ref.pointer);
  }

  /// ! Stops applying `effect` to the receiver. Any affected presentation values will animate to
  /// their post-removal values using the present UIView animation context.
  void removeMotionEffect(UIMotionEffect effect) {
    objc.checkOsVersionInternal('UIView.removeMotionEffect:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_removeMotionEffect_, effect.ref.pointer);
  }

  /// motionEffects
  objc.NSArray get motionEffects {
    objc.checkOsVersionInternal('UIView.motionEffects', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_motionEffects);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// setMotionEffects:
  set motionEffects(objc.NSArray value) {
    objc.checkOsVersionInternal('UIView.setMotionEffects:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setMotionEffects_, value.ref.pointer);
  }
}

late final _sel_constraints = objc.registerName("constraints");

/// WARNING: NSLayoutConstraint is a stub. To generate bindings for this class, include
/// NSLayoutConstraint in your config's objc-interfaces list.
///
/// NSLayoutConstraint
class NSLayoutConstraint extends objc.NSObject {
  NSLayoutConstraint._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSLayoutConstraint', iOS: (false, (6, 0, 0)), macOS: (false, (10, 7, 0)));
  }

  /// Constructs a [NSLayoutConstraint] that points to the same underlying object as [other].
  NSLayoutConstraint.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSLayoutConstraint] that wraps the given raw object pointer.
  NSLayoutConstraint.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_addConstraint_ = objc.registerName("addConstraint:");
late final _sel_addConstraints_ = objc.registerName("addConstraints:");
late final _sel_removeConstraint_ = objc.registerName("removeConstraint:");
late final _sel_removeConstraints_ = objc.registerName("removeConstraints:");

/// UIConstraintBasedLayoutInstallingConstraints
extension UIConstraintBasedLayoutInstallingConstraints on UIView {
  /// constraints
  objc.NSArray get constraints {
    objc.checkOsVersionInternal('UIView.constraints', iOS: (false, (6, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_constraints);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// addConstraint:
  void addConstraint(NSLayoutConstraint constraint) {
    objc.checkOsVersionInternal('UIView.addConstraint:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addConstraint_, constraint.ref.pointer);
  }

  /// addConstraints:
  void addConstraints(objc.NSArray constraints$1) {
    objc.checkOsVersionInternal('UIView.addConstraints:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addConstraints_, constraints$1.ref.pointer);
  }

  /// removeConstraint:
  void removeConstraint(NSLayoutConstraint constraint) {
    objc.checkOsVersionInternal('UIView.removeConstraint:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_removeConstraint_, constraint.ref.pointer);
  }

  /// removeConstraints:
  void removeConstraints(objc.NSArray constraints$1) {
    objc.checkOsVersionInternal('UIView.removeConstraints:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_removeConstraints_, constraints$1.ref.pointer);
  }
}

late final _sel_updateConstraintsIfNeeded = objc.registerName("updateConstraintsIfNeeded");
late final _sel_updateConstraints = objc.registerName("updateConstraints");
late final _sel_needsUpdateConstraints = objc.registerName("needsUpdateConstraints");
late final _sel_setNeedsUpdateConstraints = objc.registerName("setNeedsUpdateConstraints");

/// UIConstraintBasedLayoutCoreMethods
extension UIConstraintBasedLayoutCoreMethods$1 on UIView {
  /// updateConstraintsIfNeeded
  void updateConstraintsIfNeeded() {
    objc.checkOsVersionInternal('UIView.updateConstraintsIfNeeded', iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_updateConstraintsIfNeeded);
  }

  /// updateConstraints
  void updateConstraints() {
    objc.checkOsVersionInternal('UIView.updateConstraints', iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_updateConstraints);
  }

  /// needsUpdateConstraints
  bool needsUpdateConstraints() {
    objc.checkOsVersionInternal('UIView.needsUpdateConstraints', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_needsUpdateConstraints);
  }

  /// setNeedsUpdateConstraints
  void setNeedsUpdateConstraints() {
    objc.checkOsVersionInternal('UIView.setNeedsUpdateConstraints', iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsUpdateConstraints);
  }
}

late final _sel_translatesAutoresizingMaskIntoConstraints = objc.registerName(
  "translatesAutoresizingMaskIntoConstraints",
);
late final _sel_setTranslatesAutoresizingMaskIntoConstraints_ = objc.registerName(
  "setTranslatesAutoresizingMaskIntoConstraints:",
);
late final _sel_requiresConstraintBasedLayout = objc.registerName("requiresConstraintBasedLayout");

/// UIConstraintBasedCompatibility
extension UIConstraintBasedCompatibility on UIView {
  /// translatesAutoresizingMaskIntoConstraints
  bool get translatesAutoresizingMaskIntoConstraints {
    objc.checkOsVersionInternal('UIView.translatesAutoresizingMaskIntoConstraints', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_translatesAutoresizingMaskIntoConstraints);
  }

  /// setTranslatesAutoresizingMaskIntoConstraints:
  set translatesAutoresizingMaskIntoConstraints(bool value) {
    objc.checkOsVersionInternal('UIView.setTranslatesAutoresizingMaskIntoConstraints:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setTranslatesAutoresizingMaskIntoConstraints_, value);
  }

  /// requiresConstraintBasedLayout
  static bool getRequiresConstraintBasedLayout() {
    objc.checkOsVersionInternal('UIView.requiresConstraintBasedLayout', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_91o635(_class_UIView, _sel_requiresConstraintBasedLayout);
  }
}

late final _sel_alignmentRectForFrame_ = objc.registerName("alignmentRectForFrame:");
final _objc_msgSend_1gn1s3d = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect)
      >
    >()
    .asFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect)>();
final _objc_msgSend_1gn1s3dStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.CGRect>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect)
    >();
late final _sel_frameForAlignmentRect_ = objc.registerName("frameForAlignmentRect:");
late final _sel_alignmentRectInsets = objc.registerName("alignmentRectInsets");
late final _sel_viewForBaselineLayout = objc.registerName("viewForBaselineLayout");
late final _sel_viewForFirstBaselineLayout = objc.registerName("viewForFirstBaselineLayout");
late final _sel_viewForLastBaselineLayout = objc.registerName("viewForLastBaselineLayout");
late final _sel_intrinsicContentSize = objc.registerName("intrinsicContentSize");
late final _sel_invalidateIntrinsicContentSize = objc.registerName("invalidateIntrinsicContentSize");

enum UILayoutConstraintAxis {
  UILayoutConstraintAxisHorizontal(0),
  UILayoutConstraintAxisVertical(1);

  final int value;
  const UILayoutConstraintAxis(this.value);

  static UILayoutConstraintAxis fromValue(int value) => switch (value) {
    0 => UILayoutConstraintAxisHorizontal,
    1 => UILayoutConstraintAxisVertical,
    _ => throw ArgumentError('Unknown value for UILayoutConstraintAxis: $value'),
  };
}

late final _sel_contentHuggingPriorityForAxis_ = objc.registerName("contentHuggingPriorityForAxis:");
final _objc_msgSend_qigf85 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Float Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<double Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
final _objc_msgSend_qigf85Fpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<ffi.Float Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<double Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setContentHuggingPriority_forAxis_ = objc.registerName("setContentHuggingPriority:forAxis:");
final _objc_msgSend_wd7esz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Float, ffi.Long)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, double, int)>();
late final _sel_contentCompressionResistancePriorityForAxis_ = objc.registerName(
  "contentCompressionResistancePriorityForAxis:",
);
late final _sel_setContentCompressionResistancePriority_forAxis_ = objc.registerName(
  "setContentCompressionResistancePriority:forAxis:",
);

/// UIConstraintBasedLayoutLayering
extension UIConstraintBasedLayoutLayering on UIView {
  /// alignmentRectForFrame:
  objc.CGRect alignmentRectForFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal('UIView.alignmentRectForFrame:', iOS: (false, (6, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1gn1s3dStret(_ptr, this.ref.pointer, _sel_alignmentRectForFrame_, frame)
        : _ptr.ref = _objc_msgSend_1gn1s3d(this.ref.pointer, _sel_alignmentRectForFrame_, frame);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// frameForAlignmentRect:
  objc.CGRect frameForAlignmentRect(objc.CGRect alignmentRect) {
    objc.checkOsVersionInternal('UIView.frameForAlignmentRect:', iOS: (false, (6, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1gn1s3dStret(_ptr, this.ref.pointer, _sel_frameForAlignmentRect_, alignmentRect)
        : _ptr.ref = _objc_msgSend_1gn1s3d(this.ref.pointer, _sel_frameForAlignmentRect_, alignmentRect);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// alignmentRectInsets
  UIEdgeInsets get alignmentRectInsets {
    objc.checkOsVersionInternal('UIView.alignmentRectInsets', iOS: (false, (6, 0, 0)));
    final _ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(_ptr, this.ref.pointer, _sel_alignmentRectInsets)
        : _ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_alignmentRectInsets);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>(_finalizable);
  }

  /// viewForBaselineLayout
  UIView viewForBaselineLayout() {
    objc.checkOsVersionInternal('UIView.viewForBaselineLayout', iOS: (false, (6, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_viewForBaselineLayout);
    return UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// viewForFirstBaselineLayout
  UIView get viewForFirstBaselineLayout {
    objc.checkOsVersionInternal('UIView.viewForFirstBaselineLayout', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_viewForFirstBaselineLayout);
    return UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// viewForLastBaselineLayout
  UIView get viewForLastBaselineLayout {
    objc.checkOsVersionInternal('UIView.viewForLastBaselineLayout', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_viewForLastBaselineLayout);
    return UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// intrinsicContentSize
  objc.CGSize get intrinsicContentSize {
    objc.checkOsVersionInternal('UIView.intrinsicContentSize', iOS: (false, (6, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1vdfkenStret(_ptr, this.ref.pointer, _sel_intrinsicContentSize)
        : _ptr.ref = _objc_msgSend_1vdfken(this.ref.pointer, _sel_intrinsicContentSize);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// invalidateIntrinsicContentSize
  void invalidateIntrinsicContentSize() {
    objc.checkOsVersionInternal('UIView.invalidateIntrinsicContentSize', iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_invalidateIntrinsicContentSize);
  }

  /// contentHuggingPriorityForAxis:
  double contentHuggingPriorityForAxis(UILayoutConstraintAxis axis) {
    objc.checkOsVersionInternal('UIView.contentHuggingPriorityForAxis:', iOS: (false, (6, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_qigf85Fpret(this.ref.pointer, _sel_contentHuggingPriorityForAxis_, axis.value)
        : _objc_msgSend_qigf85(this.ref.pointer, _sel_contentHuggingPriorityForAxis_, axis.value);
  }

  /// setContentHuggingPriority:forAxis:
  void setContentHuggingPriority(double priority, {required UILayoutConstraintAxis forAxis}) {
    objc.checkOsVersionInternal('UIView.setContentHuggingPriority:forAxis:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_wd7esz(this.ref.pointer, _sel_setContentHuggingPriority_forAxis_, priority, forAxis.value);
  }

  /// contentCompressionResistancePriorityForAxis:
  double contentCompressionResistancePriorityForAxis(UILayoutConstraintAxis axis) {
    objc.checkOsVersionInternal('UIView.contentCompressionResistancePriorityForAxis:', iOS: (false, (6, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_qigf85Fpret(this.ref.pointer, _sel_contentCompressionResistancePriorityForAxis_, axis.value)
        : _objc_msgSend_qigf85(this.ref.pointer, _sel_contentCompressionResistancePriorityForAxis_, axis.value);
  }

  /// setContentCompressionResistancePriority:forAxis:
  void setContentCompressionResistancePriority(double priority, {required UILayoutConstraintAxis forAxis}) {
    objc.checkOsVersionInternal('UIView.setContentCompressionResistancePriority:forAxis:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_wd7esz(
      this.ref.pointer,
      _sel_setContentCompressionResistancePriority_forAxis_,
      priority,
      forAxis.value,
    );
  }
}

late final _sel_systemLayoutSizeFittingSize_ = objc.registerName("systemLayoutSizeFittingSize:");
late final _sel_systemLayoutSizeFittingSize_withHorizontalFittingPriority_verticalFittingPriority_ = objc.registerName(
  "systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority:",
);
final _objc_msgSend_3fx2qn = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGSize Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGSize,
          ffi.Float,
          ffi.Float,
        )
      >
    >()
    .asFunction<
      objc.CGSize Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGSize, double, double)
    >();
final _objc_msgSend_3fx2qnStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGSize>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGSize,
          ffi.Float,
          ffi.Float,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGSize>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGSize,
        double,
        double,
      )
    >();

/// UIConstraintBasedLayoutFittingSize
extension UIConstraintBasedLayoutFittingSize on UIView {
  /// systemLayoutSizeFittingSize:
  objc.CGSize systemLayoutSizeFittingSize(objc.CGSize targetSize) {
    objc.checkOsVersionInternal('UIView.systemLayoutSizeFittingSize:', iOS: (false, (6, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1owrp3bStret(_ptr, this.ref.pointer, _sel_systemLayoutSizeFittingSize_, targetSize)
        : _ptr.ref = _objc_msgSend_1owrp3b(this.ref.pointer, _sel_systemLayoutSizeFittingSize_, targetSize);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority:
  objc.CGSize systemLayoutSizeFittingSize$1(
    objc.CGSize targetSize, {
    required double withHorizontalFittingPriority,
    required double verticalFittingPriority,
  }) {
    objc.checkOsVersionInternal(
      'UIView.systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority:',
      iOS: (false, (8, 0, 0)),
    );
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3fx2qnStret(
            _ptr,
            this.ref.pointer,
            _sel_systemLayoutSizeFittingSize_withHorizontalFittingPriority_verticalFittingPriority_,
            targetSize,
            withHorizontalFittingPriority,
            verticalFittingPriority,
          )
        : _ptr.ref = _objc_msgSend_3fx2qn(
            this.ref.pointer,
            _sel_systemLayoutSizeFittingSize_withHorizontalFittingPriority_verticalFittingPriority_,
            targetSize,
            withHorizontalFittingPriority,
            verticalFittingPriority,
          );
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }
}

late final _sel_layoutGuides = objc.registerName("layoutGuides");
late final _sel_addLayoutGuide_ = objc.registerName("addLayoutGuide:");
late final _sel_removeLayoutGuide_ = objc.registerName("removeLayoutGuide:");

/// UILayoutGuideSupport
extension UILayoutGuideSupport on UIView {
  /// layoutGuides
  objc.NSArray get layoutGuides {
    objc.checkOsVersionInternal('UIView.layoutGuides', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_layoutGuides);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// addLayoutGuide:
  void addLayoutGuide(UILayoutGuide layoutGuide) {
    objc.checkOsVersionInternal('UIView.addLayoutGuide:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addLayoutGuide_, layoutGuide.ref.pointer);
  }

  /// removeLayoutGuide:
  void removeLayoutGuide(UILayoutGuide layoutGuide) {
    objc.checkOsVersionInternal('UIView.removeLayoutGuide:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_removeLayoutGuide_, layoutGuide.ref.pointer);
  }
}

/// WARNING: NSLayoutXAxisAnchor is a stub. To generate bindings for this class, include
/// NSLayoutXAxisAnchor in your config's objc-interfaces list.
///
/// NSLayoutXAxisAnchor
class NSLayoutXAxisAnchor extends objc.ObjCObjectBase {
  NSLayoutXAxisAnchor._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [NSLayoutXAxisAnchor] that points to the same underlying object as [other].
  NSLayoutXAxisAnchor.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSLayoutXAxisAnchor] that wraps the given raw object pointer.
  NSLayoutXAxisAnchor.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_leadingAnchor = objc.registerName("leadingAnchor");
late final _sel_trailingAnchor = objc.registerName("trailingAnchor");
late final _sel_leftAnchor = objc.registerName("leftAnchor");
late final _sel_rightAnchor = objc.registerName("rightAnchor");

/// WARNING: NSLayoutYAxisAnchor is a stub. To generate bindings for this class, include
/// NSLayoutYAxisAnchor in your config's objc-interfaces list.
///
/// NSLayoutYAxisAnchor
class NSLayoutYAxisAnchor extends objc.ObjCObjectBase {
  NSLayoutYAxisAnchor._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [NSLayoutYAxisAnchor] that points to the same underlying object as [other].
  NSLayoutYAxisAnchor.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSLayoutYAxisAnchor] that wraps the given raw object pointer.
  NSLayoutYAxisAnchor.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_topAnchor = objc.registerName("topAnchor");
late final _sel_bottomAnchor = objc.registerName("bottomAnchor");

/// WARNING: NSLayoutDimension is a stub. To generate bindings for this class, include
/// NSLayoutDimension in your config's objc-interfaces list.
///
/// NSLayoutDimension
class NSLayoutDimension extends objc.ObjCObjectBase {
  NSLayoutDimension._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [NSLayoutDimension] that points to the same underlying object as [other].
  NSLayoutDimension.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSLayoutDimension] that wraps the given raw object pointer.
  NSLayoutDimension.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_widthAnchor = objc.registerName("widthAnchor");
late final _sel_heightAnchor = objc.registerName("heightAnchor");
late final _sel_centerXAnchor = objc.registerName("centerXAnchor");
late final _sel_centerYAnchor = objc.registerName("centerYAnchor");
late final _sel_firstBaselineAnchor = objc.registerName("firstBaselineAnchor");
late final _sel_lastBaselineAnchor = objc.registerName("lastBaselineAnchor");

/// UIViewLayoutConstraintCreation
extension UIViewLayoutConstraintCreation on UIView {
  /// leadingAnchor
  NSLayoutXAxisAnchor get leadingAnchor {
    objc.checkOsVersionInternal('UIView.leadingAnchor', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_leadingAnchor);
    return NSLayoutXAxisAnchor.castFromPointer(_ret, retain: true, release: true);
  }

  /// trailingAnchor
  NSLayoutXAxisAnchor get trailingAnchor {
    objc.checkOsVersionInternal('UIView.trailingAnchor', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_trailingAnchor);
    return NSLayoutXAxisAnchor.castFromPointer(_ret, retain: true, release: true);
  }

  /// leftAnchor
  NSLayoutXAxisAnchor get leftAnchor {
    objc.checkOsVersionInternal('UIView.leftAnchor', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_leftAnchor);
    return NSLayoutXAxisAnchor.castFromPointer(_ret, retain: true, release: true);
  }

  /// rightAnchor
  NSLayoutXAxisAnchor get rightAnchor {
    objc.checkOsVersionInternal('UIView.rightAnchor', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_rightAnchor);
    return NSLayoutXAxisAnchor.castFromPointer(_ret, retain: true, release: true);
  }

  /// topAnchor
  NSLayoutYAxisAnchor get topAnchor {
    objc.checkOsVersionInternal('UIView.topAnchor', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_topAnchor);
    return NSLayoutYAxisAnchor.castFromPointer(_ret, retain: true, release: true);
  }

  /// bottomAnchor
  NSLayoutYAxisAnchor get bottomAnchor {
    objc.checkOsVersionInternal('UIView.bottomAnchor', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_bottomAnchor);
    return NSLayoutYAxisAnchor.castFromPointer(_ret, retain: true, release: true);
  }

  /// widthAnchor
  NSLayoutDimension get widthAnchor {
    objc.checkOsVersionInternal('UIView.widthAnchor', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_widthAnchor);
    return NSLayoutDimension.castFromPointer(_ret, retain: true, release: true);
  }

  /// heightAnchor
  NSLayoutDimension get heightAnchor {
    objc.checkOsVersionInternal('UIView.heightAnchor', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_heightAnchor);
    return NSLayoutDimension.castFromPointer(_ret, retain: true, release: true);
  }

  /// centerXAnchor
  NSLayoutXAxisAnchor get centerXAnchor {
    objc.checkOsVersionInternal('UIView.centerXAnchor', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_centerXAnchor);
    return NSLayoutXAxisAnchor.castFromPointer(_ret, retain: true, release: true);
  }

  /// centerYAnchor
  NSLayoutYAxisAnchor get centerYAnchor {
    objc.checkOsVersionInternal('UIView.centerYAnchor', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_centerYAnchor);
    return NSLayoutYAxisAnchor.castFromPointer(_ret, retain: true, release: true);
  }

  /// firstBaselineAnchor
  NSLayoutYAxisAnchor get firstBaselineAnchor {
    objc.checkOsVersionInternal('UIView.firstBaselineAnchor', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_firstBaselineAnchor);
    return NSLayoutYAxisAnchor.castFromPointer(_ret, retain: true, release: true);
  }

  /// lastBaselineAnchor
  NSLayoutYAxisAnchor get lastBaselineAnchor {
    objc.checkOsVersionInternal('UIView.lastBaselineAnchor', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_lastBaselineAnchor);
    return NSLayoutYAxisAnchor.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_constraintsAffectingLayoutForAxis_ = objc.registerName("constraintsAffectingLayoutForAxis:");
final _objc_msgSend_5swr7b = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)
    >();
late final _sel_hasAmbiguousLayout = objc.registerName("hasAmbiguousLayout");
late final _sel_exerciseAmbiguityInLayout = objc.registerName("exerciseAmbiguityInLayout");

/// UIConstraintBasedLayoutDebugging
extension UIConstraintBasedLayoutDebugging on UIView {
  /// constraintsAffectingLayoutForAxis:
  objc.NSArray constraintsAffectingLayoutForAxis(UILayoutConstraintAxis axis) {
    objc.checkOsVersionInternal('UIView.constraintsAffectingLayoutForAxis:', iOS: (false, (6, 0, 0)));
    final _ret = _objc_msgSend_5swr7b(this.ref.pointer, _sel_constraintsAffectingLayoutForAxis_, axis.value);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// hasAmbiguousLayout
  bool get hasAmbiguousLayout {
    objc.checkOsVersionInternal('UIView.hasAmbiguousLayout', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_hasAmbiguousLayout);
  }

  /// exerciseAmbiguityInLayout
  void exerciseAmbiguityInLayout() {
    objc.checkOsVersionInternal('UIView.exerciseAmbiguityInLayout', iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_exerciseAmbiguityInLayout);
  }
}

/// UIStateRestoration
extension UIStateRestoration$1 on UIView {
  /// restorationIdentifier
  objc.NSString? get restorationIdentifier {
    objc.checkOsVersionInternal('UIView.restorationIdentifier', iOS: (false, (6, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_restorationIdentifier);
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setRestorationIdentifier:
  set restorationIdentifier(objc.NSString? value) {
    objc.checkOsVersionInternal('UIView.setRestorationIdentifier:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setRestorationIdentifier_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// encodeRestorableStateWithCoder:
  void encodeRestorableStateWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal('UIView.encodeRestorableStateWithCoder:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeRestorableStateWithCoder_, coder.ref.pointer);
  }

  /// decodeRestorableStateWithCoder:
  void decodeRestorableStateWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal('UIView.decodeRestorableStateWithCoder:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_decodeRestorableStateWithCoder_, coder.ref.pointer);
  }
}

late final _sel_snapshotViewAfterScreenUpdates_ = objc.registerName("snapshotViewAfterScreenUpdates:");
late final _sel_resizableSnapshotViewFromRect_afterScreenUpdates_withCapInsets_ = objc.registerName(
  "resizableSnapshotViewFromRect:afterScreenUpdates:withCapInsets:",
);
final _objc_msgSend_qvletk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Bool,
          UIEdgeInsets,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        bool,
        UIEdgeInsets,
      )
    >();
late final _sel_drawViewHierarchyInRect_afterScreenUpdates_ = objc.registerName(
  "drawViewHierarchyInRect:afterScreenUpdates:",
);
final _objc_msgSend_19ljaqg = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect, ffi.Bool)
      >
    >()
    .asFunction<bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect, bool)>();

/// UISnapshotting
extension UISnapshotting on UIView {
  /// snapshotViewAfterScreenUpdates:
  UIView? snapshotViewAfterScreenUpdates(bool afterUpdates) {
    objc.checkOsVersionInternal('UIView.snapshotViewAfterScreenUpdates:', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_1t6aok9(this.ref.pointer, _sel_snapshotViewAfterScreenUpdates_, afterUpdates);
    return _ret.address == 0 ? null : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// resizableSnapshotViewFromRect:afterScreenUpdates:withCapInsets:
  UIView? resizableSnapshotViewFromRect(
    objc.CGRect rect, {
    required bool afterScreenUpdates,
    required UIEdgeInsets withCapInsets,
  }) {
    objc.checkOsVersionInternal(
      'UIView.resizableSnapshotViewFromRect:afterScreenUpdates:withCapInsets:',
      iOS: (false, (7, 0, 0)),
    );
    final _ret = _objc_msgSend_qvletk(
      this.ref.pointer,
      _sel_resizableSnapshotViewFromRect_afterScreenUpdates_withCapInsets_,
      rect,
      afterScreenUpdates,
      withCapInsets,
    );
    return _ret.address == 0 ? null : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// drawViewHierarchyInRect:afterScreenUpdates:
  bool drawViewHierarchyInRect(objc.CGRect rect, {required bool afterScreenUpdates}) {
    objc.checkOsVersionInternal('UIView.drawViewHierarchyInRect:afterScreenUpdates:', iOS: (false, (7, 0, 0)));
    return _objc_msgSend_19ljaqg(
      this.ref.pointer,
      _sel_drawViewHierarchyInRect_afterScreenUpdates_,
      rect,
      afterScreenUpdates,
    );
  }
}

late final _sel_beginAnimations_context_ = objc.registerName("beginAnimations:context:");
final _objc_msgSend_1lzqwav = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Void>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Void>,
      )
    >();
late final _sel_commitAnimations = objc.registerName("commitAnimations");
late final _sel_setAnimationDelegate_ = objc.registerName("setAnimationDelegate:");
late final _sel_setAnimationWillStartSelector_ = objc.registerName("setAnimationWillStartSelector:");
late final _sel_setAnimationDidStopSelector_ = objc.registerName("setAnimationDidStopSelector:");
late final _sel_setAnimationDuration_ = objc.registerName("setAnimationDuration:");
late final _sel_setAnimationDelay_ = objc.registerName("setAnimationDelay:");
late final _sel_setAnimationStartDate_ = objc.registerName("setAnimationStartDate:");

enum UIViewAnimationCurve {
  UIViewAnimationCurveEaseInOut(0),
  UIViewAnimationCurveEaseIn(1),
  UIViewAnimationCurveEaseOut(2),
  UIViewAnimationCurveLinear(3);

  final int value;
  const UIViewAnimationCurve(this.value);

  static UIViewAnimationCurve fromValue(int value) => switch (value) {
    0 => UIViewAnimationCurveEaseInOut,
    1 => UIViewAnimationCurveEaseIn,
    2 => UIViewAnimationCurveEaseOut,
    3 => UIViewAnimationCurveLinear,
    _ => throw ArgumentError('Unknown value for UIViewAnimationCurve: $value'),
  };
}

late final _sel_setAnimationCurve_ = objc.registerName("setAnimationCurve:");
final _objc_msgSend_up32gn = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setAnimationRepeatCount_ = objc.registerName("setAnimationRepeatCount:");
final _objc_msgSend_v5hmet = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Float)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, double)>();
late final _sel_setAnimationRepeatAutoreverses_ = objc.registerName("setAnimationRepeatAutoreverses:");
late final _sel_setAnimationBeginsFromCurrentState_ = objc.registerName("setAnimationBeginsFromCurrentState:");

enum UIViewAnimationTransition {
  UIViewAnimationTransitionNone(0),
  UIViewAnimationTransitionFlipFromLeft(1),
  UIViewAnimationTransitionFlipFromRight(2),
  UIViewAnimationTransitionCurlUp(3),
  UIViewAnimationTransitionCurlDown(4);

  final int value;
  const UIViewAnimationTransition(this.value);

  static UIViewAnimationTransition fromValue(int value) => switch (value) {
    0 => UIViewAnimationTransitionNone,
    1 => UIViewAnimationTransitionFlipFromLeft,
    2 => UIViewAnimationTransitionFlipFromRight,
    3 => UIViewAnimationTransitionCurlUp,
    4 => UIViewAnimationTransitionCurlDown,
    _ => throw ArgumentError('Unknown value for UIViewAnimationTransition: $value'),
  };
}

late final _sel_setAnimationTransition_forView_cache_ = objc.registerName("setAnimationTransition:forView:cache:");
final _objc_msgSend_1ftk3d5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObject>,
        bool,
      )
    >();

/// DeprecatedAnimations
extension DeprecatedAnimations on UIView {
  /// beginAnimations:context:
  static void beginAnimations(objc.NSString? animationID, {required ffi.Pointer<ffi.Void> context}) {
    objc.checkOsVersionInternal('UIView.beginAnimations:context:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1lzqwav(
      _class_UIView,
      _sel_beginAnimations_context_,
      animationID?.ref.pointer ?? ffi.nullptr,
      context,
    );
  }

  /// commitAnimations
  static void commitAnimations() {
    objc.checkOsVersionInternal('UIView.commitAnimations', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(_class_UIView, _sel_commitAnimations);
  }

  /// setAnimationDelegate:
  static void setAnimationDelegate(objc.ObjCObjectBase? delegate) {
    objc.checkOsVersionInternal('UIView.setAnimationDelegate:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(_class_UIView, _sel_setAnimationDelegate_, delegate?.ref.pointer ?? ffi.nullptr);
  }

  /// setAnimationWillStartSelector:
  static void setAnimationWillStartSelector(ffi.Pointer<objc.ObjCSelector> selector) {
    objc.checkOsVersionInternal('UIView.setAnimationWillStartSelector:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1d9e4oe(_class_UIView, _sel_setAnimationWillStartSelector_, selector);
  }

  /// setAnimationDidStopSelector:
  static void setAnimationDidStopSelector(ffi.Pointer<objc.ObjCSelector> selector) {
    objc.checkOsVersionInternal('UIView.setAnimationDidStopSelector:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1d9e4oe(_class_UIView, _sel_setAnimationDidStopSelector_, selector);
  }

  /// setAnimationDuration:
  static void setAnimationDuration(double duration) {
    objc.checkOsVersionInternal('UIView.setAnimationDuration:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(_class_UIView, _sel_setAnimationDuration_, duration);
  }

  /// setAnimationDelay:
  static void setAnimationDelay(double delay) {
    objc.checkOsVersionInternal('UIView.setAnimationDelay:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(_class_UIView, _sel_setAnimationDelay_, delay);
  }

  /// setAnimationStartDate:
  static void setAnimationStartDate(objc.NSDate startDate) {
    objc.checkOsVersionInternal('UIView.setAnimationStartDate:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(_class_UIView, _sel_setAnimationStartDate_, startDate.ref.pointer);
  }

  /// setAnimationCurve:
  static void setAnimationCurve(UIViewAnimationCurve curve) {
    objc.checkOsVersionInternal('UIView.setAnimationCurve:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_up32gn(_class_UIView, _sel_setAnimationCurve_, curve.value);
  }

  /// setAnimationRepeatCount:
  static void setAnimationRepeatCount(double repeatCount) {
    objc.checkOsVersionInternal('UIView.setAnimationRepeatCount:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_v5hmet(_class_UIView, _sel_setAnimationRepeatCount_, repeatCount);
  }

  /// setAnimationRepeatAutoreverses:
  static void setAnimationRepeatAutoreverses(bool repeatAutoreverses) {
    objc.checkOsVersionInternal('UIView.setAnimationRepeatAutoreverses:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(_class_UIView, _sel_setAnimationRepeatAutoreverses_, repeatAutoreverses);
  }

  /// setAnimationBeginsFromCurrentState:
  static void setAnimationBeginsFromCurrentState(bool fromCurrentState) {
    objc.checkOsVersionInternal('UIView.setAnimationBeginsFromCurrentState:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(_class_UIView, _sel_setAnimationBeginsFromCurrentState_, fromCurrentState);
  }

  /// setAnimationTransition:forView:cache:
  static void setAnimationTransition(
    UIViewAnimationTransition transition, {
    required UIView forView,
    required bool cache,
  }) {
    objc.checkOsVersionInternal('UIView.setAnimationTransition:forView:cache:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1ftk3d5(
      _class_UIView,
      _sel_setAnimationTransition_forView_cache_,
      transition.value,
      forView.ref.pointer,
      cache,
    );
  }
}

/// UserInterfaceStyle
extension UserInterfaceStyle on UIView {
  /// overrideUserInterfaceStyle
  UIUserInterfaceStyle get overrideUserInterfaceStyle {
    objc.checkOsVersionInternal('UIView.overrideUserInterfaceStyle', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_2x5ago(this.ref.pointer, _sel_overrideUserInterfaceStyle);
    return UIUserInterfaceStyle.fromValue(_ret);
  }

  /// setOverrideUserInterfaceStyle:
  set overrideUserInterfaceStyle(UIUserInterfaceStyle value) {
    objc.checkOsVersionInternal('UIView.setOverrideUserInterfaceStyle:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_15dz1ky(this.ref.pointer, _sel_setOverrideUserInterfaceStyle_, value.value);
  }
}

late final _sel_minimumContentSizeCategory = objc.registerName("minimumContentSizeCategory");
late final _sel_setMinimumContentSizeCategory_ = objc.registerName("setMinimumContentSizeCategory:");
late final _sel_maximumContentSizeCategory = objc.registerName("maximumContentSizeCategory");
late final _sel_setMaximumContentSizeCategory_ = objc.registerName("setMaximumContentSizeCategory:");
late final _sel_appliedContentSizeCategoryLimitsDescription = objc.registerName(
  "appliedContentSizeCategoryLimitsDescription",
);

/// UIContentSizeCategoryLimit
extension UIContentSizeCategoryLimit on UIView {
  /// Specify content size category limits. Setting one or both of these properties will limit the
  /// content size category for this view (and its subviews) to a minimum or a maximum value.
  /// You can use this to limit the support content size categories on part of your view hierarchy.
  /// Setting this to nil removes the limit on the minimum or maximum.
  /// Limits will be applied immediately and when future content size category updates occur.
  ///
  /// Specifying a minimum limit that is greater than the maximum limit (or vice versa) will effectively
  /// only use the maximum limit.
  ///
  /// Example:
  ///
  /// // limit the support content size categories between .medium and .accessibilityExtraLarge (included).
  /// view.minimumContentSizeCategory = UIContentSizeCategoryMedium;
  /// view.maximumContentSizeCategory = UIContentSizeCategoryAccessibilityExtraLarge;
  objc.NSString? get minimumContentSizeCategory {
    objc.checkOsVersionInternal('UIView.minimumContentSizeCategory', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_minimumContentSizeCategory);
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Specify content size category limits. Setting one or both of these properties will limit the
  /// content size category for this view (and its subviews) to a minimum or a maximum value.
  /// You can use this to limit the support content size categories on part of your view hierarchy.
  /// Setting this to nil removes the limit on the minimum or maximum.
  /// Limits will be applied immediately and when future content size category updates occur.
  ///
  /// Specifying a minimum limit that is greater than the maximum limit (or vice versa) will effectively
  /// only use the maximum limit.
  ///
  /// Example:
  ///
  /// // limit the support content size categories between .medium and .accessibilityExtraLarge (included).
  /// view.minimumContentSizeCategory = UIContentSizeCategoryMedium;
  /// view.maximumContentSizeCategory = UIContentSizeCategoryAccessibilityExtraLarge;
  set minimumContentSizeCategory(objc.NSString? value) {
    objc.checkOsVersionInternal('UIView.setMinimumContentSizeCategory:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setMinimumContentSizeCategory_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// maximumContentSizeCategory
  objc.NSString? get maximumContentSizeCategory {
    objc.checkOsVersionInternal('UIView.maximumContentSizeCategory', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_maximumContentSizeCategory);
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setMaximumContentSizeCategory:
  set maximumContentSizeCategory(objc.NSString? value) {
    objc.checkOsVersionInternal('UIView.setMaximumContentSizeCategory:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setMaximumContentSizeCategory_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Will return a string with a log of all the superviews of this view, alongside with what
  /// content size category each view has and if that view has limits applied.
  /// This is for debugging purposes only.
  objc.NSString get appliedContentSizeCategoryLimitsDescription {
    objc.checkOsVersionInternal('UIView.appliedContentSizeCategoryLimitsDescription', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_appliedContentSizeCategoryLimitsDescription);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }
}

/// WARNING: UIInteraction is a stub. To generate bindings for this class, include
/// UIInteraction in your config's objc-protocols list.
///
/// UIInteraction
interface class UIInteraction extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIInteraction._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIInteraction] that points to the same underlying object as [other].
  UIInteraction.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIInteraction] that wraps the given raw object pointer.
  UIInteraction.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_addInteraction_ = objc.registerName("addInteraction:");
late final _sel_removeInteraction_ = objc.registerName("removeInteraction:");
late final _sel_interactions = objc.registerName("interactions");
late final _sel_setInteractions_ = objc.registerName("setInteractions:");

/// Interactions
extension Interactions on UIView {
  /// addInteraction:
  void addInteraction(UIInteraction interaction) {
    objc.checkOsVersionInternal('UIView.addInteraction:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addInteraction_, interaction.ref.pointer);
  }

  /// removeInteraction:
  void removeInteraction(UIInteraction interaction) {
    objc.checkOsVersionInternal('UIView.removeInteraction:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_removeInteraction_, interaction.ref.pointer);
  }

  /// interactions
  objc.NSArray get interactions {
    objc.checkOsVersionInternal('UIView.interactions', iOS: (false, (11, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_interactions);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// setInteractions:
  set interactions(objc.NSArray value) {
    objc.checkOsVersionInternal('UIView.setInteractions:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setInteractions_, value.ref.pointer);
  }
}

late final _sel_endEditing_ = objc.registerName("endEditing:");
final _objc_msgSend_41h7k3 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>
    >()
    .asFunction<bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, bool)>();

/// UITextField
extension UITextField on UIView {
  /// endEditing:
  bool endEditing(bool force) {
    objc.checkOsVersionInternal('UIView.endEditing:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_41h7k3(this.ref.pointer, _sel_endEditing_, force);
  }
}

late final _sel_isUserInteractionEnabled = objc.registerName("isUserInteractionEnabled");
late final _sel_setUserInteractionEnabled_ = objc.registerName("setUserInteractionEnabled:");

/// WARNING: CALayer is a stub. To generate bindings for this class, include
/// CALayer in your config's objc-interfaces list.
///
/// CALayer
class CALayer extends objc.NSObject implements objc.NSSecureCoding, CAMediaTiming {
  CALayer._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CALayer', iOS: (false, (2, 0, 0)), macOS: (false, (10, 5, 0)));
  }

  /// Constructs a [CALayer] that points to the same underlying object as [other].
  CALayer.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CALayer] that wraps the given raw object pointer.
  CALayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_layer = objc.registerName("layer");
late final _sel_canBecomeFocused = objc.registerName("canBecomeFocused");
late final _sel_isFocused = objc.registerName("isFocused");
late final _sel_focusGroupPriority = objc.registerName("focusGroupPriority");
late final _sel_setFocusGroupPriority_ = objc.registerName("setFocusGroupPriority:");

/// WARNING: UIFocusEffect is a stub. To generate bindings for this class, include
/// UIFocusEffect in your config's objc-interfaces list.
///
/// UIFocusEffect
class UIFocusEffect extends objc.ObjCObjectBase {
  UIFocusEffect._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIFocusEffect] that points to the same underlying object as [other].
  UIFocusEffect.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusEffect] that wraps the given raw object pointer.
  UIFocusEffect.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_focusEffect = objc.registerName("focusEffect");
late final _sel_setFocusEffect_ = objc.registerName("setFocusEffect:");
late final _sel_semanticContentAttribute = objc.registerName("semanticContentAttribute");
final _objc_msgSend_i2u4x4 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setSemanticContentAttribute_ = objc.registerName("setSemanticContentAttribute:");
final _objc_msgSend_162qwxu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_effectiveUserInterfaceLayoutDirection = objc.registerName("effectiveUserInterfaceLayoutDirection");
final _objc_msgSend_qj4fey = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
objc.CGRect _ObjCBlock_NSRect_ffiVoid_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => block.ref.target
    .cast<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<ffi.Void> arg0)>>()
    .asFunction<objc.CGRect Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSRect_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
      _ObjCBlock_NSRect_ffiVoid_fnPtrTrampoline,
    ).cast();
objc.CGRect _ObjCBlock_NSRect_ffiVoid_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => (objc.getBlockClosure(block) as objc.CGRect Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSRect_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
      _ObjCBlock_NSRect_ffiVoid_closureTrampoline,
    ).cast();

/// Construction methods for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSRect_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_ObjCBlock_NSRect_ffiVoid_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)> fromFunction(
    objc.CGRect Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _ObjCBlock_NSRect_ffiVoid_closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSRect_ffiVoid_CallExtension on objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)> {
  objc.CGRect call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>
      >()
      .asFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

CGAffineTransform _ObjCBlock_CGAffineTransform_ffiVoid_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => block.ref.target
    .cast<ffi.NativeFunction<CGAffineTransform Function(ffi.Pointer<ffi.Void> arg0)>>()
    .asFunction<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CGAffineTransform_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<CGAffineTransform Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
      _ObjCBlock_CGAffineTransform_ffiVoid_fnPtrTrampoline,
    ).cast();
CGAffineTransform _ObjCBlock_CGAffineTransform_ffiVoid_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => (objc.getBlockClosure(block) as CGAffineTransform Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CGAffineTransform_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<CGAffineTransform Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
      _ObjCBlock_CGAffineTransform_ffiVoid_closureTrampoline,
    ).cast();

/// Construction methods for `objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_CGAffineTransform_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<CGAffineTransform Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_ObjCBlock_CGAffineTransform_ffiVoid_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)> fromFunction(
    CGAffineTransform Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _ObjCBlock_CGAffineTransform_ffiVoid_closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_CGAffineTransform_ffiVoid_CallExtension
    on objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)> {
  CGAffineTransform call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              CGAffineTransform Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)
            >
          >()
          .asFunction<CGAffineTransform Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(
        ref.pointer,
        arg0,
      );
}

void _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  CGAffineTransform arg1,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1)>>()
    .asFunction<void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, CGAffineTransform)
        >(_ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  CGAffineTransform arg1,
) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, CGAffineTransform))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, CGAffineTransform)
        >(_ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  CGAffineTransform arg1,
) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, CGAffineTransform))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, CGAffineTransform)>
_ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, CGAffineTransform)
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  CGAffineTransform arg1,
) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, CGAffineTransform))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, CGAffineTransform)
>
_ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          CGAffineTransform,
        )
      >.isolateLocal(_ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, CGAffineTransform)
>
_ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          CGAffineTransform,
        )
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>(
    objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, CGAffineTransform) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>(
    objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)> listener(
    void Function(ffi.Pointer<ffi.Void>, CGAffineTransform) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_1lznlw3(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)> blocking(
    void Function(ffi.Pointer<ffi.Void>, CGAffineTransform) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_1lznlw3(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>(
      wrapper,
      retain: false,
      release: true,
    );
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)> {
  void call(ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                CGAffineTransform arg1,
              )
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, CGAffineTransform)>()(
        ref.pointer,
        arg0,
        arg1,
      );
}

enum UIDynamicItemCollisionBoundsType {
  UIDynamicItemCollisionBoundsTypeRectangle(0),
  UIDynamicItemCollisionBoundsTypeEllipse(1),
  UIDynamicItemCollisionBoundsTypePath(2);

  final int value;
  const UIDynamicItemCollisionBoundsType(this.value);

  static UIDynamicItemCollisionBoundsType fromValue(int value) => switch (value) {
    0 => UIDynamicItemCollisionBoundsTypeRectangle,
    1 => UIDynamicItemCollisionBoundsTypeEllipse,
    2 => UIDynamicItemCollisionBoundsTypePath,
    _ => throw ArgumentError('Unknown value for UIDynamicItemCollisionBoundsType: $value'),
  };
}

late final _sel_collisionBoundsType = objc.registerName("collisionBoundsType");
final _objc_msgSend_k9iunc = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
int _ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>>()
    .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
      _ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid_fnPtrTrampoline,
      0,
    ).cast();
int _ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
      _ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid_closureTrampoline,
      0,
    ).cast();

/// Construction methods for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> fromFunction(
    UIDynamicItemCollisionBoundsType Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid_closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).value,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> {
  UIDynamicItemCollisionBoundsType call(ffi.Pointer<ffi.Void> arg0) => UIDynamicItemCollisionBoundsType.fromValue(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)
          >
        >()
        .asFunction<int Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
  );
}

/// WARNING: UIBezierPath is a stub. To generate bindings for this class, include
/// UIBezierPath in your config's objc-interfaces list.
///
/// UIBezierPath
class UIBezierPath extends objc.ObjCObjectBase {
  UIBezierPath._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIBezierPath] that points to the same underlying object as [other].
  UIBezierPath.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIBezierPath] that wraps the given raw object pointer.
  UIBezierPath.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_collisionBoundingPath = objc.registerName("collisionBoundingPath");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIBezierPath_ffiVoid_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>>()
    .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIBezierPath_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
        >(_ObjCBlock_UIBezierPath_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIBezierPath_ffiVoid_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIBezierPath_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
        >(_ObjCBlock_UIBezierPath_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIBezierPath_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_ObjCBlock_UIBezierPath_ffiVoid_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)> fromFunction(
    UIBezierPath Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _ObjCBlock_UIBezierPath_ffiVoid_closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIBezierPath_ffiVoid_CallExtension on objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)> {
  UIBezierPath call(ffi.Pointer<ffi.Void> arg0) => UIBezierPath.castFromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)
          >
        >()
        .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(
      ref.pointer,
      arg0,
    ),
    retain: true,
    release: true,
  );
}

late final _sel_convertPoint_toCoordinateSpace_ = objc.registerName("convertPoint:toCoordinateSpace:");
objc.CGPoint _ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGPoint arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) =>
    block.ref.target
        .cast<
          ffi.NativeFunction<
            objc.CGPoint Function(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1, ffi.Pointer<objc.ObjCObject> arg2)
          >
        >()
        .asFunction<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>()(
      arg0,
      arg1,
      arg2,
    );
ffi.Pointer<ffi.Void> _ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace_fnPtrCallable =
    ffi.Pointer.fromFunction<
          objc.CGPoint Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            objc.CGPoint,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace_fnPtrTrampoline)
        .cast();
objc.CGPoint _ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGPoint arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) =>
    (objc.getBlockClosure(block)
        as objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void> _ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace_closureCallable =
    ffi.Pointer.fromFunction<
          objc.CGPoint Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            objc.CGPoint,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        objc.CGPoint Function(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1, ffi.Pointer<objc.ObjCObject> arg2)
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>(
    objc.newPointerBlock(_ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>
  fromFunction(
    objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, UICoordinateSpace) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>(
    objc.newClosureBlock(
      _ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1, ffi.Pointer<objc.ObjCObject> arg2) =>
          fn(arg0, arg1, UICoordinateSpace.castFromPointer(arg2, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace_CallExtension
    on objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)> {
  objc.CGPoint call(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1, UICoordinateSpace arg2) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          objc.CGPoint Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.CGPoint arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        objc.CGPoint Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(ref.pointer, arg0, arg1, arg2.ref.pointer);
}

late final _sel_convertPoint_fromCoordinateSpace_ = objc.registerName("convertPoint:fromCoordinateSpace:");
late final _sel_convertRect_toCoordinateSpace_ = objc.registerName("convertRect:toCoordinateSpace:");
objc.CGRect _ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGRect arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) =>
    block.ref.target
        .cast<
          ffi.NativeFunction<
            objc.CGRect Function(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1, ffi.Pointer<objc.ObjCObject> arg2)
          >
        >()
        .asFunction<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>()(
      arg0,
      arg1,
      arg2,
    );
ffi.Pointer<ffi.Void> _ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace_fnPtrCallable =
    ffi.Pointer.fromFunction<
          objc.CGRect Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            objc.CGRect,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace_fnPtrTrampoline)
        .cast();
objc.CGRect _ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGRect arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) =>
    (objc.getBlockClosure(block)
        as objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void> _ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace_closureCallable =
    ffi.Pointer.fromFunction<
          objc.CGRect Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            objc.CGRect,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        objc.CGRect Function(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1, ffi.Pointer<objc.ObjCObject> arg2)
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>(
    objc.newPointerBlock(_ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>
  fromFunction(
    objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, UICoordinateSpace) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>(
    objc.newClosureBlock(
      _ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1, ffi.Pointer<objc.ObjCObject> arg2) =>
          fn(arg0, arg1, UICoordinateSpace.castFromPointer(arg2, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace_CallExtension
    on objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)> {
  objc.CGRect call(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1, UICoordinateSpace arg2) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          objc.CGRect Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.CGRect arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(ref.pointer, arg0, arg1, arg2.ref.pointer);
}

late final _sel_convertRect_fromCoordinateSpace_ = objc.registerName("convertRect:fromCoordinateSpace:");
late final _sel_isTransparentFocusItem = objc.registerName("isTransparentFocusItem");

/// WARNING: UIFocusMovementHint is a stub. To generate bindings for this class, include
/// UIFocusMovementHint in your config's objc-interfaces list.
///
/// UIFocusMovementHint
class UIFocusMovementHint extends objc.ObjCObjectBase {
  UIFocusMovementHint._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIFocusMovementHint] that points to the same underlying object as [other].
  UIFocusMovementHint.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusMovementHint] that wraps the given raw object pointer.
  UIFocusMovementHint.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_didHintFocusMovement_ = objc.registerName("didHintFocusMovement:");
void _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
    .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
>
_ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.isolateLocal(_ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>(
    objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>(
    objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, UIFocusMovementHint.castFromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)> listener(
    void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, UIFocusMovementHint.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)> blocking(
    void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, UIFocusMovementHint.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, UIFocusMovementHint.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>(
      wrapper,
      retain: false,
      release: true,
    );
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)> {
  void call(ffi.Pointer<ffi.Void> arg0, UIFocusMovementHint arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_displayLayer_ = objc.registerName("displayLayer:");
void _ObjCBlock_ffiVoid_ffiVoid_CALayer_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
    .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_CALayer_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_ffiVoid_ffiVoid_CALayer_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CALayer_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_CALayer_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_ffiVoid_ffiVoid_CALayer_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CALayer_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
>
_ObjCBlock_ffiVoid_ffiVoid_CALayer_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_CALayer_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_CALayer_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_CALayer_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.isolateLocal(_ObjCBlock_ffiVoid_ffiVoid_CALayer_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_CALayer_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_CALayer_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CALayer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(
    objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_CALayer_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, CALayer) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(
    objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_CALayer_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, CALayer.castFromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)> listener(
    void Function(ffi.Pointer<ffi.Void>, CALayer) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_CALayer_listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, CALayer.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)> blocking(
    void Function(ffi.Pointer<ffi.Void>, CALayer) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_CALayer_blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, CALayer.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_CALayer_blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, CALayer.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CALayer_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)> {
  void call(ffi.Pointer<ffi.Void> arg0, CALayer arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_drawLayer_inContext_ = objc.registerName("drawLayer:inContext:");
final _objc_msgSend_a4xp11 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<CGContext>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<CGContext>,
      )
    >();
void _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<CGContext> arg2,
) =>
    block.ref.target
        .cast<
          ffi.NativeFunction<
            ffi.Void Function(
              ffi.Pointer<ffi.Void> arg0,
              ffi.Pointer<objc.ObjCObject> arg1,
              ffi.Pointer<CGContext> arg2,
            )
          >
        >()
        .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<CGContext>)>()(
      arg0,
      arg1,
      arg2,
    );
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<CGContext>,
          )
        >(_ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<CGContext> arg2,
) =>
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<CGContext>))(
      arg0,
      arg1,
      arg2,
    );
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<CGContext>,
          )
        >(_ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<CGContext> arg2,
) {
  (objc.getBlockClosure(block)
      as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<CGContext>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<CGContext>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<CGContext>,
        )
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<CGContext> arg2,
) {
  try {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<CGContext>))(
      arg0,
      arg1,
      arg2,
    );
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<CGContext>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<CGContext>,
        )
      >.isolateLocal(_ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<CGContext>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<CGContext>,
        )
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<CGContext> arg2)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>(
    objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>(
    objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<CGContext> arg2) =>
          fn(arg0, CALayer.castFromPointer(arg1, retain: true, release: true), arg2),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)> listener(
    void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<CGContext> arg2) =>
          fn(arg0, CALayer.castFromPointer(arg1, retain: false, release: true), arg2),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_qvcerx(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)> blocking(
    void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<CGContext> arg2) =>
          fn(arg0, CALayer.castFromPointer(arg1, retain: false, release: true), arg2),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<CGContext> arg2) =>
          fn(arg0, CALayer.castFromPointer(arg1, retain: false, release: true), arg2),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_qvcerx(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)> {
  void call(ffi.Pointer<ffi.Void> arg0, CALayer arg1, ffi.Pointer<CGContext> arg2) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<CGContext> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<CGContext>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2);
}

late final _sel_layerWillDraw_ = objc.registerName("layerWillDraw:");
late final _sel_layoutSublayersOfLayer_ = objc.registerName("layoutSublayersOfLayer:");

/// WARNING: CAAction is a stub. To generate bindings for this class, include
/// CAAction in your config's objc-protocols list.
///
/// CAAction
interface class CAAction extends objc.ObjCProtocolBase {
  CAAction._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [CAAction] that points to the same underlying object as [other].
  CAAction.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CAAction] that wraps the given raw object pointer.
  CAAction.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_actionForLayer_forKey_ = objc.registerName("actionForLayer:forKey:");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_idCAAction_ffiVoid_CALayer_NSString_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) => block.ref.target
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void> _ObjCBlock_idCAAction_ffiVoid_CALayer_NSString_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_idCAAction_ffiVoid_CALayer_NSString_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_idCAAction_ffiVoid_CALayer_NSString_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) =>
    (objc.getBlockClosure(block)
        as ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        ))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void> _ObjCBlock_idCAAction_ffiVoid_CALayer_NSString_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_idCAAction_ffiVoid_CALayer_NSString_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>`.
abstract final class ObjCBlock_idCAAction_ffiVoid_CALayer_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>(
    objc.newPointerBlock(_ObjCBlock_idCAAction_ffiVoid_CALayer_NSString_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>
  fromFunction(CAAction? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString) fn, {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>(
        objc.newClosureBlock(
          _ObjCBlock_idCAAction_ffiVoid_CALayer_NSString_closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) =>
              fn(
                arg0,
                CALayer.castFromPointer(arg1, retain: true, release: true),
                objc.NSString.castFromPointer(arg2, retain: true, release: true),
              )?.ref.retainAndAutorelease() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>`.
extension ObjCBlock_idCAAction_ffiVoid_CALayer_NSString_CallExtension
    on objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)> {
  CAAction? call(ffi.Pointer<ffi.Void> arg0, CALayer arg1, objc.NSString arg2) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer)
              .address ==
          0
      ? null
      : CAAction.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer),
          retain: true,
          release: true,
        );
}

/// UIView
class UIView extends UIResponder
    implements
        objc.NSCoding,
        UIAppearance,
        UIAppearanceContainer,
        UIDynamicItem,
        UITraitEnvironment,
        UICoordinateSpace,
        UIFocusItem,
        UIFocusItemContainer,
        CALayerDelegate {
  UIView._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIView', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIView] that points to the same underlying object as [other].
  UIView.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIView] that wraps the given raw object pointer.
  UIView.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIView].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIView);
  }

  /// layerClass
  static objc.ObjCObjectBase getLayerClass() {
    objc.checkOsVersionInternal('UIView.layerClass', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIView, _sel_layerClass);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute(
    UISemanticContentAttribute attribute,
  ) {
    objc.checkOsVersionInternal(
      'UIView.userInterfaceLayoutDirectionForSemanticContentAttribute:',
      iOS: (false, (9, 0, 0)),
    );
    final _ret = _objc_msgSend_racczx(
      _class_UIView,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
      attribute.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute$1(
    UISemanticContentAttribute semanticContentAttribute, {
    required UIUserInterfaceLayoutDirection relativeToLayoutDirection,
  }) {
    objc.checkOsVersionInternal(
      'UIView.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
      iOS: (false, (10, 0, 0)),
    );
    final _ret = _objc_msgSend_tz4p54(
      _class_UIView,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
      semanticContentAttribute.value,
      relativeToLayoutDirection.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// new
  static UIView new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIView, _sel_new);
    return UIView.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIView allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(_class_UIView, _sel_allocWithZone_, zone);
    return UIView.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UIView alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UIView, _sel_alloc);
    return UIView.castFromPointer(_ret, retain: false, release: true);
  }

  /// appearance
  static UIView appearance() {
    final _ret = _objc_msgSend_151sglz(_class_UIView, _sel_appearance);
    return UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceWhenContainedIn:
  static UIView appearanceWhenContainedIn(UIAppearanceContainer? ContainerClass) {
    objc.checkOsVersionInternal('UIView.appearanceWhenContainedIn:', iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
      _class_UIView,
      _sel_appearanceWhenContainedIn_,
      ContainerClass?.ref.pointer ?? ffi.nullptr,
    );
    return UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceWhenContainedInInstancesOfClasses:
  static UIView appearanceWhenContainedInInstancesOfClasses(objc.NSArray containerTypes) {
    objc.checkOsVersionInternal('UIView.appearanceWhenContainedInInstancesOfClasses:', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
      _class_UIView,
      _sel_appearanceWhenContainedInInstancesOfClasses_,
      containerTypes.ref.pointer,
    );
    return UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:
  static UIView appearanceForTraitCollection(UITraitCollection trait) {
    objc.checkOsVersionInternal('UIView.appearanceForTraitCollection:', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_UIView, _sel_appearanceForTraitCollection_, trait.ref.pointer);
    return UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedIn:
  static UIView appearanceForTraitCollection$1(UITraitCollection trait, {UIAppearanceContainer? whenContainedIn}) {
    objc.checkOsVersionInternal('UIView.appearanceForTraitCollection:whenContainedIn:', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_15qeuct(
      _class_UIView,
      _sel_appearanceForTraitCollection_whenContainedIn_,
      trait.ref.pointer,
      whenContainedIn?.ref.pointer ?? ffi.nullptr,
    );
    return UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedInInstancesOfClasses:
  static UIView appearanceForTraitCollection$2(
    UITraitCollection trait, {
    required objc.NSArray whenContainedInInstancesOfClasses,
  }) {
    objc.checkOsVersionInternal(
      'UIView.appearanceForTraitCollection:whenContainedInInstancesOfClasses:',
      iOS: (false, (9, 0, 0)),
    );
    final _ret = _objc_msgSend_15qeuct(
      _class_UIView,
      _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_,
      trait.ref.pointer,
      whenContainedInInstancesOfClasses.ref.pointer,
    );
    return UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of UIView constructed with the default `new` method.
  factory UIView() => new$();
}

extension UIView$Methods on UIView {
  /// initWithFrame:
  UIView initWithFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal('UIView.initWithFrame:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_15yz4e6(this.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return UIView.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIView? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0 ? null : UIView.castFromPointer(_ret, retain: false, release: true);
  }

  /// isUserInteractionEnabled
  bool get userInteractionEnabled {
    objc.checkOsVersionInternal('UIView.isUserInteractionEnabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isUserInteractionEnabled);
  }

  /// setUserInteractionEnabled:
  set userInteractionEnabled(bool value) {
    objc.checkOsVersionInternal('UIView.setUserInteractionEnabled:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setUserInteractionEnabled_, value);
  }

  /// tag
  int get tag {
    objc.checkOsVersionInternal('UIView.tag', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_tag);
  }

  /// setTag:
  set tag(int value) {
    objc.checkOsVersionInternal('UIView.setTag:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_4sp4xj(this.ref.pointer, _sel_setTag_, value);
  }

  /// layer
  CALayer get layer {
    objc.checkOsVersionInternal('UIView.layer', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_layer);
    return CALayer.castFromPointer(_ret, retain: true, release: true);
  }

  /// Indicates whether or not this item is currently allowed to become focused.
  /// Returning NO restricts the item from being focusable, even if it is visible in the user interface. For example, UIControls return NO if they are disabled.
  bool get canBecomeFocused {
    objc.checkOsVersionInternal('UIView.canBecomeFocused', iOS: (false, (10, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_canBecomeFocused);
  }

  /// isFocused
  bool get focused {
    objc.checkOsVersionInternal('UIView.isFocused', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isFocused);
  }

  /// The identifier of the focus group that this view belongs to. If this is nil, subviews inherit their superview's focus group.
  objc.NSString? get focusGroupIdentifier {
    objc.checkOsVersionInternal('UIView.focusGroupIdentifier', iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_focusGroupIdentifier);
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The identifier of the focus group that this view belongs to. If this is nil, subviews inherit their superview's focus group.
  set focusGroupIdentifier(objc.NSString? value) {
    objc.checkOsVersionInternal('UIView.setFocusGroupIdentifier:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setFocusGroupIdentifier_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The priority this item has in its focus group. The higher the priority, the more likely it is to get picked when focus moves into this group.
  /// Note: this method can only be used to increase an item's priority, not decrease it. For example if an item is currently selected, the actual priority of this item will be determined by MAX(focusGroupPriority, UIFocusGroupPrioritySelected).
  int get focusGroupPriority {
    objc.checkOsVersionInternal('UIView.focusGroupPriority', iOS: (false, (15, 0, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_focusGroupPriority);
  }

  /// The priority this item has in its focus group. The higher the priority, the more likely it is to get picked when focus moves into this group.
  /// Note: this method can only be used to increase an item's priority, not decrease it. For example if an item is currently selected, the actual priority of this item will be determined by MAX(focusGroupPriority, UIFocusGroupPrioritySelected).
  set focusGroupPriority(int value) {
    objc.checkOsVersionInternal('UIView.setFocusGroupPriority:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_4sp4xj(this.ref.pointer, _sel_setFocusGroupPriority_, value);
  }

  /// Describes a visual effect to apply when this item is focused. If this property is nil no effect will be applied when this view becomes focused.
  UIFocusEffect? get focusEffect {
    objc.checkOsVersionInternal('UIView.focusEffect', iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_focusEffect);
    return _ret.address == 0 ? null : UIFocusEffect.castFromPointer(_ret, retain: true, release: true);
  }

  /// Describes a visual effect to apply when this item is focused. If this property is nil no effect will be applied when this view becomes focused.
  set focusEffect(UIFocusEffect? value) {
    objc.checkOsVersionInternal('UIView.setFocusEffect:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setFocusEffect_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// semanticContentAttribute
  UISemanticContentAttribute get semanticContentAttribute {
    objc.checkOsVersionInternal('UIView.semanticContentAttribute', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_i2u4x4(this.ref.pointer, _sel_semanticContentAttribute);
    return UISemanticContentAttribute.fromValue(_ret);
  }

  /// setSemanticContentAttribute:
  set semanticContentAttribute(UISemanticContentAttribute value) {
    objc.checkOsVersionInternal('UIView.setSemanticContentAttribute:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_162qwxu(this.ref.pointer, _sel_setSemanticContentAttribute_, value.value);
  }

  /// effectiveUserInterfaceLayoutDirection
  UIUserInterfaceLayoutDirection get effectiveUserInterfaceLayoutDirection {
    objc.checkOsVersionInternal('UIView.effectiveUserInterfaceLayoutDirection', iOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_qj4fey(this.ref.pointer, _sel_effectiveUserInterfaceLayoutDirection);
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// init
  UIView init() {
    objc.checkOsVersionInternal('UIView.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIView.castFromPointer(_ret, retain: false, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// center
  objc.CGPoint get center {
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret(_ptr, this.ref.pointer, _sel_center)
        : _ptr.ref = _objc_msgSend_1uwdhlk(this.ref.pointer, _sel_center);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// setCenter:
  set center(objc.CGPoint value) {
    _objc_msgSend_iy8iz6(this.ref.pointer, _sel_setCenter_, value);
  }

  /// bounds
  objc.CGRect get bounds {
    objc.checkOsVersionInternal('UIView.bounds', iOS: (false, (8, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(_ptr, this.ref.pointer, _sel_bounds)
        : _ptr.ref = _objc_msgSend_bu1hbw(this.ref.pointer, _sel_bounds);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// transform
  CGAffineTransform get transform {
    final _ptr = pkg_ffi.calloc<CGAffineTransform>();
    objc.useMsgSendVariants
        ? _objc_msgSend_5qswvjStret(_ptr, this.ref.pointer, _sel_transform)
        : _ptr.ref = _objc_msgSend_5qswvj(this.ref.pointer, _sel_transform);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<CGAffineTransform>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<CGAffineTransform>(_finalizable);
  }

  /// setTransform:
  set transform(CGAffineTransform value) {
    _objc_msgSend_qgt66z(this.ref.pointer, _sel_setTransform_, value);
  }

  /// The collision type represents how the dynamics system will evaluate collisions with
  /// respect to the dynamic item. defaults to UIDynamicItemCollisionBoundsTypeRectangle
  UIDynamicItemCollisionBoundsType get collisionBoundsType {
    objc.checkOsVersionInternal('UIView.collisionBoundsType', iOS: (false, (9, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_collisionBoundsType)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'collisionBoundsType');
    }
    final _ret = _objc_msgSend_k9iunc(this.ref.pointer, _sel_collisionBoundsType);
    return UIDynamicItemCollisionBoundsType.fromValue(_ret);
  }

  /// The path must represent a convex polygon with counter clockwise winding and no self intersection.
  /// The point (0,0) in the path corresponds to the dynamic item's center.
  UIBezierPath get collisionBoundingPath {
    objc.checkOsVersionInternal('UIView.collisionBoundingPath', iOS: (false, (9, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_collisionBoundingPath)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'collisionBoundingPath');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_collisionBoundingPath);
    return UIBezierPath.castFromPointer(_ret, retain: true, release: true);
  }

  /// traitCollection
  UITraitCollection get traitCollection {
    objc.checkOsVersionInternal('UIView.traitCollection', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_traitCollection);
    return UITraitCollection.castFromPointer(_ret, retain: true, release: true);
  }

  /// ! To be overridden as needed to provide custom behavior when the environment's traits change.
  void traitCollectionDidChange(UITraitCollection? previousTraitCollection) {
    objc.checkOsVersionInternal('UIView.traitCollectionDidChange:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(
      this.ref.pointer,
      _sel_traitCollectionDidChange_,
      previousTraitCollection?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// convertPoint:toCoordinateSpace:
  objc.CGPoint convertPoint(objc.CGPoint point, {required UICoordinateSpace toCoordinateSpace}) {
    objc.checkOsVersionInternal('UIView.convertPoint:toCoordinateSpace:', iOS: (false, (8, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            _ptr,
            this.ref.pointer,
            _sel_convertPoint_toCoordinateSpace_,
            point,
            toCoordinateSpace.ref.pointer,
          )
        : _ptr.ref = _objc_msgSend_3l1tu1(
            this.ref.pointer,
            _sel_convertPoint_toCoordinateSpace_,
            point,
            toCoordinateSpace.ref.pointer,
          );
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// convertPoint:fromCoordinateSpace:
  objc.CGPoint convertPoint$1(objc.CGPoint point, {required UICoordinateSpace fromCoordinateSpace}) {
    objc.checkOsVersionInternal('UIView.convertPoint:fromCoordinateSpace:', iOS: (false, (8, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            _ptr,
            this.ref.pointer,
            _sel_convertPoint_fromCoordinateSpace_,
            point,
            fromCoordinateSpace.ref.pointer,
          )
        : _ptr.ref = _objc_msgSend_3l1tu1(
            this.ref.pointer,
            _sel_convertPoint_fromCoordinateSpace_,
            point,
            fromCoordinateSpace.ref.pointer,
          );
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// convertRect:toCoordinateSpace:
  objc.CGRect convertRect(objc.CGRect rect, {required UICoordinateSpace toCoordinateSpace}) {
    objc.checkOsVersionInternal('UIView.convertRect:toCoordinateSpace:', iOS: (false, (8, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            _ptr,
            this.ref.pointer,
            _sel_convertRect_toCoordinateSpace_,
            rect,
            toCoordinateSpace.ref.pointer,
          )
        : _ptr.ref = _objc_msgSend_2olghr(
            this.ref.pointer,
            _sel_convertRect_toCoordinateSpace_,
            rect,
            toCoordinateSpace.ref.pointer,
          );
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// convertRect:fromCoordinateSpace:
  objc.CGRect convertRect$1(objc.CGRect rect, {required UICoordinateSpace fromCoordinateSpace}) {
    objc.checkOsVersionInternal('UIView.convertRect:fromCoordinateSpace:', iOS: (false, (8, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            _ptr,
            this.ref.pointer,
            _sel_convertRect_fromCoordinateSpace_,
            rect,
            fromCoordinateSpace.ref.pointer,
          )
        : _ptr.ref = _objc_msgSend_2olghr(
            this.ref.pointer,
            _sel_convertRect_fromCoordinateSpace_,
            rect,
            fromCoordinateSpace.ref.pointer,
          );
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// The geometric frame of this item, represented in the `coordinateSpace` of the UIFocusItemContainer in which it is contained.
  objc.CGRect get frame {
    objc.checkOsVersionInternal('UIView.frame', iOS: (false, (12, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(_ptr, this.ref.pointer, _sel_frame)
        : _ptr.ref = _objc_msgSend_bu1hbw(this.ref.pointer, _sel_frame);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// If this returns YES, the focus item is considered transparent in terms of occlusion. Items that are behind it are focusable.
  /// This value is ignored when the item is focusable, in which case the item is never considered transparent.
  bool get isTransparentFocusItem {
    objc.checkOsVersionInternal('UIView.isTransparentFocusItem', iOS: (false, (15, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_isTransparentFocusItem)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'isTransparentFocusItem');
    }
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isTransparentFocusItem);
  }

  /// Called whenever this focus item is hinting to the user a focus movement might occur.
  /// The provided object is mutated by the focus engine whenever the user's finger moves.
  void didHintFocusMovement(UIFocusMovementHint hint) {
    objc.checkOsVersionInternal('UIView.didHintFocusMovement:', iOS: (false, (12, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_didHintFocusMovement_)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'didHintFocusMovement:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_didHintFocusMovement_, hint.ref.pointer);
  }

  /// The preferred focus environments define where to search for the default focused item in an environment, such as when focus updates programmatically.
  /// Starting from the target environment, each preferred focus environment is recursively searched in the order of the array until an eligible, focusable item is found.
  /// Preferred focus environments can include focusable and non-focusable items, in addition to non-item environments. Returning an empty array is equivalent to returning an array containing only 'self'.
  objc.NSArray get preferredFocusEnvironments {
    objc.checkOsVersionInternal('UIView.preferredFocusEnvironments', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_preferredFocusEnvironments);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// The parent focus environment of this environment, or nil if no parent exists.
  /// NOTE: If you implement this method, you must return a non-nil value for parent focus environment, otherwise your focus environment will not participate in focus interactions.
  UIFocusEnvironment? get parentFocusEnvironment {
    objc.checkOsVersionInternal('UIView.parentFocusEnvironment', iOS: (false, (12, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_parentFocusEnvironment);
    return _ret.address == 0 ? null : UIFocusEnvironment.castFromPointer(_ret, retain: true, release: true);
  }

  /// The container of any child focus items in this focus environment, or nil if no container exists.
  UIFocusItemContainer? get focusItemContainer {
    objc.checkOsVersionInternal('UIView.focusItemContainer', iOS: (false, (12, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_focusItemContainer);
    return _ret.address == 0 ? null : UIFocusItemContainer.castFromPointer(_ret, retain: true, release: true);
  }

  /// Marks this environment as needing a focus update, which if accepted will attempt to reset focus to this environment, or one of its preferred focus environments, on the next update cycle. If this environment does not currently contain the focused item, then calling this method has no effect. If a parent of this environment is also requesting focus, then this environment's request is rejected in favor of the parent's.
  /// NOTE: If you provide your own implementation, it must call `[[UIFocusSystem focusSystemForEnvironment:self] requestFocusUpdateToEnvironment:self]`;
  void setNeedsFocusUpdate() {
    objc.checkOsVersionInternal('UIView.setNeedsFocusUpdate', iOS: (false, (9, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsFocusUpdate);
  }

  /// Forces focus to be updated immediately. If there is an environment that has requested a focus update via -setNeedsFocusUpdate, and the request was accepted, then focus will be updated to that environment or one of its preferred focus environments.
  /// NOTE: If you provide your own implementation, it must call `[[UIFocusSystem focusSystemForEnvironment:self] updateFocusIfNeeded];`.
  void updateFocusIfNeeded() {
    objc.checkOsVersionInternal('UIView.updateFocusIfNeeded', iOS: (false, (9, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_updateFocusIfNeeded);
  }

  /// Asks whether the system should allow a focus update to occur.
  bool shouldUpdateFocusInContext(UIFocusUpdateContext context) {
    objc.checkOsVersionInternal('UIView.shouldUpdateFocusInContext:', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_19nvye5(this.ref.pointer, _sel_shouldUpdateFocusInContext_, context.ref.pointer);
  }

  /// Called when the screens focused item has been updated to a new item. Use the animation coordinator to schedule focus-related animations in response to the update.
  void didUpdateFocusInContext(
    UIFocusUpdateContext context, {
    required UIFocusAnimationCoordinator withAnimationCoordinator,
  }) {
    objc.checkOsVersionInternal('UIView.didUpdateFocusInContext:withAnimationCoordinator:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_didUpdateFocusInContext_withAnimationCoordinator_,
      context.ref.pointer,
      withAnimationCoordinator.ref.pointer,
    );
  }

  /// Specifies an identifier corresponding to a sound that should be played for a focus update.
  /// Return UIFocusSoundIdentifierNone to opt out of sounds, UIFocusSoundIdentifierDefault for the system
  /// default sounds, a previously registered identifier for a custom sound, or nil to defer the decision
  /// to the parent.
  objc.NSString? soundIdentifierForFocusUpdateInContext(UIFocusUpdateContext context) {
    objc.checkOsVersionInternal('UIView.soundIdentifierForFocusUpdateInContext:', iOS: (true, null));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_soundIdentifierForFocusUpdateInContext_)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'soundIdentifierForFocusUpdateInContext:');
    }
    final _ret = _objc_msgSend_1sotr3r(
      this.ref.pointer,
      _sel_soundIdentifierForFocusUpdateInContext_,
      context.ref.pointer,
    );
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// preferredFocusedView
  UIView? get preferredFocusedView {
    objc.checkOsVersionInternal('UIView.preferredFocusedView', iOS: (false, (9, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_preferredFocusedView)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'preferredFocusedView');
    }
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_preferredFocusedView);
    return _ret.address == 0 ? null : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// The coordinate space of the focus items contained in this container. The focus items returned by focusItemsInRect: should report their frames in this coordinate space.
  /// If you are implementing this protocol, you may find it convenient to return the UIScreen as your coordinate space, and ensure that your contained items report their frames in screen space.
  /// Similarly, you might find that your focus items' containing UIView or UIWindow is the most convenient coordinate space to use.
  /// You may also choose to implement your own object that conforms to UICoordinateSpace, if that is the most natural solution for your architecture.
  UICoordinateSpace get coordinateSpace {
    objc.checkOsVersionInternal('UIView.coordinateSpace', iOS: (false, (12, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_coordinateSpace);
    return UICoordinateSpace.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an array of all focus items within this container that intersect with the provided rect. `rect` is expressed in `coordinateSpace`.
  objc.NSArray focusItemsInRect(objc.CGRect rect) {
    objc.checkOsVersionInternal('UIView.focusItemsInRect:', iOS: (false, (12, 0, 0)));
    final _ret = _objc_msgSend_15yz4e6(this.ref.pointer, _sel_focusItemsInRect_, rect);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// displayLayer:
  void displayLayer(CALayer layer$1) {
    objc.checkOsVersionInternal('UIView.displayLayer:', iOS: (false, (10, 0, 0)), macOS: (false, (10, 12, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_displayLayer_)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'displayLayer:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_displayLayer_, layer$1.ref.pointer);
  }

  /// drawLayer:inContext:
  void drawLayer(CALayer layer$1, {required ffi.Pointer<CGContext> inContext}) {
    objc.checkOsVersionInternal('UIView.drawLayer:inContext:', iOS: (false, (10, 0, 0)), macOS: (false, (10, 12, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_drawLayer_inContext_)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'drawLayer:inContext:');
    }
    _objc_msgSend_a4xp11(this.ref.pointer, _sel_drawLayer_inContext_, layer$1.ref.pointer, inContext);
  }

  /// layerWillDraw:
  void layerWillDraw(CALayer layer$1) {
    objc.checkOsVersionInternal('UIView.layerWillDraw:', iOS: (false, (10, 0, 0)), macOS: (false, (10, 12, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_layerWillDraw_)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'layerWillDraw:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_layerWillDraw_, layer$1.ref.pointer);
  }

  /// layoutSublayersOfLayer:
  void layoutSublayersOfLayer(CALayer layer$1) {
    objc.checkOsVersionInternal(
      'UIView.layoutSublayersOfLayer:',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
    if (!objc.respondsToSelector(this.ref.pointer, _sel_layoutSublayersOfLayer_)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'layoutSublayersOfLayer:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_layoutSublayersOfLayer_, layer$1.ref.pointer);
  }

  /// actionForLayer:forKey:
  CAAction? actionForLayer(CALayer layer$1, {required objc.NSString forKey}) {
    objc.checkOsVersionInternal('UIView.actionForLayer:forKey:', iOS: (false, (10, 0, 0)), macOS: (false, (10, 12, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_actionForLayer_forKey_)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'actionForLayer:forKey:');
    }
    final _ret = _objc_msgSend_15qeuct(
      this.ref.pointer,
      _sel_actionForLayer_forKey_,
      layer$1.ref.pointer,
      forKey.ref.pointer,
    );
    return _ret.address == 0 ? null : CAAction.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_inputView = objc.registerName("inputView");
late final _sel_inputAccessoryView = objc.registerName("inputAccessoryView");

/// WARNING: UITextInputAssistantItem is a stub. To generate bindings for this class, include
/// UITextInputAssistantItem in your config's objc-interfaces list.
///
/// UITextInputAssistantItem
class UITextInputAssistantItem extends objc.NSObject {
  UITextInputAssistantItem._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITextInputAssistantItem', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UITextInputAssistantItem] that points to the same underlying object as [other].
  UITextInputAssistantItem.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITextInputAssistantItem] that wraps the given raw object pointer.
  UITextInputAssistantItem.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_inputAssistantItem = objc.registerName("inputAssistantItem");

/// WARNING: UIInputViewController is a stub. To generate bindings for this class, include
/// UIInputViewController in your config's objc-interfaces list.
///
/// UIInputViewController
class UIInputViewController extends objc.ObjCObjectBase {
  UIInputViewController._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIInputViewController] that points to the same underlying object as [other].
  UIInputViewController.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIInputViewController] that wraps the given raw object pointer.
  UIInputViewController.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_inputViewController = objc.registerName("inputViewController");
late final _sel_inputAccessoryViewController = objc.registerName("inputAccessoryViewController");

/// WARNING: UITextInputMode is a stub. To generate bindings for this class, include
/// UITextInputMode in your config's objc-interfaces list.
///
/// UITextInputMode
class UITextInputMode extends objc.NSObject implements objc.NSSecureCoding {
  UITextInputMode._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITextInputMode', iOS: (false, (4, 2, 0)));
  }

  /// Constructs a [UITextInputMode] that points to the same underlying object as [other].
  UITextInputMode.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITextInputMode] that wraps the given raw object pointer.
  UITextInputMode.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_textInputMode = objc.registerName("textInputMode");
late final _sel_textInputContextIdentifier = objc.registerName("textInputContextIdentifier");
late final _sel_clearTextInputContextIdentifier_ = objc.registerName("clearTextInputContextIdentifier:");
late final _sel_reloadInputViews = objc.registerName("reloadInputViews");

/// UIResponderInputViewAdditions
extension UIResponderInputViewAdditions on UIResponder {
  /// inputView
  UIView? get inputView {
    objc.checkOsVersionInternal('UIResponder.inputView', iOS: (false, (3, 2, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_inputView);
    return _ret.address == 0 ? null : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// inputAccessoryView
  UIView? get inputAccessoryView {
    objc.checkOsVersionInternal('UIResponder.inputAccessoryView', iOS: (false, (3, 2, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_inputAccessoryView);
    return _ret.address == 0 ? null : UIView.castFromPointer(_ret, retain: true, release: true);
  }

  /// This method is for clients that wish to put buttons on the Shortcuts Bar, shown on top of the keyboard.
  /// You may modify the returned inputAssistantItem to add to or replace the existing items on the bar.
  /// Modifications made to the returned UITextInputAssistantItem are reflected automatically.
  /// This method should not be overridden. Goes up the responder chain.
  UITextInputAssistantItem get inputAssistantItem {
    objc.checkOsVersionInternal('UIResponder.inputAssistantItem', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_inputAssistantItem);
    return UITextInputAssistantItem.castFromPointer(_ret, retain: true, release: true);
  }

  /// inputViewController
  UIInputViewController? get inputViewController {
    objc.checkOsVersionInternal('UIResponder.inputViewController', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_inputViewController);
    return _ret.address == 0 ? null : UIInputViewController.castFromPointer(_ret, retain: true, release: true);
  }

  /// inputAccessoryViewController
  UIInputViewController? get inputAccessoryViewController {
    objc.checkOsVersionInternal('UIResponder.inputAccessoryViewController', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_inputAccessoryViewController);
    return _ret.address == 0 ? null : UIInputViewController.castFromPointer(_ret, retain: true, release: true);
  }

  /// textInputMode
  UITextInputMode? get textInputMode {
    objc.checkOsVersionInternal('UIResponder.textInputMode', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textInputMode);
    return _ret.address == 0 ? null : UITextInputMode.castFromPointer(_ret, retain: true, release: true);
  }

  /// textInputContextIdentifier
  objc.NSString? get textInputContextIdentifier {
    objc.checkOsVersionInternal('UIResponder.textInputContextIdentifier', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textInputContextIdentifier);
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// clearTextInputContextIdentifier:
  static void clearTextInputContextIdentifier(objc.NSString identifier) {
    objc.checkOsVersionInternal('UIResponder.clearTextInputContextIdentifier:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_xtuoz7(_class_UIResponder, _sel_clearTextInputContextIdentifier_, identifier.ref.pointer);
  }

  /// reloadInputViews
  void reloadInputViews() {
    objc.checkOsVersionInternal('UIResponder.reloadInputViews', iOS: (false, (3, 2, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_reloadInputViews);
  }
}

late final _sel_userActivity = objc.registerName("userActivity");
late final _sel_setUserActivity_ = objc.registerName("setUserActivity:");
late final _sel_updateUserActivityState_ = objc.registerName("updateUserActivityState:");
late final _sel_restoreUserActivityState_ = objc.registerName("restoreUserActivityState:");
void _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
    .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
>
_ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.isolateLocal(_ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSUserActivity {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(
    objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, NSUserActivity) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(
    objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, NSUserActivity.castFromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)> listener(
    void Function(ffi.Pointer<ffi.Void>, NSUserActivity) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, NSUserActivity.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)> blocking(
    void Function(ffi.Pointer<ffi.Void>, NSUserActivity) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, NSUserActivity.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, NSUserActivity.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(
      wrapper,
      retain: false,
      release: true,
    );
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSUserActivity_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSUserActivity arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// ActivityContinuation
extension ActivityContinuation on UIResponder {
  /// userActivity
  NSUserActivity? get userActivity {
    objc.checkOsVersionInternal('UIResponder.userActivity', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_userActivity);
    return _ret.address == 0 ? null : NSUserActivity.castFromPointer(_ret, retain: true, release: true);
  }

  /// setUserActivity:
  set userActivity(NSUserActivity? value) {
    objc.checkOsVersionInternal('UIResponder.setUserActivity:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setUserActivity_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// updateUserActivityState:
  void updateUserActivityState(NSUserActivity activity) {
    objc.checkOsVersionInternal('UIResponder.updateUserActivityState:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_updateUserActivityState_, activity.ref.pointer);
  }

  /// restoreUserActivityState:
  void restoreUserActivityState(NSUserActivity userActivity$1) {
    objc.checkOsVersionInternal('UIResponder.restoreUserActivityState:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_restoreUserActivityState_, userActivity$1.ref.pointer);
  }
}

late final _sel_captureTextFromCamera_ = objc.registerName("captureTextFromCamera:");

/// UICaptureTextFromCameraSupporting
extension UICaptureTextFromCameraSupporting on UIResponder {
  /// captureTextFromCamera:
  void captureTextFromCamera(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.captureTextFromCamera:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_captureTextFromCamera_, sender?.ref.pointer ?? ffi.nullptr);
  }
}

late final _sel_nextResponder = objc.registerName("nextResponder");
late final _sel_canBecomeFirstResponder = objc.registerName("canBecomeFirstResponder");
late final _sel_becomeFirstResponder = objc.registerName("becomeFirstResponder");
late final _sel_canResignFirstResponder = objc.registerName("canResignFirstResponder");
late final _sel_resignFirstResponder = objc.registerName("resignFirstResponder");
late final _sel_isFirstResponder = objc.registerName("isFirstResponder");
late final _sel_touchesBegan_withEvent_ = objc.registerName("touchesBegan:withEvent:");
late final _sel_touchesMoved_withEvent_ = objc.registerName("touchesMoved:withEvent:");
late final _sel_touchesEnded_withEvent_ = objc.registerName("touchesEnded:withEvent:");
late final _sel_touchesCancelled_withEvent_ = objc.registerName("touchesCancelled:withEvent:");
late final _sel_touchesEstimatedPropertiesUpdated_ = objc.registerName("touchesEstimatedPropertiesUpdated:");

/// WARNING: UIPressesEvent is a stub. To generate bindings for this class, include
/// UIPressesEvent in your config's objc-interfaces list.
///
/// UIPressesEvent
class UIPressesEvent extends objc.ObjCObjectBase {
  UIPressesEvent._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIPressesEvent] that points to the same underlying object as [other].
  UIPressesEvent.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIPressesEvent] that wraps the given raw object pointer.
  UIPressesEvent.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_pressesBegan_withEvent_ = objc.registerName("pressesBegan:withEvent:");
late final _sel_pressesChanged_withEvent_ = objc.registerName("pressesChanged:withEvent:");
late final _sel_pressesEnded_withEvent_ = objc.registerName("pressesEnded:withEvent:");
late final _sel_pressesCancelled_withEvent_ = objc.registerName("pressesCancelled:withEvent:");
late final _sel_motionBegan_withEvent_ = objc.registerName("motionBegan:withEvent:");
final _objc_msgSend_pov02z = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int, ffi.Pointer<objc.ObjCObject>)
    >();
late final _sel_motionEnded_withEvent_ = objc.registerName("motionEnded:withEvent:");
late final _sel_motionCancelled_withEvent_ = objc.registerName("motionCancelled:withEvent:");
late final _sel_remoteControlReceivedWithEvent_ = objc.registerName("remoteControlReceivedWithEvent:");
late final _sel_canPerformAction_withSender_ = objc.registerName("canPerformAction:withSender:");
final _objc_msgSend_1f04296 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_targetForAction_withSender_ = objc.registerName("targetForAction:withSender:");

/// WARNING: UIMenuBuilder is a stub. To generate bindings for this class, include
/// UIMenuBuilder in your config's objc-protocols list.
///
/// UIMenuBuilder
interface class UIMenuBuilder extends objc.ObjCProtocolBase {
  UIMenuBuilder._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIMenuBuilder] that points to the same underlying object as [other].
  UIMenuBuilder.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIMenuBuilder] that wraps the given raw object pointer.
  UIMenuBuilder.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_buildMenuWithBuilder_ = objc.registerName("buildMenuWithBuilder:");
late final _sel_validateCommand_ = objc.registerName("validateCommand:");
late final _sel_undoManager = objc.registerName("undoManager");
late final _sel_editingInteractionConfiguration = objc.registerName("editingInteractionConfiguration");
final _objc_msgSend_15pfzxv = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_cut_ = objc.registerName("cut:");
void _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
    .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
>
_ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.isolateLocal(_ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_objcObjCObject {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
    objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
    objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> listener(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_objcObjCObject_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObjectBase? arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_copy_ = objc.registerName("copy:");
void _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
    .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
>
_ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.isolateLocal(_ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
  fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
    ptr,
  ) => objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
    objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
  fromFunction(void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?) fn, {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
        objc.newClosureBlock(
          _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
              fn(arg0, arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: true, release: true)),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
  listener(void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?) fn, {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
  blocking(void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?) fn, {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1_CallExtension
    on objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObjectBase? arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_paste_ = objc.registerName("paste:");
late final _sel_pasteAndMatchStyle_ = objc.registerName("pasteAndMatchStyle:");
late final _sel_pasteAndGo_ = objc.registerName("pasteAndGo:");
late final _sel_pasteAndSearch_ = objc.registerName("pasteAndSearch:");
late final _sel_select_ = objc.registerName("select:");
late final _sel_selectAll_ = objc.registerName("selectAll:");
late final _sel_delete_ = objc.registerName("delete:");
late final _sel_makeTextWritingDirectionLeftToRight_ = objc.registerName("makeTextWritingDirectionLeftToRight:");
late final _sel_makeTextWritingDirectionRightToLeft_ = objc.registerName("makeTextWritingDirectionRightToLeft:");
late final _sel_toggleBoldface_ = objc.registerName("toggleBoldface:");
late final _sel_toggleItalics_ = objc.registerName("toggleItalics:");
late final _sel_toggleUnderline_ = objc.registerName("toggleUnderline:");
late final _sel_increaseSize_ = objc.registerName("increaseSize:");
late final _sel_decreaseSize_ = objc.registerName("decreaseSize:");
late final _sel_updateTextAttributesWithConversionHandler_ = objc.registerName(
  "updateTextAttributesWithConversionHandler:",
);
void _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCBlockImpl> arg1,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1)>>()
    .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>)
        >(_ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCBlockImpl> arg1,
) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>)
        >(_ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCBlockImpl> arg1,
) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>)
>
_ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>)
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCBlockImpl> arg1,
) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCBlockImpl>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >.isolateLocal(_ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCBlockImpl>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
  >
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
  >
  fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1)>>
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
      >(
        objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
      >(
        objc.newClosureBlock(
          _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) =>
              fn(arg0, ObjCBlock_NSDictionary_NSDictionary.castFromPointer(arg1, retain: true, release: true)),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) =>
          fn(arg0, ObjCBlock_NSDictionary_NSDictionary.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_1l4hxwm(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) =>
          fn(arg0, ObjCBlock_NSDictionary_NSDictionary.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) =>
          fn(arg0, ObjCBlock_NSDictionary_NSDictionary.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_1l4hxwm(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
    >(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler_CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCBlockImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>)
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_print_ = objc.registerName("print:");

/// UIResponder
class UIResponder extends objc.NSObject implements UIResponderStandardEditActions {
  UIResponder._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIResponder', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIResponder] that points to the same underlying object as [other].
  UIResponder.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIResponder] that wraps the given raw object pointer.
  UIResponder.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIResponder].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIResponder);
  }

  /// new
  static UIResponder new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIResponder, _sel_new);
    return UIResponder.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIResponder allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(_class_UIResponder, _sel_allocWithZone_, zone);
    return UIResponder.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UIResponder alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UIResponder, _sel_alloc);
    return UIResponder.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of UIResponder constructed with the default `new` method.
  factory UIResponder() => new$();
}

extension UIResponder$Methods on UIResponder {
  /// nextResponder
  UIResponder? get nextResponder {
    objc.checkOsVersionInternal('UIResponder.nextResponder', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_nextResponder);
    return _ret.address == 0 ? null : UIResponder.castFromPointer(_ret, retain: true, release: true);
  }

  /// canBecomeFirstResponder
  bool get canBecomeFirstResponder {
    objc.checkOsVersionInternal('UIResponder.canBecomeFirstResponder', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_canBecomeFirstResponder);
  }

  /// becomeFirstResponder
  bool becomeFirstResponder() {
    objc.checkOsVersionInternal('UIResponder.becomeFirstResponder', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_becomeFirstResponder);
  }

  /// canResignFirstResponder
  bool get canResignFirstResponder {
    objc.checkOsVersionInternal('UIResponder.canResignFirstResponder', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_canResignFirstResponder);
  }

  /// resignFirstResponder
  bool resignFirstResponder() {
    objc.checkOsVersionInternal('UIResponder.resignFirstResponder', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_resignFirstResponder);
  }

  /// isFirstResponder
  bool get isFirstResponder {
    objc.checkOsVersionInternal('UIResponder.isFirstResponder', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isFirstResponder);
  }

  /// touchesBegan:withEvent:
  void touchesBegan(objc.NSSet touches, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.touchesBegan:withEvent:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_touchesBegan_withEvent_,
      touches.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// touchesMoved:withEvent:
  void touchesMoved(objc.NSSet touches, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.touchesMoved:withEvent:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_touchesMoved_withEvent_,
      touches.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// touchesEnded:withEvent:
  void touchesEnded(objc.NSSet touches, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.touchesEnded:withEvent:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_touchesEnded_withEvent_,
      touches.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// touchesCancelled:withEvent:
  void touchesCancelled(objc.NSSet touches, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.touchesCancelled:withEvent:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_touchesCancelled_withEvent_,
      touches.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// touchesEstimatedPropertiesUpdated:
  void touchesEstimatedPropertiesUpdated(objc.NSSet touches) {
    objc.checkOsVersionInternal('UIResponder.touchesEstimatedPropertiesUpdated:', iOS: (false, (9, 1, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_touchesEstimatedPropertiesUpdated_, touches.ref.pointer);
  }

  /// pressesBegan:withEvent:
  void pressesBegan(objc.NSSet presses, {UIPressesEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.pressesBegan:withEvent:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_pressesBegan_withEvent_,
      presses.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// pressesChanged:withEvent:
  void pressesChanged(objc.NSSet presses, {UIPressesEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.pressesChanged:withEvent:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_pressesChanged_withEvent_,
      presses.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// pressesEnded:withEvent:
  void pressesEnded(objc.NSSet presses, {UIPressesEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.pressesEnded:withEvent:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_pressesEnded_withEvent_,
      presses.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// pressesCancelled:withEvent:
  void pressesCancelled(objc.NSSet presses, {UIPressesEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.pressesCancelled:withEvent:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_pressesCancelled_withEvent_,
      presses.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// motionBegan:withEvent:
  void motionBegan(UIEventSubtype motion, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.motionBegan:withEvent:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_pov02z(
      this.ref.pointer,
      _sel_motionBegan_withEvent_,
      motion.value,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// motionEnded:withEvent:
  void motionEnded(UIEventSubtype motion, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.motionEnded:withEvent:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_pov02z(
      this.ref.pointer,
      _sel_motionEnded_withEvent_,
      motion.value,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// motionCancelled:withEvent:
  void motionCancelled(UIEventSubtype motion, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.motionCancelled:withEvent:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_pov02z(
      this.ref.pointer,
      _sel_motionCancelled_withEvent_,
      motion.value,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// remoteControlReceivedWithEvent:
  void remoteControlReceivedWithEvent(UIEvent? event) {
    objc.checkOsVersionInternal('UIResponder.remoteControlReceivedWithEvent:', iOS: (false, (4, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_remoteControlReceivedWithEvent_, event?.ref.pointer ?? ffi.nullptr);
  }

  /// canPerformAction:withSender:
  bool canPerformAction(ffi.Pointer<objc.ObjCSelector> action, {objc.ObjCObjectBase? withSender}) {
    objc.checkOsVersionInternal('UIResponder.canPerformAction:withSender:', iOS: (false, (3, 0, 0)));
    return _objc_msgSend_1f04296(
      this.ref.pointer,
      _sel_canPerformAction_withSender_,
      action,
      withSender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// targetForAction:withSender:
  objc.ObjCObjectBase? targetForAction(ffi.Pointer<objc.ObjCSelector> action, {objc.ObjCObjectBase? withSender}) {
    objc.checkOsVersionInternal('UIResponder.targetForAction:withSender:', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_gx50so(
      this.ref.pointer,
      _sel_targetForAction_withSender_,
      action,
      withSender?.ref.pointer ?? ffi.nullptr,
    );
    return _ret.address == 0 ? null : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// buildMenuWithBuilder:
  void buildMenuWithBuilder(UIMenuBuilder builder) {
    objc.checkOsVersionInternal('UIResponder.buildMenuWithBuilder:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_buildMenuWithBuilder_, builder.ref.pointer);
  }

  /// validateCommand:
  void validateCommand(UICommand command) {
    objc.checkOsVersionInternal('UIResponder.validateCommand:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_validateCommand_, command.ref.pointer);
  }

  /// undoManager
  NSUndoManager? get undoManager {
    objc.checkOsVersionInternal('UIResponder.undoManager', iOS: (false, (3, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_undoManager);
    return _ret.address == 0 ? null : NSUndoManager.castFromPointer(_ret, retain: true, release: true);
  }

  /// editingInteractionConfiguration
  UIEditingInteractionConfiguration get editingInteractionConfiguration {
    objc.checkOsVersionInternal('UIResponder.editingInteractionConfiguration', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_15pfzxv(this.ref.pointer, _sel_editingInteractionConfiguration);
    return UIEditingInteractionConfiguration.fromValue(_ret);
  }

  /// init
  UIResponder init() {
    objc.checkOsVersionInternal('UIResponder.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIResponder.castFromPointer(_ret, retain: false, release: true);
  }

  /// cut:
  void cut(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.cut:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_cut_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'cut:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_cut_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// copy:
  void copy(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.copy:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_copy_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'copy:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_copy_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// paste:
  void paste(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.paste:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_paste_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'paste:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_paste_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// pasteAndMatchStyle:
  void pasteAndMatchStyle(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.pasteAndMatchStyle:', iOS: (false, (15, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_pasteAndMatchStyle_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'pasteAndMatchStyle:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_pasteAndMatchStyle_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// pasteAndGo:
  void pasteAndGo(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.pasteAndGo:', iOS: (false, (15, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_pasteAndGo_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'pasteAndGo:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_pasteAndGo_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// pasteAndSearch:
  void pasteAndSearch(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.pasteAndSearch:', iOS: (false, (15, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_pasteAndSearch_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'pasteAndSearch:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_pasteAndSearch_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// select:
  void select(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.select:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_select_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'select:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_select_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// selectAll:
  void selectAll(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.selectAll:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_selectAll_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'selectAll:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_selectAll_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// delete:
  void delete(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.delete:', iOS: (false, (3, 2, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_delete_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'delete:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_delete_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// makeTextWritingDirectionLeftToRight:
  void makeTextWritingDirectionLeftToRight(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.makeTextWritingDirectionLeftToRight:', iOS: (false, (5, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_makeTextWritingDirectionLeftToRight_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'makeTextWritingDirectionLeftToRight:');
    }
    _objc_msgSend_xtuoz7(
      this.ref.pointer,
      _sel_makeTextWritingDirectionLeftToRight_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// makeTextWritingDirectionRightToLeft:
  void makeTextWritingDirectionRightToLeft(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.makeTextWritingDirectionRightToLeft:', iOS: (false, (5, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_makeTextWritingDirectionRightToLeft_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'makeTextWritingDirectionRightToLeft:');
    }
    _objc_msgSend_xtuoz7(
      this.ref.pointer,
      _sel_makeTextWritingDirectionRightToLeft_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// toggleBoldface:
  void toggleBoldface(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.toggleBoldface:', iOS: (false, (6, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_toggleBoldface_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'toggleBoldface:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_toggleBoldface_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// toggleItalics:
  void toggleItalics(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.toggleItalics:', iOS: (false, (6, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_toggleItalics_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'toggleItalics:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_toggleItalics_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// toggleUnderline:
  void toggleUnderline(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.toggleUnderline:', iOS: (false, (6, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_toggleUnderline_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'toggleUnderline:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_toggleUnderline_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// increaseSize:
  void increaseSize(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.increaseSize:', iOS: (false, (7, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_increaseSize_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'increaseSize:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_increaseSize_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// decreaseSize:
  void decreaseSize(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.decreaseSize:', iOS: (false, (7, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_decreaseSize_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'decreaseSize:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_decreaseSize_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// updateTextAttributesWithConversionHandler:
  void updateTextAttributesWithConversionHandler(
    objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> conversionHandler,
  ) {
    objc.checkOsVersionInternal('UIResponder.updateTextAttributesWithConversionHandler:', iOS: (false, (13, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_updateTextAttributesWithConversionHandler_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'updateTextAttributesWithConversionHandler:');
    }
    _objc_msgSend_f167m6(
      this.ref.pointer,
      _sel_updateTextAttributesWithConversionHandler_,
      conversionHandler.ref.pointer,
    );
  }

  /// print:
  void print(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.print:', iOS: (false, (15, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_print_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'print:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_print_, sender?.ref.pointer ?? ffi.nullptr);
  }
}

/// WARNING: UIScene is a stub. To generate bindings for this class, include
/// UIScene in your config's objc-interfaces list.
///
/// UIScene
class UIScene extends UIResponder {
  UIScene._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIScene', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIScene] that points to the same underlying object as [other].
  UIScene.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIScene] that wraps the given raw object pointer.
  UIScene.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

final class __CVBuffer extends ffi.Opaque {}

final class CGImageSource extends ffi.Opaque {}

enum CGImagePropertyOrientation {
  kCGImagePropertyOrientationUp(1),
  kCGImagePropertyOrientationUpMirrored(2),
  kCGImagePropertyOrientationDown(3),
  kCGImagePropertyOrientationDownMirrored(4),
  kCGImagePropertyOrientationLeftMirrored(5),
  kCGImagePropertyOrientationRight(6),
  kCGImagePropertyOrientationRightMirrored(7),
  kCGImagePropertyOrientationLeft(8);

  final int value;
  const CGImagePropertyOrientation(this.value);

  static CGImagePropertyOrientation fromValue(int value) => switch (value) {
    1 => kCGImagePropertyOrientationUp,
    2 => kCGImagePropertyOrientationUpMirrored,
    3 => kCGImagePropertyOrientationDown,
    4 => kCGImagePropertyOrientationDownMirrored,
    5 => kCGImagePropertyOrientationLeftMirrored,
    6 => kCGImagePropertyOrientationRight,
    7 => kCGImagePropertyOrientationRightMirrored,
    8 => kCGImagePropertyOrientationLeft,
    _ => throw ArgumentError('Unknown value for CGImagePropertyOrientation: $value'),
  };
}

objc.CGRect _ObjCBlock_CGRect_ffiInt_CGRect_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  int arg0,
  objc.CGRect arg1,
) => block.ref.target
    .cast<ffi.NativeFunction<objc.CGRect Function(ffi.Int arg0, objc.CGRect arg1)>>()
    .asFunction<objc.CGRect Function(int, objc.CGRect)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_CGRect_ffiInt_CGRect_fnPtrCallable =
    ffi.Pointer.fromFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Int, objc.CGRect)>(
      _ObjCBlock_CGRect_ffiInt_CGRect_fnPtrTrampoline,
    ).cast();
objc.CGRect _ObjCBlock_CGRect_ffiInt_CGRect_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  int arg0,
  objc.CGRect arg1,
) => (objc.getBlockClosure(block) as objc.CGRect Function(int, objc.CGRect))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_CGRect_ffiInt_CGRect_closureCallable =
    ffi.Pointer.fromFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Int, objc.CGRect)>(
      _ObjCBlock_CGRect_ffiInt_CGRect_closureTrampoline,
    ).cast();

/// Construction methods for `objc.ObjCBlock<objc.CGRect Function(ffi.Int, objc.CGRect)>`.
abstract final class ObjCBlock_CGRect_ffiInt_CGRect {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Int, objc.CGRect)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.CGRect Function(ffi.Int, objc.CGRect)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Int, objc.CGRect)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<objc.CGRect Function(ffi.Int arg0, objc.CGRect arg1)>> ptr,
  ) => objc.ObjCBlock<objc.CGRect Function(ffi.Int, objc.CGRect)>(
    objc.newPointerBlock(_ObjCBlock_CGRect_ffiInt_CGRect_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Int, objc.CGRect)> fromFunction(
    objc.CGRect Function(int, objc.CGRect) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.CGRect Function(ffi.Int, objc.CGRect)>(
    objc.newClosureBlock(
      _ObjCBlock_CGRect_ffiInt_CGRect_closureCallable,
      (int arg0, objc.CGRect arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<objc.CGRect Function(ffi.Int, objc.CGRect)>`.
extension ObjCBlock_CGRect_ffiInt_CGRect_CallExtension on objc.ObjCBlock<objc.CGRect Function(ffi.Int, objc.CGRect)> {
  objc.CGRect call(int arg0, objc.CGRect arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Int arg0, objc.CGRect arg1)>
      >()
      .asFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl>, int, objc.CGRect)>()(ref.pointer, arg0, arg1);
}

enum UIFontDescriptorSymbolicTraits {
  UIFontDescriptorTraitItalic(1),
  UIFontDescriptorTraitBold(2),
  UIFontDescriptorTraitExpanded(32),
  UIFontDescriptorTraitCondensed(64),
  UIFontDescriptorTraitMonoSpace(1024),
  UIFontDescriptorTraitVertical(2048),
  UIFontDescriptorTraitUIOptimized(4096),
  UIFontDescriptorTraitTightLeading(32768),
  UIFontDescriptorTraitLooseLeading(65536),
  UIFontDescriptorClassMask(-268435456),
  UIFontDescriptorClassUnknown(0),
  UIFontDescriptorClassOldStyleSerifs(268435456),
  UIFontDescriptorClassTransitionalSerifs(536870912),
  UIFontDescriptorClassModernSerifs(805306368),
  UIFontDescriptorClassClarendonSerifs(1073741824),
  UIFontDescriptorClassSlabSerifs(1342177280),
  UIFontDescriptorClassFreeformSerifs(1879048192),
  UIFontDescriptorClassSansSerif(-2147483648),
  UIFontDescriptorClassOrnamentals(-1879048192),
  UIFontDescriptorClassScripts(-1610612736),
  UIFontDescriptorClassSymbolic(-1073741824);

  final int value;
  const UIFontDescriptorSymbolicTraits(this.value);

  static UIFontDescriptorSymbolicTraits fromValue(int value) => switch (value) {
    1 => UIFontDescriptorTraitItalic,
    2 => UIFontDescriptorTraitBold,
    32 => UIFontDescriptorTraitExpanded,
    64 => UIFontDescriptorTraitCondensed,
    1024 => UIFontDescriptorTraitMonoSpace,
    2048 => UIFontDescriptorTraitVertical,
    4096 => UIFontDescriptorTraitUIOptimized,
    32768 => UIFontDescriptorTraitTightLeading,
    65536 => UIFontDescriptorTraitLooseLeading,
    -268435456 => UIFontDescriptorClassMask,
    0 => UIFontDescriptorClassUnknown,
    268435456 => UIFontDescriptorClassOldStyleSerifs,
    536870912 => UIFontDescriptorClassTransitionalSerifs,
    805306368 => UIFontDescriptorClassModernSerifs,
    1073741824 => UIFontDescriptorClassClarendonSerifs,
    1342177280 => UIFontDescriptorClassSlabSerifs,
    1879048192 => UIFontDescriptorClassFreeformSerifs,
    -2147483648 => UIFontDescriptorClassSansSerif,
    -1879048192 => UIFontDescriptorClassOrnamentals,
    -1610612736 => UIFontDescriptorClassScripts,
    -1073741824 => UIFontDescriptorClassSymbolic,
    _ => throw ArgumentError('Unknown value for UIFontDescriptorSymbolicTraits: $value'),
  };
}

/// WARNING: UIFontDescriptor is a stub. To generate bindings for this class, include
/// UIFontDescriptor in your config's objc-interfaces list.
///
/// UIFontDescriptor
class UIFontDescriptor extends objc.NSObject implements objc.NSCopying, objc.NSSecureCoding {
  UIFontDescriptor._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIFontDescriptor', iOS: (false, (7, 0, 0)));
  }

  /// Constructs a [UIFontDescriptor] that points to the same underlying object as [other].
  UIFontDescriptor.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFontDescriptor] that wraps the given raw object pointer.
  UIFontDescriptor.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _class_UIFont = objc.getClass("UIFont");
late final _sel_labelFontSize = objc.registerName("labelFontSize");
late final _sel_buttonFontSize = objc.registerName("buttonFontSize");
late final _sel_smallSystemFontSize = objc.registerName("smallSystemFontSize");
late final _sel_systemFontSize = objc.registerName("systemFontSize");
late final _sel_defaultFontSize = objc.registerName("defaultFontSize");
late final _sel_systemMinimumFontSize = objc.registerName("systemMinimumFontSize");

/// UIFontSystemFonts
extension UIFontSystemFonts on UIFont {
  /// labelFontSize
  static double getLabelFontSize() {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(_class_UIFont, _sel_labelFontSize)
        : _objc_msgSend_1ukqyt8(_class_UIFont, _sel_labelFontSize);
  }

  /// buttonFontSize
  static double getButtonFontSize() {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(_class_UIFont, _sel_buttonFontSize)
        : _objc_msgSend_1ukqyt8(_class_UIFont, _sel_buttonFontSize);
  }

  /// smallSystemFontSize
  static double getSmallSystemFontSize() {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(_class_UIFont, _sel_smallSystemFontSize)
        : _objc_msgSend_1ukqyt8(_class_UIFont, _sel_smallSystemFontSize);
  }

  /// systemFontSize
  static double getSystemFontSize() {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(_class_UIFont, _sel_systemFontSize)
        : _objc_msgSend_1ukqyt8(_class_UIFont, _sel_systemFontSize);
  }

  /// defaultFontSize
  static double getDefaultFontSize() {
    objc.checkOsVersionInternal('UIFont.defaultFontSize', iOS: (true, null), macOS: (true, null));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(_class_UIFont, _sel_defaultFontSize)
        : _objc_msgSend_1ukqyt8(_class_UIFont, _sel_defaultFontSize);
  }

  /// systemMinimumFontSize
  static double getSystemMinimumFontSize() {
    objc.checkOsVersionInternal('UIFont.systemMinimumFontSize', iOS: (true, null), macOS: (true, null));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(_class_UIFont, _sel_systemMinimumFontSize)
        : _objc_msgSend_1ukqyt8(_class_UIFont, _sel_systemMinimumFontSize);
  }
}

late final _sel_preferredFontForTextStyle_ = objc.registerName("preferredFontForTextStyle:");
late final _sel_preferredFontForTextStyle_compatibleWithTraitCollection_ = objc.registerName(
  "preferredFontForTextStyle:compatibleWithTraitCollection:",
);
late final _sel_fontWithName_size_ = objc.registerName("fontWithName:size:");
final _objc_msgSend_6plvbo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Double,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        double,
      )
    >();
late final _sel_familyNames = objc.registerName("familyNames");
late final _sel_fontNamesForFamilyName_ = objc.registerName("fontNamesForFamilyName:");
late final _sel_systemFontOfSize_ = objc.registerName("systemFontOfSize:");
late final _sel_boldSystemFontOfSize_ = objc.registerName("boldSystemFontOfSize:");
late final _sel_italicSystemFontOfSize_ = objc.registerName("italicSystemFontOfSize:");
late final _sel_systemFontOfSize_weight_ = objc.registerName("systemFontOfSize:weight:");
late final _sel_monospacedDigitSystemFontOfSize_weight_ = objc.registerName("monospacedDigitSystemFontOfSize:weight:");
late final _sel_monospacedSystemFontOfSize_weight_ = objc.registerName("monospacedSystemFontOfSize:weight:");
late final _sel_familyName = objc.registerName("familyName");
late final _sel_fontName = objc.registerName("fontName");
late final _sel_pointSize = objc.registerName("pointSize");
late final _sel_ascender = objc.registerName("ascender");
late final _sel_descender = objc.registerName("descender");
late final _sel_capHeight = objc.registerName("capHeight");
late final _sel_xHeight = objc.registerName("xHeight");
late final _sel_lineHeight = objc.registerName("lineHeight");
late final _sel_leading = objc.registerName("leading");
late final _sel_fontWithSize_ = objc.registerName("fontWithSize:");
late final _sel_fontWithDescriptor_size_ = objc.registerName("fontWithDescriptor:size:");
late final _sel_fontDescriptor = objc.registerName("fontDescriptor");
late final _sel_self = objc.registerName("self");
late final _sel_retain = objc.registerName("retain");
late final _sel_autorelease = objc.registerName("autorelease");

/// UIFont
class UIFont extends objc.NSObject implements objc.NSCopying, objc.NSSecureCoding {
  UIFont._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIFont', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIFont] that points to the same underlying object as [other].
  UIFont.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFont] that wraps the given raw object pointer.
  UIFont.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIFont].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIFont);
  }

  /// preferredFontForTextStyle:
  static UIFont preferredFontForTextStyle(objc.NSString style) {
    objc.checkOsVersionInternal('UIFont.preferredFontForTextStyle:', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_UIFont, _sel_preferredFontForTextStyle_, style.ref.pointer);
    return UIFont.castFromPointer(_ret, retain: true, release: true);
  }

  /// preferredFontForTextStyle:compatibleWithTraitCollection:
  static UIFont preferredFontForTextStyle$1(objc.NSString style, {UITraitCollection? compatibleWithTraitCollection}) {
    objc.checkOsVersionInternal(
      'UIFont.preferredFontForTextStyle:compatibleWithTraitCollection:',
      iOS: (false, (10, 0, 0)),
    );
    final _ret = _objc_msgSend_15qeuct(
      _class_UIFont,
      _sel_preferredFontForTextStyle_compatibleWithTraitCollection_,
      style.ref.pointer,
      compatibleWithTraitCollection?.ref.pointer ?? ffi.nullptr,
    );
    return UIFont.castFromPointer(_ret, retain: true, release: true);
  }

  /// fontWithName:size:
  static UIFont? fontWithName(objc.NSString fontName, {required double size}) {
    objc.checkOsVersionInternal('UIFont.fontWithName:size:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_6plvbo(_class_UIFont, _sel_fontWithName_size_, fontName.ref.pointer, size);
    return _ret.address == 0 ? null : UIFont.castFromPointer(_ret, retain: true, release: true);
  }

  /// familyNames
  static objc.NSArray getFamilyNames() {
    objc.checkOsVersionInternal('UIFont.familyNames', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIFont, _sel_familyNames);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// fontNamesForFamilyName:
  static objc.NSArray fontNamesForFamilyName(objc.NSString familyName) {
    objc.checkOsVersionInternal('UIFont.fontNamesForFamilyName:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_UIFont, _sel_fontNamesForFamilyName_, familyName.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemFontOfSize:
  static UIFont systemFontOfSize(double fontSize) {
    objc.checkOsVersionInternal('UIFont.systemFontOfSize:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_oa8mke(_class_UIFont, _sel_systemFontOfSize_, fontSize);
    return UIFont.castFromPointer(_ret, retain: true, release: true);
  }

  /// boldSystemFontOfSize:
  static UIFont boldSystemFontOfSize(double fontSize) {
    objc.checkOsVersionInternal('UIFont.boldSystemFontOfSize:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_oa8mke(_class_UIFont, _sel_boldSystemFontOfSize_, fontSize);
    return UIFont.castFromPointer(_ret, retain: true, release: true);
  }

  /// italicSystemFontOfSize:
  static UIFont italicSystemFontOfSize(double fontSize) {
    objc.checkOsVersionInternal('UIFont.italicSystemFontOfSize:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_oa8mke(_class_UIFont, _sel_italicSystemFontOfSize_, fontSize);
    return UIFont.castFromPointer(_ret, retain: true, release: true);
  }

  /// systemFontOfSize:weight:
  static UIFont systemFontOfSize$1(double fontSize, {required double weight}) {
    objc.checkOsVersionInternal('UIFont.systemFontOfSize:weight:', iOS: (false, (8, 2, 0)));
    final _ret = _objc_msgSend_1n2vn5t(_class_UIFont, _sel_systemFontOfSize_weight_, fontSize, weight);
    return UIFont.castFromPointer(_ret, retain: true, release: true);
  }

  /// monospacedDigitSystemFontOfSize:weight:
  static UIFont monospacedDigitSystemFontOfSize(double fontSize, {required double weight}) {
    objc.checkOsVersionInternal('UIFont.monospacedDigitSystemFontOfSize:weight:', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_1n2vn5t(_class_UIFont, _sel_monospacedDigitSystemFontOfSize_weight_, fontSize, weight);
    return UIFont.castFromPointer(_ret, retain: true, release: true);
  }

  /// monospacedSystemFontOfSize:weight:
  static UIFont monospacedSystemFontOfSize(double fontSize, {required double weight}) {
    objc.checkOsVersionInternal('UIFont.monospacedSystemFontOfSize:weight:', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_1n2vn5t(_class_UIFont, _sel_monospacedSystemFontOfSize_weight_, fontSize, weight);
    return UIFont.castFromPointer(_ret, retain: true, release: true);
  }

  /// fontWithDescriptor:size:
  static UIFont fontWithDescriptor(UIFontDescriptor descriptor, {required double size}) {
    objc.checkOsVersionInternal('UIFont.fontWithDescriptor:size:', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_6plvbo(_class_UIFont, _sel_fontWithDescriptor_size_, descriptor.ref.pointer, size);
    return UIFont.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static UIFont new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIFont, _sel_new);
    return UIFont.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIFont allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(_class_UIFont, _sel_allocWithZone_, zone);
    return UIFont.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UIFont alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UIFont, _sel_alloc);
    return UIFont.castFromPointer(_ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UIFont, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of UIFont constructed with the default `new` method.
  factory UIFont() => new$();
}

extension UIFont$Methods on UIFont {
  /// familyName
  objc.NSString get familyName {
    objc.checkOsVersionInternal('UIFont.familyName', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_familyName);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// fontName
  objc.NSString get fontName {
    objc.checkOsVersionInternal('UIFont.fontName', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_fontName);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// pointSize
  double get pointSize {
    objc.checkOsVersionInternal('UIFont.pointSize', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_pointSize)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_pointSize);
  }

  /// ascender
  double get ascender {
    objc.checkOsVersionInternal('UIFont.ascender', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_ascender)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_ascender);
  }

  /// descender
  double get descender {
    objc.checkOsVersionInternal('UIFont.descender', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_descender)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_descender);
  }

  /// capHeight
  double get capHeight {
    objc.checkOsVersionInternal('UIFont.capHeight', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_capHeight)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_capHeight);
  }

  /// xHeight
  double get xHeight {
    objc.checkOsVersionInternal('UIFont.xHeight', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_xHeight)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_xHeight);
  }

  /// lineHeight
  double get lineHeight {
    objc.checkOsVersionInternal('UIFont.lineHeight', iOS: (false, (4, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_lineHeight)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_lineHeight);
  }

  /// leading
  double get leading {
    objc.checkOsVersionInternal('UIFont.leading', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_leading)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_leading);
  }

  /// fontWithSize:
  UIFont fontWithSize(double fontSize) {
    objc.checkOsVersionInternal('UIFont.fontWithSize:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_oa8mke(this.ref.pointer, _sel_fontWithSize_, fontSize);
    return UIFont.castFromPointer(_ret, retain: true, release: true);
  }

  /// fontDescriptor
  UIFontDescriptor get fontDescriptor {
    objc.checkOsVersionInternal('UIFont.fontDescriptor', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_fontDescriptor);
    return UIFontDescriptor.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  UIFont init() {
    objc.checkOsVersionInternal('UIFont.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIFont.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  UIFont self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return UIFont.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  UIFont retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return UIFont.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  UIFont autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return UIFont.castFromPointer(_ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// initWithCoder:
  UIFont? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0 ? null : UIFont.castFromPointer(_ret, retain: false, release: true);
  }
}

enum UIUserInterfaceSizeClass {
  UIUserInterfaceSizeClassUnspecified(0),
  UIUserInterfaceSizeClassCompact(1),
  UIUserInterfaceSizeClassRegular(2);

  final int value;
  const UIUserInterfaceSizeClass(this.value);

  static UIUserInterfaceSizeClass fromValue(int value) => switch (value) {
    0 => UIUserInterfaceSizeClassUnspecified,
    1 => UIUserInterfaceSizeClassCompact,
    2 => UIUserInterfaceSizeClassRegular,
    _ => throw ArgumentError('Unknown value for UIUserInterfaceSizeClass: $value'),
  };
}

enum UITraitEnvironmentLayoutDirection {
  UITraitEnvironmentLayoutDirectionUnspecified(-1),
  UITraitEnvironmentLayoutDirectionLeftToRight(0),
  UITraitEnvironmentLayoutDirectionRightToLeft(1);

  final int value;
  const UITraitEnvironmentLayoutDirection(this.value);

  static UITraitEnvironmentLayoutDirection fromValue(int value) => switch (value) {
    -1 => UITraitEnvironmentLayoutDirectionUnspecified,
    0 => UITraitEnvironmentLayoutDirectionLeftToRight,
    1 => UITraitEnvironmentLayoutDirectionRightToLeft,
    _ => throw ArgumentError('Unknown value for UITraitEnvironmentLayoutDirection: $value'),
  };
}

enum UIDisplayGamut {
  UIDisplayGamutUnspecified(-1),
  UIDisplayGamutSRGB(0),
  UIDisplayGamutP3(1);

  final int value;
  const UIDisplayGamut(this.value);

  static UIDisplayGamut fromValue(int value) => switch (value) {
    -1 => UIDisplayGamutUnspecified,
    0 => UIDisplayGamutSRGB,
    1 => UIDisplayGamutP3,
    _ => throw ArgumentError('Unknown value for UIDisplayGamut: $value'),
  };
}

enum UIAccessibilityContrast {
  UIAccessibilityContrastUnspecified(-1),
  UIAccessibilityContrastNormal(0),
  UIAccessibilityContrastHigh(1);

  final int value;
  const UIAccessibilityContrast(this.value);

  static UIAccessibilityContrast fromValue(int value) => switch (value) {
    -1 => UIAccessibilityContrastUnspecified,
    0 => UIAccessibilityContrastNormal,
    1 => UIAccessibilityContrastHigh,
    _ => throw ArgumentError('Unknown value for UIAccessibilityContrast: $value'),
  };
}

enum UILegibilityWeight {
  UILegibilityWeightUnspecified(-1),
  UILegibilityWeightRegular(0),
  UILegibilityWeightBold(1);

  final int value;
  const UILegibilityWeight(this.value);

  static UILegibilityWeight fromValue(int value) => switch (value) {
    -1 => UILegibilityWeightUnspecified,
    0 => UILegibilityWeightRegular,
    1 => UILegibilityWeightBold,
    _ => throw ArgumentError('Unknown value for UILegibilityWeight: $value'),
  };
}

enum UIUserInterfaceLevel {
  UIUserInterfaceLevelUnspecified(-1),
  UIUserInterfaceLevelBase(0),
  UIUserInterfaceLevelElevated(1);

  final int value;
  const UIUserInterfaceLevel(this.value);

  static UIUserInterfaceLevel fromValue(int value) => switch (value) {
    -1 => UIUserInterfaceLevelUnspecified,
    0 => UIUserInterfaceLevelBase,
    1 => UIUserInterfaceLevelElevated,
    _ => throw ArgumentError('Unknown value for UIUserInterfaceLevel: $value'),
  };
}

enum UIUserInterfaceActiveAppearance {
  UIUserInterfaceActiveAppearanceUnspecified(-1),
  UIUserInterfaceActiveAppearanceInactive(0),
  UIUserInterfaceActiveAppearanceActive(1);

  final int value;
  const UIUserInterfaceActiveAppearance(this.value);

  static UIUserInterfaceActiveAppearance fromValue(int value) => switch (value) {
    -1 => UIUserInterfaceActiveAppearanceUnspecified,
    0 => UIUserInterfaceActiveAppearanceInactive,
    1 => UIUserInterfaceActiveAppearanceActive,
    _ => throw ArgumentError('Unknown value for UIUserInterfaceActiveAppearance: $value'),
  };
}

enum UIUserInterfaceIdiom {
  UIUserInterfaceIdiomUnspecified(-1),
  UIUserInterfaceIdiomPhone(0),
  UIUserInterfaceIdiomPad(1),
  UIUserInterfaceIdiomTV(2),
  UIUserInterfaceIdiomCarPlay(3),
  UIUserInterfaceIdiomMac(5);

  final int value;
  const UIUserInterfaceIdiom(this.value);

  static UIUserInterfaceIdiom fromValue(int value) => switch (value) {
    -1 => UIUserInterfaceIdiomUnspecified,
    0 => UIUserInterfaceIdiomPhone,
    1 => UIUserInterfaceIdiomPad,
    2 => UIUserInterfaceIdiomTV,
    3 => UIUserInterfaceIdiomCarPlay,
    5 => UIUserInterfaceIdiomMac,
    _ => throw ArgumentError('Unknown value for UIUserInterfaceIdiom: $value'),
  };
}

/// WARNING: CAMediaTiming is a stub. To generate bindings for this class, include
/// CAMediaTiming in your config's objc-protocols list.
///
/// CAMediaTiming
interface class CAMediaTiming extends objc.ObjCProtocolBase {
  CAMediaTiming._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [CAMediaTiming] that points to the same underlying object as [other].
  CAMediaTiming.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CAMediaTiming] that wraps the given raw object pointer.
  CAMediaTiming.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

enum CAAutoresizingMask {
  kCALayerNotSizable(0),
  kCALayerMinXMargin(1),
  kCALayerWidthSizable(2),
  kCALayerMaxXMargin(4),
  kCALayerMinYMargin(8),
  kCALayerHeightSizable(16),
  kCALayerMaxYMargin(32);

  final int value;
  const CAAutoresizingMask(this.value);

  static CAAutoresizingMask fromValue(int value) => switch (value) {
    0 => kCALayerNotSizable,
    1 => kCALayerMinXMargin,
    2 => kCALayerWidthSizable,
    4 => kCALayerMaxXMargin,
    8 => kCALayerMinYMargin,
    16 => kCALayerHeightSizable,
    32 => kCALayerMaxYMargin,
    _ => throw ArgumentError('Unknown value for CAAutoresizingMask: $value'),
  };
}

enum CAEdgeAntialiasingMask {
  kCALayerLeftEdge(1),
  kCALayerRightEdge(2),
  kCALayerBottomEdge(4),
  kCALayerTopEdge(8);

  final int value;
  const CAEdgeAntialiasingMask(this.value);

  static CAEdgeAntialiasingMask fromValue(int value) => switch (value) {
    1 => kCALayerLeftEdge,
    2 => kCALayerRightEdge,
    4 => kCALayerBottomEdge,
    8 => kCALayerTopEdge,
    _ => throw ArgumentError('Unknown value for CAEdgeAntialiasingMask: $value'),
  };
}

enum CACornerMask {
  kCALayerMinXMinYCorner(1),
  kCALayerMaxXMinYCorner(2),
  kCALayerMinXMaxYCorner(4),
  kCALayerMaxXMaxYCorner(8);

  final int value;
  const CACornerMask(this.value);

  static CACornerMask fromValue(int value) => switch (value) {
    1 => kCALayerMinXMinYCorner,
    2 => kCALayerMaxXMinYCorner,
    4 => kCALayerMinXMaxYCorner,
    8 => kCALayerMaxXMaxYCorner,
    _ => throw ArgumentError('Unknown value for CACornerMask: $value'),
  };
}

final class CAFrameRateRange extends ffi.Struct {
  @ffi.Float()
  external double minimum;

  @ffi.Float()
  external double maximum;

  @ffi.Float()
  external double preferred;
}

enum CAConstraintAttribute {
  kCAConstraintMinX(0),
  kCAConstraintMidX(1),
  kCAConstraintMaxX(2),
  kCAConstraintWidth(3),
  kCAConstraintMinY(4),
  kCAConstraintMidY(5),
  kCAConstraintMaxY(6),
  kCAConstraintHeight(7);

  final int value;
  const CAConstraintAttribute(this.value);

  static CAConstraintAttribute fromValue(int value) => switch (value) {
    0 => kCAConstraintMinX,
    1 => kCAConstraintMidX,
    2 => kCAConstraintMaxX,
    3 => kCAConstraintWidth,
    4 => kCAConstraintMinY,
    5 => kCAConstraintMidY,
    6 => kCAConstraintMaxY,
    7 => kCAConstraintHeight,
    _ => throw ArgumentError('Unknown value for CAConstraintAttribute: $value'),
  };
}

enum NSLayoutRelation {
  NSLayoutRelationLessThanOrEqual(-1),
  NSLayoutRelationEqual(0),
  NSLayoutRelationGreaterThanOrEqual(1);

  final int value;
  const NSLayoutRelation(this.value);

  static NSLayoutRelation fromValue(int value) => switch (value) {
    -1 => NSLayoutRelationLessThanOrEqual,
    0 => NSLayoutRelationEqual,
    1 => NSLayoutRelationGreaterThanOrEqual,
    _ => throw ArgumentError('Unknown value for NSLayoutRelation: $value'),
  };
}

enum NSLayoutAttribute {
  NSLayoutAttributeLeft(1),
  NSLayoutAttributeRight(2),
  NSLayoutAttributeTop(3),
  NSLayoutAttributeBottom(4),
  NSLayoutAttributeLeading(5),
  NSLayoutAttributeTrailing(6),
  NSLayoutAttributeWidth(7),
  NSLayoutAttributeHeight(8),
  NSLayoutAttributeCenterX(9),
  NSLayoutAttributeCenterY(10),
  NSLayoutAttributeLastBaseline(11),
  NSLayoutAttributeFirstBaseline(12),
  NSLayoutAttributeNotAnAttribute(0);

  static const NSLayoutAttributeBaseline = NSLayoutAttributeLastBaseline;

  final int value;
  const NSLayoutAttribute(this.value);

  static NSLayoutAttribute fromValue(int value) => switch (value) {
    1 => NSLayoutAttributeLeft,
    2 => NSLayoutAttributeRight,
    3 => NSLayoutAttributeTop,
    4 => NSLayoutAttributeBottom,
    5 => NSLayoutAttributeLeading,
    6 => NSLayoutAttributeTrailing,
    7 => NSLayoutAttributeWidth,
    8 => NSLayoutAttributeHeight,
    9 => NSLayoutAttributeCenterX,
    10 => NSLayoutAttributeCenterY,
    11 => NSLayoutAttributeLastBaseline,
    12 => NSLayoutAttributeFirstBaseline,
    0 => NSLayoutAttributeNotAnAttribute,
    _ => throw ArgumentError('Unknown value for NSLayoutAttribute: $value'),
  };

  @override
  String toString() {
    if (this == NSLayoutAttributeLastBaseline)
      return "NSLayoutAttribute.NSLayoutAttributeLastBaseline, NSLayoutAttribute.NSLayoutAttributeBaseline";
    return super.toString();
  }
}

enum NSLayoutFormatOptions {
  NSLayoutFormatAlignAllLeft(2),
  NSLayoutFormatAlignAllRight(4),
  NSLayoutFormatAlignAllTop(8),
  NSLayoutFormatAlignAllBottom(16),
  NSLayoutFormatAlignAllLeading(32),
  NSLayoutFormatAlignAllTrailing(64),
  NSLayoutFormatAlignAllCenterX(512),
  NSLayoutFormatAlignAllCenterY(1024),
  NSLayoutFormatAlignAllLastBaseline(2048),
  NSLayoutFormatAlignAllFirstBaseline(4096),
  NSLayoutFormatAlignmentMask(65535),
  NSLayoutFormatDirectionLeadingToTrailing(0),
  NSLayoutFormatDirectionLeftToRight(65536),
  NSLayoutFormatDirectionRightToLeft(131072),
  NSLayoutFormatDirectionMask(196608);

  static const NSLayoutFormatAlignAllBaseline = NSLayoutFormatAlignAllLastBaseline;

  final int value;
  const NSLayoutFormatOptions(this.value);

  static NSLayoutFormatOptions fromValue(int value) => switch (value) {
    2 => NSLayoutFormatAlignAllLeft,
    4 => NSLayoutFormatAlignAllRight,
    8 => NSLayoutFormatAlignAllTop,
    16 => NSLayoutFormatAlignAllBottom,
    32 => NSLayoutFormatAlignAllLeading,
    64 => NSLayoutFormatAlignAllTrailing,
    512 => NSLayoutFormatAlignAllCenterX,
    1024 => NSLayoutFormatAlignAllCenterY,
    2048 => NSLayoutFormatAlignAllLastBaseline,
    4096 => NSLayoutFormatAlignAllFirstBaseline,
    65535 => NSLayoutFormatAlignmentMask,
    0 => NSLayoutFormatDirectionLeadingToTrailing,
    65536 => NSLayoutFormatDirectionLeftToRight,
    131072 => NSLayoutFormatDirectionRightToLeft,
    196608 => NSLayoutFormatDirectionMask,
    _ => throw ArgumentError('Unknown value for NSLayoutFormatOptions: $value'),
  };

  @override
  String toString() {
    if (this == NSLayoutFormatAlignAllLastBaseline)
      return "NSLayoutFormatOptions.NSLayoutFormatAlignAllLastBaseline, NSLayoutFormatOptions.NSLayoutFormatAlignAllBaseline";
    return super.toString();
  }
}

enum UITouchPhase {
  UITouchPhaseBegan(0),
  UITouchPhaseMoved(1),
  UITouchPhaseStationary(2),
  UITouchPhaseEnded(3),
  UITouchPhaseCancelled(4),
  UITouchPhaseRegionEntered(5),
  UITouchPhaseRegionMoved(6),
  UITouchPhaseRegionExited(7);

  final int value;
  const UITouchPhase(this.value);

  static UITouchPhase fromValue(int value) => switch (value) {
    0 => UITouchPhaseBegan,
    1 => UITouchPhaseMoved,
    2 => UITouchPhaseStationary,
    3 => UITouchPhaseEnded,
    4 => UITouchPhaseCancelled,
    5 => UITouchPhaseRegionEntered,
    6 => UITouchPhaseRegionMoved,
    7 => UITouchPhaseRegionExited,
    _ => throw ArgumentError('Unknown value for UITouchPhase: $value'),
  };
}

enum UIForceTouchCapability {
  UIForceTouchCapabilityUnknown(0),
  UIForceTouchCapabilityUnavailable(1),
  UIForceTouchCapabilityAvailable(2);

  final int value;
  const UIForceTouchCapability(this.value);

  static UIForceTouchCapability fromValue(int value) => switch (value) {
    0 => UIForceTouchCapabilityUnknown,
    1 => UIForceTouchCapabilityUnavailable,
    2 => UIForceTouchCapabilityAvailable,
    _ => throw ArgumentError('Unknown value for UIForceTouchCapability: $value'),
  };
}

enum UITouchType {
  UITouchTypeDirect(0),
  UITouchTypeIndirect(1),
  UITouchTypePencil(2),
  UITouchTypeIndirectPointer(3);

  static const UITouchTypeStylus = UITouchTypePencil;

  final int value;
  const UITouchType(this.value);

  static UITouchType fromValue(int value) => switch (value) {
    0 => UITouchTypeDirect,
    1 => UITouchTypeIndirect,
    2 => UITouchTypePencil,
    3 => UITouchTypeIndirectPointer,
    _ => throw ArgumentError('Unknown value for UITouchType: $value'),
  };

  @override
  String toString() {
    if (this == UITouchTypePencil) return "UITouchType.UITouchTypePencil, UITouchType.UITouchTypeStylus";
    return super.toString();
  }
}

enum UITouchProperties {
  UITouchPropertyForce(1),
  UITouchPropertyAzimuth(2),
  UITouchPropertyAltitude(4),
  UITouchPropertyLocation(8);

  final int value;
  const UITouchProperties(this.value);

  static UITouchProperties fromValue(int value) => switch (value) {
    1 => UITouchPropertyForce,
    2 => UITouchPropertyAzimuth,
    4 => UITouchPropertyAltitude,
    8 => UITouchPropertyLocation,
    _ => throw ArgumentError('Unknown value for UITouchProperties: $value'),
  };
}

/// WARNING: UITouch is a stub. To generate bindings for this class, include
/// UITouch in your config's objc-interfaces list.
///
/// UITouch
class UITouch extends objc.NSObject {
  UITouch._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITouch', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UITouch] that points to the same underlying object as [other].
  UITouch.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITouch] that wraps the given raw object pointer.
  UITouch.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

enum UIFocusHeading {
  UIFocusHeadingNone(0),
  UIFocusHeadingUp(1),
  UIFocusHeadingDown(2),
  UIFocusHeadingLeft(4),
  UIFocusHeadingRight(8),
  UIFocusHeadingNext(16),
  UIFocusHeadingPrevious(32),
  UIFocusHeadingFirst(256),
  UIFocusHeadingLast(512);

  final int value;
  const UIFocusHeading(this.value);

  static UIFocusHeading fromValue(int value) => switch (value) {
    0 => UIFocusHeadingNone,
    1 => UIFocusHeadingUp,
    2 => UIFocusHeadingDown,
    4 => UIFocusHeadingLeft,
    8 => UIFocusHeadingRight,
    16 => UIFocusHeadingNext,
    32 => UIFocusHeadingPrevious,
    256 => UIFocusHeadingFirst,
    512 => UIFocusHeadingLast,
    _ => throw ArgumentError('Unknown value for UIFocusHeading: $value'),
  };
}

ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIMenu_NSArray_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
    .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIMenu_NSArray_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_UIMenu_NSArray_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIMenu_NSArray_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_UIMenu_NSArray_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
        >(_ObjCBlock_UIMenu_NSArray_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<UIMenu? Function(objc.NSArray)>`.
abstract final class ObjCBlock_UIMenu_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIMenu? Function(objc.NSArray)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UIMenu? Function(objc.NSArray)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIMenu? Function(objc.NSArray)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject> arg0)>> ptr,
  ) => objc.ObjCBlock<UIMenu? Function(objc.NSArray)>(
    objc.newPointerBlock(_ObjCBlock_UIMenu_NSArray_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIMenu? Function(objc.NSArray)> fromFunction(
    UIMenu? Function(objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UIMenu? Function(objc.NSArray)>(
    objc.newClosureBlock(
      _ObjCBlock_UIMenu_NSArray_closureCallable,
      (ffi.Pointer<objc.ObjCObject> arg0) =>
          fn(objc.NSArray.castFromPointer(arg0, retain: true, release: true))?.ref.retainAndAutorelease() ??
          ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<UIMenu? Function(objc.NSArray)>`.
extension ObjCBlock_UIMenu_NSArray_CallExtension on objc.ObjCBlock<UIMenu? Function(objc.NSArray)> {
  UIMenu? call(objc.NSArray arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<objc.ObjCObject> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
              >()(ref.pointer, arg0.ref.pointer)
              .address ==
          0
      ? null
      : UIMenu.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<objc.ObjCObject> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
              >()(ref.pointer, arg0.ref.pointer),
          retain: true,
          release: true,
        );
}

ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIViewController_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function()>>()
    .asFunction<ffi.Pointer<objc.ObjCObject> Function()>()();
ffi.Pointer<ffi.Void> _ObjCBlock_UIViewController_fnPtrCallable =
    ffi.Pointer.fromFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(
      _ObjCBlock_UIViewController_fnPtrTrampoline,
    ).cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_UIViewController_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function())();
ffi.Pointer<ffi.Void> _ObjCBlock_UIViewController_closureCallable =
    ffi.Pointer.fromFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(
      _ObjCBlock_UIViewController_closureTrampoline,
    ).cast();

/// Construction methods for `objc.ObjCBlock<UIViewController? Function()>`.
abstract final class ObjCBlock_UIViewController {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIViewController? Function()> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UIViewController? Function()>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIViewController? Function()> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function()>> ptr,
  ) => objc.ObjCBlock<UIViewController? Function()>(
    objc.newPointerBlock(_ObjCBlock_UIViewController_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIViewController? Function()> fromFunction(
    UIViewController? Function() fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UIViewController? Function()>(
    objc.newClosureBlock(
      _ObjCBlock_UIViewController_closureCallable,
      () => fn()?.ref.retainAndAutorelease() ?? ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<UIViewController? Function()>`.
extension ObjCBlock_UIViewController_CallExtension on objc.ObjCBlock<UIViewController? Function()> {
  UIViewController? call() =>
      ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>)>()(
                ref.pointer,
              )
              .address ==
          0
      ? null
      : UIViewController.castFromPointer(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>)>()(
            ref.pointer,
          ),
          retain: true,
          release: true,
        );
}

/// WARNING: UIContextMenuConfiguration is a stub. To generate bindings for this class, include
/// UIContextMenuConfiguration in your config's objc-interfaces list.
///
/// UIContextMenuConfiguration
class UIContextMenuConfiguration extends objc.NSObject {
  UIContextMenuConfiguration._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIContextMenuConfiguration', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIContextMenuConfiguration] that points to the same underlying object as [other].
  UIContextMenuConfiguration.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIContextMenuConfiguration] that wraps the given raw object pointer.
  UIContextMenuConfiguration.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

enum UIContextMenuInteractionCommitStyle {
  UIContextMenuInteractionCommitStyleDismiss(0),
  UIContextMenuInteractionCommitStylePop(1);

  final int value;
  const UIContextMenuInteractionCommitStyle(this.value);

  static UIContextMenuInteractionCommitStyle fromValue(int value) => switch (value) {
    0 => UIContextMenuInteractionCommitStyleDismiss,
    1 => UIContextMenuInteractionCommitStylePop,
    _ => throw ArgumentError('Unknown value for UIContextMenuInteractionCommitStyle: $value'),
  };
}

enum UIContextMenuInteractionAppearance {
  UIContextMenuInteractionAppearanceUnknown(0),
  UIContextMenuInteractionAppearanceRich(1),
  UIContextMenuInteractionAppearanceCompact(2);

  final int value;
  const UIContextMenuInteractionAppearance(this.value);

  static UIContextMenuInteractionAppearance fromValue(int value) => switch (value) {
    0 => UIContextMenuInteractionAppearanceUnknown,
    1 => UIContextMenuInteractionAppearanceRich,
    2 => UIContextMenuInteractionAppearanceCompact,
    _ => throw ArgumentError('Unknown value for UIContextMenuInteractionAppearance: $value'),
  };
}

/// WARNING: UIContextMenuInteraction is a stub. To generate bindings for this class, include
/// UIContextMenuInteraction in your config's objc-interfaces list.
///
/// UIContextMenuInteraction
class UIContextMenuInteraction extends objc.NSObject implements UIInteraction {
  UIContextMenuInteraction._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIContextMenuInteraction', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIContextMenuInteraction] that points to the same underlying object as [other].
  UIContextMenuInteraction.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIContextMenuInteraction] that wraps the given raw object pointer.
  UIContextMenuInteraction.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

enum UIControlEvents {
  UIControlEventTouchDown(1),
  UIControlEventTouchDownRepeat(2),
  UIControlEventTouchDragInside(4),
  UIControlEventTouchDragOutside(8),
  UIControlEventTouchDragEnter(16),
  UIControlEventTouchDragExit(32),
  UIControlEventTouchUpInside(64),
  UIControlEventTouchUpOutside(128),
  UIControlEventTouchCancel(256),
  UIControlEventValueChanged(4096),
  UIControlEventPrimaryActionTriggered(8192),
  UIControlEventMenuActionTriggered(16384),
  UIControlEventEditingDidBegin(65536),
  UIControlEventEditingChanged(131072),
  UIControlEventEditingDidEnd(262144),
  UIControlEventEditingDidEndOnExit(524288),
  UIControlEventAllTouchEvents(4095),
  UIControlEventAllEditingEvents(983040),
  UIControlEventApplicationReserved(251658240),
  UIControlEventSystemReserved(4026531840),
  UIControlEventAllEvents(4294967295);

  final int value;
  const UIControlEvents(this.value);

  static UIControlEvents fromValue(int value) => switch (value) {
    1 => UIControlEventTouchDown,
    2 => UIControlEventTouchDownRepeat,
    4 => UIControlEventTouchDragInside,
    8 => UIControlEventTouchDragOutside,
    16 => UIControlEventTouchDragEnter,
    32 => UIControlEventTouchDragExit,
    64 => UIControlEventTouchUpInside,
    128 => UIControlEventTouchUpOutside,
    256 => UIControlEventTouchCancel,
    4096 => UIControlEventValueChanged,
    8192 => UIControlEventPrimaryActionTriggered,
    16384 => UIControlEventMenuActionTriggered,
    65536 => UIControlEventEditingDidBegin,
    131072 => UIControlEventEditingChanged,
    262144 => UIControlEventEditingDidEnd,
    524288 => UIControlEventEditingDidEndOnExit,
    4095 => UIControlEventAllTouchEvents,
    983040 => UIControlEventAllEditingEvents,
    251658240 => UIControlEventApplicationReserved,
    4026531840 => UIControlEventSystemReserved,
    4294967295 => UIControlEventAllEvents,
    _ => throw ArgumentError('Unknown value for UIControlEvents: $value'),
  };
}

enum UIControlContentVerticalAlignment {
  UIControlContentVerticalAlignmentCenter(0),
  UIControlContentVerticalAlignmentTop(1),
  UIControlContentVerticalAlignmentBottom(2),
  UIControlContentVerticalAlignmentFill(3);

  final int value;
  const UIControlContentVerticalAlignment(this.value);

  static UIControlContentVerticalAlignment fromValue(int value) => switch (value) {
    0 => UIControlContentVerticalAlignmentCenter,
    1 => UIControlContentVerticalAlignmentTop,
    2 => UIControlContentVerticalAlignmentBottom,
    3 => UIControlContentVerticalAlignmentFill,
    _ => throw ArgumentError('Unknown value for UIControlContentVerticalAlignment: $value'),
  };
}

enum UIControlContentHorizontalAlignment {
  UIControlContentHorizontalAlignmentCenter(0),
  UIControlContentHorizontalAlignmentLeft(1),
  UIControlContentHorizontalAlignmentRight(2),
  UIControlContentHorizontalAlignmentFill(3),
  UIControlContentHorizontalAlignmentLeading(4),
  UIControlContentHorizontalAlignmentTrailing(5);

  final int value;
  const UIControlContentHorizontalAlignment(this.value);

  static UIControlContentHorizontalAlignment fromValue(int value) => switch (value) {
    0 => UIControlContentHorizontalAlignmentCenter,
    1 => UIControlContentHorizontalAlignmentLeft,
    2 => UIControlContentHorizontalAlignmentRight,
    3 => UIControlContentHorizontalAlignmentFill,
    4 => UIControlContentHorizontalAlignmentLeading,
    5 => UIControlContentHorizontalAlignmentTrailing,
    _ => throw ArgumentError('Unknown value for UIControlContentHorizontalAlignment: $value'),
  };
}

late final _class_UIControl = objc.getClass("UIControl");
late final _sel_initWithFrame_primaryAction_ = objc.registerName("initWithFrame:primaryAction:");
final _objc_msgSend_gxusyk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_isHighlighted = objc.registerName("isHighlighted");
late final _sel_setHighlighted_ = objc.registerName("setHighlighted:");
late final _sel_contentVerticalAlignment = objc.registerName("contentVerticalAlignment");
final _objc_msgSend_nqfjlo = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setContentVerticalAlignment_ = objc.registerName("setContentVerticalAlignment:");
final _objc_msgSend_1jk7esa = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_contentHorizontalAlignment = objc.registerName("contentHorizontalAlignment");
final _objc_msgSend_18109rm = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setContentHorizontalAlignment_ = objc.registerName("setContentHorizontalAlignment:");
final _objc_msgSend_96rhcc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_effectiveContentHorizontalAlignment = objc.registerName("effectiveContentHorizontalAlignment");
late final _sel_state = objc.registerName("state");
final _objc_msgSend_1as6oil = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_isTouchInside = objc.registerName("isTouchInside");
late final _sel_beginTrackingWithTouch_withEvent_ = objc.registerName("beginTrackingWithTouch:withEvent:");
late final _sel_continueTrackingWithTouch_withEvent_ = objc.registerName("continueTrackingWithTouch:withEvent:");
late final _sel_endTrackingWithTouch_withEvent_ = objc.registerName("endTrackingWithTouch:withEvent:");
late final _sel_cancelTrackingWithEvent_ = objc.registerName("cancelTrackingWithEvent:");
late final _sel_addTarget_action_forControlEvents_ = objc.registerName("addTarget:action:forControlEvents:");
final _objc_msgSend_1tj22xm = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_removeTarget_action_forControlEvents_ = objc.registerName("removeTarget:action:forControlEvents:");
late final _sel_addAction_forControlEvents_ = objc.registerName("addAction:forControlEvents:");
final _objc_msgSend_10736wn = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>, int)
    >();
late final _sel_removeAction_forControlEvents_ = objc.registerName("removeAction:forControlEvents:");
late final _sel_removeActionForIdentifier_forControlEvents_ = objc.registerName(
  "removeActionForIdentifier:forControlEvents:",
);
late final _sel_allTargets = objc.registerName("allTargets");
late final _sel_allControlEvents = objc.registerName("allControlEvents");
final _objc_msgSend_61dbeh = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_actionsForTarget_forControlEvent_ = objc.registerName("actionsForTarget:forControlEvent:");
final _objc_msgSend_364s2b = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
      )
    >();
void _ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCSelector> arg2,
  int arg3,
  ffi.Pointer<ffi.Bool> arg4,
) => block.ref.target
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCSelector> arg2,
          ffi.UnsignedLong arg3,
          ffi.Pointer<ffi.Bool> arg4,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<ffi.Bool>,
      )
    >()(arg0, arg1, arg2, arg3, arg4);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.Bool>,
          )
        >(_ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCSelector> arg2,
  int arg3,
  ffi.Pointer<ffi.Bool> arg4,
) =>
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          int,
          ffi.Pointer<ffi.Bool>,
        ))(arg0, arg1, arg2, arg3, arg4);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.Bool>,
          )
        >(_ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCSelector> arg2,
  int arg3,
  ffi.Pointer<ffi.Bool> arg4,
) {
  (objc.getBlockClosure(block)
      as void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<ffi.Bool>,
      ))(arg0, arg1, arg2, arg3, arg4);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCSelector>,
    ffi.UnsignedLong,
    ffi.Pointer<ffi.Bool>,
  )
>
_ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Bool>,
        )
      >.listener(_ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<objc.ObjCObject> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCSelector> arg2,
  int arg3,
  ffi.Pointer<ffi.Bool> arg4,
) {
  try {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          int,
          ffi.Pointer<ffi.Bool>,
        ))(arg0, arg1, arg2, arg3, arg4);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCSelector>,
    ffi.UnsignedLong,
    ffi.Pointer<ffi.Bool>,
  )
>
_ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Bool>,
        )
      >.isolateLocal(
        _ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool_blockingTrampoline,
      )
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCSelector>,
    ffi.UnsignedLong,
    ffi.Pointer<ffi.Bool>,
  )
>
_ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Bool>,
        )
      >.listener(_ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(UIAction?, ffi.Pointer<objc.ObjCObject>?, ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      UIAction?,
      ffi.Pointer<objc.ObjCObject>?,
      ffi.Pointer<objc.ObjCSelector>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<
        ffi.Void Function(
          UIAction?,
          ffi.Pointer<objc.ObjCObject>?,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Bool>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      UIAction?,
      ffi.Pointer<objc.ObjCObject>?,
      ffi.Pointer<objc.ObjCSelector>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCSelector> arg2,
          ffi.UnsignedLong arg3,
          ffi.Pointer<ffi.Bool> arg4,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          UIAction?,
          ffi.Pointer<objc.ObjCObject>?,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Bool>,
        )
      >(
        objc.newPointerBlock(
          _ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool_fnPtrCallable,
          ptr.cast(),
        ),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      UIAction?,
      ffi.Pointer<objc.ObjCObject>?,
      ffi.Pointer<objc.ObjCSelector>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  fromFunction(
    void Function(
      UIAction?,
      objc.ObjCObjectBase?,
      ffi.Pointer<objc.ObjCSelector>,
      UIControlEvents,
      ffi.Pointer<ffi.Bool>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          UIAction?,
          ffi.Pointer<objc.ObjCObject>?,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Bool>,
        )
      >(
        objc.newClosureBlock(
          _ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool_closureCallable,
          (
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCSelector> arg2,
            int arg3,
            ffi.Pointer<ffi.Bool> arg4,
          ) => fn(
            arg0.address == 0 ? null : UIAction.castFromPointer(arg0, retain: true, release: true),
            arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: true, release: true),
            arg2,
            UIControlEvents.fromValue(arg3),
            arg4,
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      UIAction?,
      ffi.Pointer<objc.ObjCObject>?,
      ffi.Pointer<objc.ObjCSelector>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  listener(
    void Function(
      UIAction?,
      objc.ObjCObjectBase?,
      ffi.Pointer<objc.ObjCSelector>,
      UIControlEvents,
      ffi.Pointer<ffi.Bool>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool_listenerCallable.nativeFunction
          .cast(),
      (
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCSelector> arg2,
        int arg3,
        ffi.Pointer<ffi.Bool> arg4,
      ) => fn(
        arg0.address == 0 ? null : UIAction.castFromPointer(arg0, retain: false, release: true),
        arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: false, release: true),
        arg2,
        UIControlEvents.fromValue(arg3),
        arg4,
      ),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_1cxqo1i(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        UIAction?,
        ffi.Pointer<objc.ObjCObject>?,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      UIAction?,
      ffi.Pointer<objc.ObjCObject>?,
      ffi.Pointer<objc.ObjCSelector>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  blocking(
    void Function(
      UIAction?,
      objc.ObjCObjectBase?,
      ffi.Pointer<objc.ObjCSelector>,
      UIControlEvents,
      ffi.Pointer<ffi.Bool>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool_blockingCallable.nativeFunction
          .cast(),
      (
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCSelector> arg2,
        int arg3,
        ffi.Pointer<ffi.Bool> arg4,
      ) => fn(
        arg0.address == 0 ? null : UIAction.castFromPointer(arg0, retain: false, release: true),
        arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: false, release: true),
        arg2,
        UIControlEvents.fromValue(arg3),
        arg4,
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool_blockingListenerCallable
          .nativeFunction
          .cast(),
      (
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCSelector> arg2,
        int arg3,
        ffi.Pointer<ffi.Bool> arg4,
      ) => fn(
        arg0.address == 0 ? null : UIAction.castFromPointer(arg0, retain: false, release: true),
        arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: false, release: true),
        arg2,
        UIControlEvents.fromValue(arg3),
        arg4,
      ),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_1cxqo1i(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        UIAction?,
        ffi.Pointer<objc.ObjCObject>?,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(UIAction?, ffi.Pointer<objc.ObjCObject>?, ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool_CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            UIAction?,
            ffi.Pointer<objc.ObjCObject>?,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.Bool>,
          )
        > {
  void call(
    UIAction? arg0,
    objc.ObjCObjectBase? arg1,
    ffi.Pointer<objc.ObjCSelector> arg2,
    UIControlEvents arg3,
    ffi.Pointer<ffi.Bool> arg4,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCSelector> arg2,
            ffi.UnsignedLong arg3,
            ffi.Pointer<ffi.Bool> arg4,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          int,
          ffi.Pointer<ffi.Bool>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1?.ref.pointer ?? ffi.nullptr, arg2, arg3.value, arg4);
}

late final _sel_enumerateEventHandlers_ = objc.registerName("enumerateEventHandlers:");
late final _sel_sendAction_to_forEvent_ = objc.registerName("sendAction:to:forEvent:");
final _objc_msgSend_lzbvjm = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_sendAction_ = objc.registerName("sendAction:");
late final _sel_sendActionsForControlEvents_ = objc.registerName("sendActionsForControlEvents:");
final _objc_msgSend_n08htp = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_contextMenuInteraction = objc.registerName("contextMenuInteraction");
late final _sel_isContextMenuInteractionEnabled = objc.registerName("isContextMenuInteractionEnabled");
late final _sel_setContextMenuInteractionEnabled_ = objc.registerName("setContextMenuInteractionEnabled:");
late final _sel_showsMenuAsPrimaryAction = objc.registerName("showsMenuAsPrimaryAction");
late final _sel_setShowsMenuAsPrimaryAction_ = objc.registerName("setShowsMenuAsPrimaryAction:");
late final _sel_menuAttachmentPointForConfiguration_ = objc.registerName("menuAttachmentPointForConfiguration:");
final _objc_msgSend_1mpyy6y = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGPoint Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      objc.CGPoint Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)
    >();
final _objc_msgSend_1mpyy6yStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGPoint>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGPoint>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_toolTip = objc.registerName("toolTip");
late final _sel_setToolTip_ = objc.registerName("setToolTip:");

/// WARNING: UIToolTipInteraction is a stub. To generate bindings for this class, include
/// UIToolTipInteraction in your config's objc-interfaces list.
///
/// UIToolTipInteraction
class UIToolTipInteraction extends objc.ObjCObjectBase {
  UIToolTipInteraction._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIToolTipInteraction] that points to the same underlying object as [other].
  UIToolTipInteraction.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIToolTipInteraction] that wraps the given raw object pointer.
  UIToolTipInteraction.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_toolTipInteraction = objc.registerName("toolTipInteraction");

/// UIControl
class UIControl extends UIView {
  UIControl._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIControl', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIControl] that points to the same underlying object as [other].
  UIControl.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIControl] that wraps the given raw object pointer.
  UIControl.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIControl].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIControl);
  }

  /// layerClass
  static objc.ObjCObjectBase getLayerClass() {
    objc.checkOsVersionInternal('UIControl.layerClass', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UIControl, _sel_layerClass);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute(
    UISemanticContentAttribute attribute,
  ) {
    objc.checkOsVersionInternal(
      'UIControl.userInterfaceLayoutDirectionForSemanticContentAttribute:',
      iOS: (false, (9, 0, 0)),
    );
    final _ret = _objc_msgSend_racczx(
      _class_UIControl,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
      attribute.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute$1(
    UISemanticContentAttribute semanticContentAttribute, {
    required UIUserInterfaceLayoutDirection relativeToLayoutDirection,
  }) {
    objc.checkOsVersionInternal(
      'UIControl.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
      iOS: (false, (10, 0, 0)),
    );
    final _ret = _objc_msgSend_tz4p54(
      _class_UIControl,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
      semanticContentAttribute.value,
      relativeToLayoutDirection.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }
}

extension UIControl$Methods on UIControl {
  /// initWithFrame:
  // UIControl initWithFrame(objc.CGRect frame) {
  //   objc.checkOsVersionInternal('UIControl.initWithFrame:', iOS: (false, (2, 0, 0)));
  //   final _ret = _objc_msgSend_15yz4e6(this.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
  //   return UIControl.castFromPointer(_ret, retain: false, release: true);
  // }

  /// initWithCoder:
  UIControl? initWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal('UIControl.initWithCoder:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0 ? null : UIControl.castFromPointer(_ret, retain: false, release: true);
  }

  /// Initializes the control and adds primaryAction for the UIControlEventPrimaryActionTriggered control event. Subclasses of UIControl may alter or add behaviors around the usage of primaryAction, see subclass documentation of this initializer for additional information.
  UIControl initWithFrame(objc.CGRect frame, {UIAction? primaryAction}) {
    objc.checkOsVersionInternal('UIControl.initWithFrame:primaryAction:', iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_gxusyk(
      this.ref.retainAndReturnPointer(),
      _sel_initWithFrame_primaryAction_,
      frame,
      primaryAction?.ref.pointer ?? ffi.nullptr,
    );
    return UIControl.castFromPointer(_ret, retain: false, release: true);
  }

  /// isEnabled
  bool get enabled {
    objc.checkOsVersionInternal('UIControl.isEnabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isEnabled);
  }

  /// setEnabled:
  set enabled(bool value) {
    objc.checkOsVersionInternal('UIControl.setEnabled:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setEnabled_, value);
  }

  /// isSelected
  bool get selected {
    objc.checkOsVersionInternal('UIControl.isSelected', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isSelected);
  }

  /// setSelected:
  set selected(bool value) {
    objc.checkOsVersionInternal('UIControl.setSelected:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setSelected_, value);
  }

  /// isHighlighted
  bool get highlighted {
    objc.checkOsVersionInternal('UIControl.isHighlighted', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isHighlighted);
  }

  /// setHighlighted:
  set highlighted(bool value) {
    objc.checkOsVersionInternal('UIControl.setHighlighted:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHighlighted_, value);
  }

  /// contentVerticalAlignment
  UIControlContentVerticalAlignment get contentVerticalAlignment {
    objc.checkOsVersionInternal('UIControl.contentVerticalAlignment', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_nqfjlo(this.ref.pointer, _sel_contentVerticalAlignment);
    return UIControlContentVerticalAlignment.fromValue(_ret);
  }

  /// setContentVerticalAlignment:
  set contentVerticalAlignment(UIControlContentVerticalAlignment value) {
    objc.checkOsVersionInternal('UIControl.setContentVerticalAlignment:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1jk7esa(this.ref.pointer, _sel_setContentVerticalAlignment_, value.value);
  }

  /// contentHorizontalAlignment
  UIControlContentHorizontalAlignment get contentHorizontalAlignment {
    objc.checkOsVersionInternal('UIControl.contentHorizontalAlignment', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_18109rm(this.ref.pointer, _sel_contentHorizontalAlignment);
    return UIControlContentHorizontalAlignment.fromValue(_ret);
  }

  /// setContentHorizontalAlignment:
  set contentHorizontalAlignment(UIControlContentHorizontalAlignment value) {
    objc.checkOsVersionInternal('UIControl.setContentHorizontalAlignment:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_96rhcc(this.ref.pointer, _sel_setContentHorizontalAlignment_, value.value);
  }

  /// effectiveContentHorizontalAlignment
  UIControlContentHorizontalAlignment get effectiveContentHorizontalAlignment {
    objc.checkOsVersionInternal('UIControl.effectiveContentHorizontalAlignment', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_18109rm(this.ref.pointer, _sel_effectiveContentHorizontalAlignment);
    return UIControlContentHorizontalAlignment.fromValue(_ret);
  }

  /// state
  UIControlState get state {
    objc.checkOsVersionInternal('UIControl.state', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1as6oil(this.ref.pointer, _sel_state);
    return UIControlState.fromValue(_ret);
  }

  /// isTracking
  bool get tracking {
    objc.checkOsVersionInternal('UIControl.isTracking', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isTracking);
  }

  /// isTouchInside
  bool get touchInside {
    objc.checkOsVersionInternal('UIControl.isTouchInside', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isTouchInside);
  }

  /// beginTrackingWithTouch:withEvent:
  bool beginTrackingWithTouch(UITouch touch, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIControl.beginTrackingWithTouch:withEvent:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1lsax7n(
      this.ref.pointer,
      _sel_beginTrackingWithTouch_withEvent_,
      touch.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// continueTrackingWithTouch:withEvent:
  bool continueTrackingWithTouch(UITouch touch, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIControl.continueTrackingWithTouch:withEvent:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1lsax7n(
      this.ref.pointer,
      _sel_continueTrackingWithTouch_withEvent_,
      touch.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// endTrackingWithTouch:withEvent:
  void endTrackingWithTouch(UITouch? touch, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIControl.endTrackingWithTouch:withEvent:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_endTrackingWithTouch_withEvent_,
      touch?.ref.pointer ?? ffi.nullptr,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// cancelTrackingWithEvent:
  void cancelTrackingWithEvent(UIEvent? event) {
    objc.checkOsVersionInternal('UIControl.cancelTrackingWithEvent:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_cancelTrackingWithEvent_, event?.ref.pointer ?? ffi.nullptr);
  }

  /// addTarget:action:forControlEvents:
  void addTarget(
    objc.ObjCObjectBase? target, {
    required ffi.Pointer<objc.ObjCSelector> action,
    required UIControlEvents forControlEvents,
  }) {
    objc.checkOsVersionInternal('UIControl.addTarget:action:forControlEvents:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1tj22xm(
      this.ref.pointer,
      _sel_addTarget_action_forControlEvents_,
      target?.ref.pointer ?? ffi.nullptr,
      action,
      forControlEvents.value,
    );
  }

  /// removeTarget:action:forControlEvents:
  void removeTarget(
    objc.ObjCObjectBase? target, {
    required ffi.Pointer<objc.ObjCSelector> action,
    required UIControlEvents forControlEvents,
  }) {
    objc.checkOsVersionInternal('UIControl.removeTarget:action:forControlEvents:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1tj22xm(
      this.ref.pointer,
      _sel_removeTarget_action_forControlEvents_,
      target?.ref.pointer ?? ffi.nullptr,
      action,
      forControlEvents.value,
    );
  }

  /// Adds the UIAction to a given event. UIActions are uniqued based on their identifier, and subsequent actions with the same identifier replace previously added actions. You may add multiple UIActions for corresponding controlEvents, and you may add the same action to multiple controlEvents.
  void addAction(UIAction action, {required UIControlEvents forControlEvents}) {
    objc.checkOsVersionInternal('UIControl.addAction:forControlEvents:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_10736wn(
      this.ref.pointer,
      _sel_addAction_forControlEvents_,
      action.ref.pointer,
      forControlEvents.value,
    );
  }

  /// Removes the action from the set of passed control events.
  void removeAction(UIAction action, {required UIControlEvents forControlEvents}) {
    objc.checkOsVersionInternal('UIControl.removeAction:forControlEvents:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_10736wn(
      this.ref.pointer,
      _sel_removeAction_forControlEvents_,
      action.ref.pointer,
      forControlEvents.value,
    );
  }

  /// Removes the action with the provided identifier from the set of passed control events.
  void removeActionForIdentifier(objc.NSString actionIdentifier, {required UIControlEvents forControlEvents}) {
    objc.checkOsVersionInternal('UIControl.removeActionForIdentifier:forControlEvents:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_10736wn(
      this.ref.pointer,
      _sel_removeActionForIdentifier_forControlEvents_,
      actionIdentifier.ref.pointer,
      forControlEvents.value,
    );
  }

  /// allTargets
  objc.NSSet get allTargets {
    objc.checkOsVersionInternal('UIControl.allTargets', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_allTargets);
    return objc.NSSet.castFromPointer(_ret, retain: true, release: true);
  }

  /// allControlEvents
  UIControlEvents get allControlEvents {
    objc.checkOsVersionInternal('UIControl.allControlEvents', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_61dbeh(this.ref.pointer, _sel_allControlEvents);
    return UIControlEvents.fromValue(_ret);
  }

  /// actionsForTarget:forControlEvent:
  objc.NSArray? actionsForTarget(objc.ObjCObjectBase? target, {required UIControlEvents forControlEvent}) {
    objc.checkOsVersionInternal('UIControl.actionsForTarget:forControlEvent:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_364s2b(
      this.ref.pointer,
      _sel_actionsForTarget_forControlEvent_,
      target?.ref.pointer ?? ffi.nullptr,
      forControlEvent.value,
    );
    return _ret.address == 0 ? null : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// Iterate over the event handlers installed on this control at the time this method is called. For each call, either actionHandler or action will be non-nil. controlEvents is always non-zero. Setting *stop to YES will terminate the enumeration early. It is legal to manipulate the control's event handlers within the block.
  void enumerateEventHandlers(
    objc.ObjCBlock<
      ffi.Void Function(
        UIAction?,
        ffi.Pointer<objc.ObjCObject>?,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >
    iterator,
  ) {
    objc.checkOsVersionInternal('UIControl.enumerateEventHandlers:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_f167m6(this.ref.pointer, _sel_enumerateEventHandlers_, iterator.ref.pointer);
  }

  /// Dispatch the target-action pair. This method is called repeatedly by -sendActionsForControlEvents: and is a point at which you can observe or override behavior.
  void sendAction(ffi.Pointer<objc.ObjCSelector> action, {objc.ObjCObjectBase? to, UIEvent? forEvent}) {
    objc.checkOsVersionInternal('UIControl.sendAction:to:forEvent:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_lzbvjm(
      this.ref.pointer,
      _sel_sendAction_to_forEvent_,
      action,
      to?.ref.pointer ?? ffi.nullptr,
      forEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// Like -sendAction:to:forEvent:, this method is called by -sendActionsForControlEvents:. You may override this method to observe or modify behavior. If you override this method, you should call super precisely once to dispatch the action, or not call super to suppress sending that action.
  void sendAction$1(UIAction action) {
    objc.checkOsVersionInternal('UIControl.sendAction:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_sendAction_, action.ref.pointer);
  }

  /// send all actions associated with the given control events
  void sendActionsForControlEvents(UIControlEvents controlEvents) {
    objc.checkOsVersionInternal('UIControl.sendActionsForControlEvents:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_n08htp(this.ref.pointer, _sel_sendActionsForControlEvents_, controlEvents.value);
  }

  /// Returns a UIContextMenuInteraction with this control set as its delegate. Before constructing the UIContextMenuInteraction, UIControl verifies 'self' is a viable delegate. See 'Implementing UIControl Menus' below for more details.
  UIContextMenuInteraction? get contextMenuInteraction {
    objc.checkOsVersionInternal('UIControl.contextMenuInteraction', iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_contextMenuInteraction);
    return _ret.address == 0 ? null : UIContextMenuInteraction.castFromPointer(_ret, retain: true, release: true);
  }

  /// Specifies if the context menu interaction is enabled. NO by default.
  bool get contextMenuInteractionEnabled {
    objc.checkOsVersionInternal('UIControl.isContextMenuInteractionEnabled', iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isContextMenuInteractionEnabled);
  }

  /// Specifies if the context menu interaction is enabled. NO by default.
  set contextMenuInteractionEnabled(bool value) {
    objc.checkOsVersionInternal('UIControl.setContextMenuInteractionEnabled:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setContextMenuInteractionEnabled_, value);
  }

  /// If the contextMenuInteraction is the primary action of the control, invoked on touch-down. NO by default.
  bool get showsMenuAsPrimaryAction {
    objc.checkOsVersionInternal('UIControl.showsMenuAsPrimaryAction', iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_showsMenuAsPrimaryAction);
  }

  /// If the contextMenuInteraction is the primary action of the control, invoked on touch-down. NO by default.
  set showsMenuAsPrimaryAction(bool value) {
    objc.checkOsVersionInternal('UIControl.setShowsMenuAsPrimaryAction:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setShowsMenuAsPrimaryAction_, value);
  }

  /// Return a point in this control's coordinate space to which to attach the given configuration's menu.
  objc.CGPoint menuAttachmentPointForConfiguration(UIContextMenuConfiguration configuration) {
    objc.checkOsVersionInternal('UIControl.menuAttachmentPointForConfiguration:', iOS: (false, (14, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1mpyy6yStret(
            _ptr,
            this.ref.pointer,
            _sel_menuAttachmentPointForConfiguration_,
            configuration.ref.pointer,
          )
        : _ptr.ref = _objc_msgSend_1mpyy6y(
            this.ref.pointer,
            _sel_menuAttachmentPointForConfiguration_,
            configuration.ref.pointer,
          );
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>(_finalizable);
  }

  /// Assigning a value to this property causes the tool tip to be displayed for the view. Setting the property to nil cancels the display of the tool tip for the view.
  objc.NSString? get toolTip {
    objc.checkOsVersionInternal('UIControl.toolTip', iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_toolTip);
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Assigning a value to this property causes the tool tip to be displayed for the view. Setting the property to nil cancels the display of the tool tip for the view.
  set toolTip(objc.NSString? value) {
    objc.checkOsVersionInternal('UIControl.setToolTip:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setToolTip_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Returns the control's default UIToolTipInteraction.
  UIToolTipInteraction? get toolTipInteraction {
    objc.checkOsVersionInternal('UIControl.toolTipInteraction', iOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_toolTipInteraction);
    return _ret.address == 0 ? null : UIToolTipInteraction.castFromPointer(_ret, retain: true, release: true);
  }
}

enum NSWritingDirection {
  NSWritingDirectionNatural(-1),
  NSWritingDirectionLeftToRight(0),
  NSWritingDirectionRightToLeft(1);

  final int value;
  const NSWritingDirection(this.value);

  static NSWritingDirection fromValue(int value) => switch (value) {
    -1 => NSWritingDirectionNatural,
    0 => NSWritingDirectionLeftToRight,
    1 => NSWritingDirectionRightToLeft,
    _ => throw ArgumentError('Unknown value for NSWritingDirection: $value'),
  };
}

enum NSPasteboardAccessBehavior {
  NSPasteboardAccessBehaviorDefault(0),
  NSPasteboardAccessBehaviorAsk(1),
  NSPasteboardAccessBehaviorAlwaysAllow(2),
  NSPasteboardAccessBehaviorAlwaysDeny(3);

  final int value;
  const NSPasteboardAccessBehavior(this.value);

  static NSPasteboardAccessBehavior fromValue(int value) => switch (value) {
    0 => NSPasteboardAccessBehaviorDefault,
    1 => NSPasteboardAccessBehaviorAsk,
    2 => NSPasteboardAccessBehaviorAlwaysAllow,
    3 => NSPasteboardAccessBehaviorAlwaysDeny,
    _ => throw ArgumentError('Unknown value for NSPasteboardAccessBehavior: $value'),
  };
}

enum NSPasteboardContentsOptions {
  NSPasteboardContentsCurrentHostOnly(1);

  final int value;
  const NSPasteboardContentsOptions(this.value);

  static NSPasteboardContentsOptions fromValue(int value) => switch (value) {
    1 => NSPasteboardContentsCurrentHostOnly,
    _ => throw ArgumentError('Unknown value for NSPasteboardContentsOptions: $value'),
  };
}

enum NSDragOperation {
  NSDragOperationNone(0),
  NSDragOperationCopy(1),
  NSDragOperationLink(2),
  NSDragOperationGeneric(4),
  NSDragOperationPrivate(8),
  NSDragOperationMove(16),
  NSDragOperationDelete(32),
  NSDragOperationEvery(-1),
  NSDragOperationAll_Obsolete(15);

  static const NSDragOperationAll = NSDragOperationAll_Obsolete;

  final int value;
  const NSDragOperation(this.value);

  static NSDragOperation fromValue(int value) => switch (value) {
    0 => NSDragOperationNone,
    1 => NSDragOperationCopy,
    2 => NSDragOperationLink,
    4 => NSDragOperationGeneric,
    8 => NSDragOperationPrivate,
    16 => NSDragOperationMove,
    32 => NSDragOperationDelete,
    -1 => NSDragOperationEvery,
    15 => NSDragOperationAll_Obsolete,
    _ => throw ArgumentError('Unknown value for NSDragOperation: $value'),
  };

  @override
  String toString() {
    if (this == NSDragOperationAll_Obsolete)
      return "NSDragOperation.NSDragOperationAll_Obsolete, NSDragOperation.NSDragOperationAll";
    return super.toString();
  }
}

enum NSDraggingFormation {
  NSDraggingFormationDefault(0),
  NSDraggingFormationNone(1),
  NSDraggingFormationPile(2),
  NSDraggingFormationList(3),
  NSDraggingFormationStack(4);

  final int value;
  const NSDraggingFormation(this.value);

  static NSDraggingFormation fromValue(int value) => switch (value) {
    0 => NSDraggingFormationDefault,
    1 => NSDraggingFormationNone,
    2 => NSDraggingFormationPile,
    3 => NSDraggingFormationList,
    4 => NSDraggingFormationStack,
    _ => throw ArgumentError('Unknown value for NSDraggingFormation: $value'),
  };
}

enum NSDraggingContext {
  NSDraggingContextOutsideApplication(0),
  NSDraggingContextWithinApplication(1);

  final int value;
  const NSDraggingContext(this.value);

  static NSDraggingContext fromValue(int value) => switch (value) {
    0 => NSDraggingContextOutsideApplication,
    1 => NSDraggingContextWithinApplication,
    _ => throw ArgumentError('Unknown value for NSDraggingContext: $value'),
  };
}

enum NSDraggingItemEnumerationOptions {
  NSDraggingItemEnumerationConcurrent(1),
  NSDraggingItemEnumerationClearNonenumeratedImages(65536);

  final int value;
  const NSDraggingItemEnumerationOptions(this.value);

  static NSDraggingItemEnumerationOptions fromValue(int value) => switch (value) {
    1 => NSDraggingItemEnumerationConcurrent,
    65536 => NSDraggingItemEnumerationClearNonenumeratedImages,
    _ => throw ArgumentError('Unknown value for NSDraggingItemEnumerationOptions: $value'),
  };
}

enum NSSpringLoadingHighlight {
  NSSpringLoadingHighlightNone(0),
  NSSpringLoadingHighlightStandard(1),
  NSSpringLoadingHighlightEmphasized(2);

  final int value;
  const NSSpringLoadingHighlight(this.value);

  static NSSpringLoadingHighlight fromValue(int value) => switch (value) {
    0 => NSSpringLoadingHighlightNone,
    1 => NSSpringLoadingHighlightStandard,
    2 => NSSpringLoadingHighlightEmphasized,
    _ => throw ArgumentError('Unknown value for NSSpringLoadingHighlight: $value'),
  };
}

enum NSWindowOrderingMode {
  NSWindowAbove(1),
  NSWindowBelow(-1),
  NSWindowOut(0);

  final int value;
  const NSWindowOrderingMode(this.value);

  static NSWindowOrderingMode fromValue(int value) => switch (value) {
    1 => NSWindowAbove,
    -1 => NSWindowBelow,
    0 => NSWindowOut,
    _ => throw ArgumentError('Unknown value for NSWindowOrderingMode: $value'),
  };
}

enum NSFocusRingType {
  NSFocusRingTypeDefault(0),
  NSFocusRingTypeNone(1),
  NSFocusRingTypeExterior(2);

  final int value;
  const NSFocusRingType(this.value);

  static NSFocusRingType fromValue(int value) => switch (value) {
    0 => NSFocusRingTypeDefault,
    1 => NSFocusRingTypeNone,
    2 => NSFocusRingTypeExterior,
    _ => throw ArgumentError('Unknown value for NSFocusRingType: $value'),
  };
}

enum NSTouchPhase {
  NSTouchPhaseBegan(1),
  NSTouchPhaseMoved(2),
  NSTouchPhaseStationary(4),
  NSTouchPhaseEnded(8),
  NSTouchPhaseCancelled(16),
  NSTouchPhaseTouching(7),
  NSTouchPhaseAny(-1);

  final int value;
  const NSTouchPhase(this.value);

  static NSTouchPhase fromValue(int value) => switch (value) {
    1 => NSTouchPhaseBegan,
    2 => NSTouchPhaseMoved,
    4 => NSTouchPhaseStationary,
    8 => NSTouchPhaseEnded,
    16 => NSTouchPhaseCancelled,
    7 => NSTouchPhaseTouching,
    -1 => NSTouchPhaseAny,
    _ => throw ArgumentError('Unknown value for NSTouchPhase: $value'),
  };
}

enum NSTouchType {
  NSTouchTypeDirect(0),
  NSTouchTypeIndirect(1);

  final int value;
  const NSTouchType(this.value);

  static NSTouchType fromValue(int value) => switch (value) {
    0 => NSTouchTypeDirect,
    1 => NSTouchTypeIndirect,
    _ => throw ArgumentError('Unknown value for NSTouchType: $value'),
  };
}

enum NSTouchTypeMask {
  NSTouchTypeMaskDirect(1),
  NSTouchTypeMaskIndirect(2);

  final int value;
  const NSTouchTypeMask(this.value);

  static NSTouchTypeMask fromValue(int value) => switch (value) {
    1 => NSTouchTypeMaskDirect,
    2 => NSTouchTypeMaskIndirect,
    _ => throw ArgumentError('Unknown value for NSTouchTypeMask: $value'),
  };
}

enum NSEventType {
  NSEventTypeLeftMouseDown(1),
  NSEventTypeLeftMouseUp(2),
  NSEventTypeRightMouseDown(3),
  NSEventTypeRightMouseUp(4),
  NSEventTypeMouseMoved(5),
  NSEventTypeLeftMouseDragged(6),
  NSEventTypeRightMouseDragged(7),
  NSEventTypeMouseEntered(8),
  NSEventTypeMouseExited(9),
  NSEventTypeKeyDown(10),
  NSEventTypeKeyUp(11),
  NSEventTypeFlagsChanged(12),
  NSEventTypeAppKitDefined(13),
  NSEventTypeSystemDefined(14),
  NSEventTypeApplicationDefined(15),
  NSEventTypePeriodic(16),
  NSEventTypeCursorUpdate(17),
  NSEventTypeScrollWheel(22),
  NSEventTypeTabletPoint(23),
  NSEventTypeTabletProximity(24),
  NSEventTypeOtherMouseDown(25),
  NSEventTypeOtherMouseUp(26),
  NSEventTypeOtherMouseDragged(27),
  NSEventTypeGesture(29),
  NSEventTypeMagnify(30),
  NSEventTypeSwipe(31),
  NSEventTypeRotate(18),
  NSEventTypeBeginGesture(19),
  NSEventTypeEndGesture(20),
  NSEventTypeSmartMagnify(32),
  NSEventTypeQuickLook(33),
  NSEventTypePressure(34),
  NSEventTypeDirectTouch(37),
  NSEventTypeChangeMode(38),
  NSEventTypeMouseCancelled(40);

  final int value;
  const NSEventType(this.value);

  static NSEventType fromValue(int value) => switch (value) {
    1 => NSEventTypeLeftMouseDown,
    2 => NSEventTypeLeftMouseUp,
    3 => NSEventTypeRightMouseDown,
    4 => NSEventTypeRightMouseUp,
    5 => NSEventTypeMouseMoved,
    6 => NSEventTypeLeftMouseDragged,
    7 => NSEventTypeRightMouseDragged,
    8 => NSEventTypeMouseEntered,
    9 => NSEventTypeMouseExited,
    10 => NSEventTypeKeyDown,
    11 => NSEventTypeKeyUp,
    12 => NSEventTypeFlagsChanged,
    13 => NSEventTypeAppKitDefined,
    14 => NSEventTypeSystemDefined,
    15 => NSEventTypeApplicationDefined,
    16 => NSEventTypePeriodic,
    17 => NSEventTypeCursorUpdate,
    22 => NSEventTypeScrollWheel,
    23 => NSEventTypeTabletPoint,
    24 => NSEventTypeTabletProximity,
    25 => NSEventTypeOtherMouseDown,
    26 => NSEventTypeOtherMouseUp,
    27 => NSEventTypeOtherMouseDragged,
    29 => NSEventTypeGesture,
    30 => NSEventTypeMagnify,
    31 => NSEventTypeSwipe,
    18 => NSEventTypeRotate,
    19 => NSEventTypeBeginGesture,
    20 => NSEventTypeEndGesture,
    32 => NSEventTypeSmartMagnify,
    33 => NSEventTypeQuickLook,
    34 => NSEventTypePressure,
    37 => NSEventTypeDirectTouch,
    38 => NSEventTypeChangeMode,
    40 => NSEventTypeMouseCancelled,
    _ => throw ArgumentError('Unknown value for NSEventType: $value'),
  };
}

enum NSEventMask {
  NSEventMaskLeftMouseDown(2),
  NSEventMaskLeftMouseUp(4),
  NSEventMaskRightMouseDown(8),
  NSEventMaskRightMouseUp(16),
  NSEventMaskMouseMoved(32),
  NSEventMaskLeftMouseDragged(64),
  NSEventMaskRightMouseDragged(128),
  NSEventMaskMouseEntered(256),
  NSEventMaskMouseExited(512),
  NSEventMaskKeyDown(1024),
  NSEventMaskKeyUp(2048),
  NSEventMaskFlagsChanged(4096),
  NSEventMaskAppKitDefined(8192),
  NSEventMaskSystemDefined(16384),
  NSEventMaskApplicationDefined(32768),
  NSEventMaskPeriodic(65536),
  NSEventMaskCursorUpdate(131072),
  NSEventMaskScrollWheel(4194304),
  NSEventMaskTabletPoint(8388608),
  NSEventMaskTabletProximity(16777216),
  NSEventMaskOtherMouseDown(33554432),
  NSEventMaskOtherMouseUp(67108864),
  NSEventMaskOtherMouseDragged(134217728),
  NSEventMaskGesture(536870912),
  NSEventMaskMagnify(1073741824),
  NSEventMaskSwipe(2147483648),
  NSEventMaskRotate(262144),
  NSEventMaskBeginGesture(524288),
  NSEventMaskEndGesture(1048576),
  NSEventMaskSmartMagnify(4294967296),
  NSEventMaskPressure(17179869184),
  NSEventMaskDirectTouch(137438953472),
  NSEventMaskChangeMode(274877906944),
  NSEventMaskMouseCancelled(1099511627776),
  NSEventMaskAny(-1);

  final int value;
  const NSEventMask(this.value);

  static NSEventMask fromValue(int value) => switch (value) {
    2 => NSEventMaskLeftMouseDown,
    4 => NSEventMaskLeftMouseUp,
    8 => NSEventMaskRightMouseDown,
    16 => NSEventMaskRightMouseUp,
    32 => NSEventMaskMouseMoved,
    64 => NSEventMaskLeftMouseDragged,
    128 => NSEventMaskRightMouseDragged,
    256 => NSEventMaskMouseEntered,
    512 => NSEventMaskMouseExited,
    1024 => NSEventMaskKeyDown,
    2048 => NSEventMaskKeyUp,
    4096 => NSEventMaskFlagsChanged,
    8192 => NSEventMaskAppKitDefined,
    16384 => NSEventMaskSystemDefined,
    32768 => NSEventMaskApplicationDefined,
    65536 => NSEventMaskPeriodic,
    131072 => NSEventMaskCursorUpdate,
    4194304 => NSEventMaskScrollWheel,
    8388608 => NSEventMaskTabletPoint,
    16777216 => NSEventMaskTabletProximity,
    33554432 => NSEventMaskOtherMouseDown,
    67108864 => NSEventMaskOtherMouseUp,
    134217728 => NSEventMaskOtherMouseDragged,
    536870912 => NSEventMaskGesture,
    1073741824 => NSEventMaskMagnify,
    2147483648 => NSEventMaskSwipe,
    262144 => NSEventMaskRotate,
    524288 => NSEventMaskBeginGesture,
    1048576 => NSEventMaskEndGesture,
    4294967296 => NSEventMaskSmartMagnify,
    17179869184 => NSEventMaskPressure,
    137438953472 => NSEventMaskDirectTouch,
    274877906944 => NSEventMaskChangeMode,
    1099511627776 => NSEventMaskMouseCancelled,
    -1 => NSEventMaskAny,
    _ => throw ArgumentError('Unknown value for NSEventMask: $value'),
  };
}

enum NSEventModifierFlags {
  NSEventModifierFlagCapsLock(65536),
  NSEventModifierFlagShift(131072),
  NSEventModifierFlagControl(262144),
  NSEventModifierFlagOption(524288),
  NSEventModifierFlagCommand(1048576),
  NSEventModifierFlagNumericPad(2097152),
  NSEventModifierFlagHelp(4194304),
  NSEventModifierFlagFunction(8388608),
  NSEventModifierFlagDeviceIndependentFlagsMask(4294901760);

  final int value;
  const NSEventModifierFlags(this.value);

  static NSEventModifierFlags fromValue(int value) => switch (value) {
    65536 => NSEventModifierFlagCapsLock,
    131072 => NSEventModifierFlagShift,
    262144 => NSEventModifierFlagControl,
    524288 => NSEventModifierFlagOption,
    1048576 => NSEventModifierFlagCommand,
    2097152 => NSEventModifierFlagNumericPad,
    4194304 => NSEventModifierFlagHelp,
    8388608 => NSEventModifierFlagFunction,
    4294901760 => NSEventModifierFlagDeviceIndependentFlagsMask,
    _ => throw ArgumentError('Unknown value for NSEventModifierFlags: $value'),
  };
}

enum NSPointingDeviceType {
  NSPointingDeviceTypeUnknown(0),
  NSPointingDeviceTypePen(1),
  NSPointingDeviceTypeCursor(2),
  NSPointingDeviceTypeEraser(3);

  final int value;
  const NSPointingDeviceType(this.value);

  static NSPointingDeviceType fromValue(int value) => switch (value) {
    0 => NSPointingDeviceTypeUnknown,
    1 => NSPointingDeviceTypePen,
    2 => NSPointingDeviceTypeCursor,
    3 => NSPointingDeviceTypeEraser,
    _ => throw ArgumentError('Unknown value for NSPointingDeviceType: $value'),
  };
}

enum NSEventButtonMask {
  NSEventButtonMaskPenTip(1),
  NSEventButtonMaskPenLowerSide(2),
  NSEventButtonMaskPenUpperSide(4);

  final int value;
  const NSEventButtonMask(this.value);

  static NSEventButtonMask fromValue(int value) => switch (value) {
    1 => NSEventButtonMaskPenTip,
    2 => NSEventButtonMaskPenLowerSide,
    4 => NSEventButtonMaskPenUpperSide,
    _ => throw ArgumentError('Unknown value for NSEventButtonMask: $value'),
  };
}

enum NSEventPhase {
  NSEventPhaseNone(0),
  NSEventPhaseBegan(1),
  NSEventPhaseStationary(2),
  NSEventPhaseChanged(4),
  NSEventPhaseEnded(8),
  NSEventPhaseCancelled(16),
  NSEventPhaseMayBegin(32);

  final int value;
  const NSEventPhase(this.value);

  static NSEventPhase fromValue(int value) => switch (value) {
    0 => NSEventPhaseNone,
    1 => NSEventPhaseBegan,
    2 => NSEventPhaseStationary,
    4 => NSEventPhaseChanged,
    8 => NSEventPhaseEnded,
    16 => NSEventPhaseCancelled,
    32 => NSEventPhaseMayBegin,
    _ => throw ArgumentError('Unknown value for NSEventPhase: $value'),
  };
}

enum NSEventGestureAxis {
  NSEventGestureAxisNone(0),
  NSEventGestureAxisHorizontal(1),
  NSEventGestureAxisVertical(2);

  final int value;
  const NSEventGestureAxis(this.value);

  static NSEventGestureAxis fromValue(int value) => switch (value) {
    0 => NSEventGestureAxisNone,
    1 => NSEventGestureAxisHorizontal,
    2 => NSEventGestureAxisVertical,
    _ => throw ArgumentError('Unknown value for NSEventGestureAxis: $value'),
  };
}

enum NSEventSwipeTrackingOptions {
  NSEventSwipeTrackingLockDirection(1),
  NSEventSwipeTrackingClampGestureAmount(2);

  final int value;
  const NSEventSwipeTrackingOptions(this.value);

  static NSEventSwipeTrackingOptions fromValue(int value) => switch (value) {
    1 => NSEventSwipeTrackingLockDirection,
    2 => NSEventSwipeTrackingClampGestureAmount,
    _ => throw ArgumentError('Unknown value for NSEventSwipeTrackingOptions: $value'),
  };
}

enum NSEventSubtype {
  NSEventSubtypeWindowExposed(0),
  NSEventSubtypeApplicationActivated(1),
  NSEventSubtypeApplicationDeactivated(2),
  NSEventSubtypeWindowMoved(4),
  NSEventSubtypeScreenChanged(8),
  NSEventSubtypeTouch(3);

  static const NSEventSubtypePowerOff = NSEventSubtypeApplicationActivated;
  static const NSEventSubtypeMouseEvent = NSEventSubtypeWindowExposed;
  static const NSEventSubtypeTabletPoint = NSEventSubtypeApplicationActivated;
  static const NSEventSubtypeTabletProximity = NSEventSubtypeApplicationDeactivated;

  final int value;
  const NSEventSubtype(this.value);

  static NSEventSubtype fromValue(int value) => switch (value) {
    0 => NSEventSubtypeWindowExposed,
    1 => NSEventSubtypeApplicationActivated,
    2 => NSEventSubtypeApplicationDeactivated,
    4 => NSEventSubtypeWindowMoved,
    8 => NSEventSubtypeScreenChanged,
    3 => NSEventSubtypeTouch,
    _ => throw ArgumentError('Unknown value for NSEventSubtype: $value'),
  };

  @override
  String toString() {
    if (this == NSEventSubtypeWindowExposed)
      return "NSEventSubtype.NSEventSubtypeWindowExposed, NSEventSubtype.NSEventSubtypeMouseEvent";
    if (this == NSEventSubtypeApplicationActivated)
      return "NSEventSubtype.NSEventSubtypeApplicationActivated, NSEventSubtype.NSEventSubtypePowerOff, NSEventSubtype.NSEventSubtypeTabletPoint";
    if (this == NSEventSubtypeApplicationDeactivated)
      return "NSEventSubtype.NSEventSubtypeApplicationDeactivated, NSEventSubtype.NSEventSubtypeTabletProximity";
    return super.toString();
  }
}

enum NSPressureBehavior {
  NSPressureBehaviorUnknown(-1),
  NSPressureBehaviorPrimaryDefault(0),
  NSPressureBehaviorPrimaryClick(1),
  NSPressureBehaviorPrimaryGeneric(2),
  NSPressureBehaviorPrimaryAccelerator(3),
  NSPressureBehaviorPrimaryDeepClick(5),
  NSPressureBehaviorPrimaryDeepDrag(6);

  final int value;
  const NSPressureBehavior(this.value);

  static NSPressureBehavior fromValue(int value) => switch (value) {
    -1 => NSPressureBehaviorUnknown,
    0 => NSPressureBehaviorPrimaryDefault,
    1 => NSPressureBehaviorPrimaryClick,
    2 => NSPressureBehaviorPrimaryGeneric,
    3 => NSPressureBehaviorPrimaryAccelerator,
    5 => NSPressureBehaviorPrimaryDeepClick,
    6 => NSPressureBehaviorPrimaryDeepDrag,
    _ => throw ArgumentError('Unknown value for NSPressureBehavior: $value'),
  };
}

enum NSAccessibilityOrientation {
  NSAccessibilityOrientationUnknown(0),
  NSAccessibilityOrientationVertical(1),
  NSAccessibilityOrientationHorizontal(2);

  final int value;
  const NSAccessibilityOrientation(this.value);

  static NSAccessibilityOrientation fromValue(int value) => switch (value) {
    0 => NSAccessibilityOrientationUnknown,
    1 => NSAccessibilityOrientationVertical,
    2 => NSAccessibilityOrientationHorizontal,
    _ => throw ArgumentError('Unknown value for NSAccessibilityOrientation: $value'),
  };
}

enum NSAccessibilitySortDirection {
  NSAccessibilitySortDirectionUnknown(0),
  NSAccessibilitySortDirectionAscending(1),
  NSAccessibilitySortDirectionDescending(2);

  final int value;
  const NSAccessibilitySortDirection(this.value);

  static NSAccessibilitySortDirection fromValue(int value) => switch (value) {
    0 => NSAccessibilitySortDirectionUnknown,
    1 => NSAccessibilitySortDirectionAscending,
    2 => NSAccessibilitySortDirectionDescending,
    _ => throw ArgumentError('Unknown value for NSAccessibilitySortDirection: $value'),
  };
}

enum NSAccessibilityRulerMarkerType {
  NSAccessibilityRulerMarkerTypeUnknown(0),
  NSAccessibilityRulerMarkerTypeTabStopLeft(1),
  NSAccessibilityRulerMarkerTypeTabStopRight(2),
  NSAccessibilityRulerMarkerTypeTabStopCenter(3),
  NSAccessibilityRulerMarkerTypeTabStopDecimal(4),
  NSAccessibilityRulerMarkerTypeIndentHead(5),
  NSAccessibilityRulerMarkerTypeIndentTail(6),
  NSAccessibilityRulerMarkerTypeIndentFirstLine(7);

  final int value;
  const NSAccessibilityRulerMarkerType(this.value);

  static NSAccessibilityRulerMarkerType fromValue(int value) => switch (value) {
    0 => NSAccessibilityRulerMarkerTypeUnknown,
    1 => NSAccessibilityRulerMarkerTypeTabStopLeft,
    2 => NSAccessibilityRulerMarkerTypeTabStopRight,
    3 => NSAccessibilityRulerMarkerTypeTabStopCenter,
    4 => NSAccessibilityRulerMarkerTypeTabStopDecimal,
    5 => NSAccessibilityRulerMarkerTypeIndentHead,
    6 => NSAccessibilityRulerMarkerTypeIndentTail,
    7 => NSAccessibilityRulerMarkerTypeIndentFirstLine,
    _ => throw ArgumentError('Unknown value for NSAccessibilityRulerMarkerType: $value'),
  };
}

enum NSAccessibilityUnits {
  NSAccessibilityUnitsUnknown(0),
  NSAccessibilityUnitsInches(1),
  NSAccessibilityUnitsCentimeters(2),
  NSAccessibilityUnitsPoints(3),
  NSAccessibilityUnitsPicas(4);

  final int value;
  const NSAccessibilityUnits(this.value);

  static NSAccessibilityUnits fromValue(int value) => switch (value) {
    0 => NSAccessibilityUnitsUnknown,
    1 => NSAccessibilityUnitsInches,
    2 => NSAccessibilityUnitsCentimeters,
    3 => NSAccessibilityUnitsPoints,
    4 => NSAccessibilityUnitsPicas,
    _ => throw ArgumentError('Unknown value for NSAccessibilityUnits: $value'),
  };
}

enum NSUserInterfaceLayoutDirection {
  NSUserInterfaceLayoutDirectionLeftToRight(0),
  NSUserInterfaceLayoutDirectionRightToLeft(1);

  final int value;
  const NSUserInterfaceLayoutDirection(this.value);

  static NSUserInterfaceLayoutDirection fromValue(int value) => switch (value) {
    0 => NSUserInterfaceLayoutDirectionLeftToRight,
    1 => NSUserInterfaceLayoutDirectionRightToLeft,
    _ => throw ArgumentError('Unknown value for NSUserInterfaceLayoutDirection: $value'),
  };
}

enum NSAutoresizingMaskOptions {
  NSViewNotSizable(0),
  NSViewMinXMargin(1),
  NSViewWidthSizable(2),
  NSViewMaxXMargin(4),
  NSViewMinYMargin(8),
  NSViewHeightSizable(16),
  NSViewMaxYMargin(32);

  final int value;
  const NSAutoresizingMaskOptions(this.value);

  static NSAutoresizingMaskOptions fromValue(int value) => switch (value) {
    0 => NSViewNotSizable,
    1 => NSViewMinXMargin,
    2 => NSViewWidthSizable,
    4 => NSViewMaxXMargin,
    8 => NSViewMinYMargin,
    16 => NSViewHeightSizable,
    32 => NSViewMaxYMargin,
    _ => throw ArgumentError('Unknown value for NSAutoresizingMaskOptions: $value'),
  };
}

enum NSViewLayerContentsRedrawPolicy {
  NSViewLayerContentsRedrawNever(0),
  NSViewLayerContentsRedrawOnSetNeedsDisplay(1),
  NSViewLayerContentsRedrawDuringViewResize(2),
  NSViewLayerContentsRedrawBeforeViewResize(3),
  NSViewLayerContentsRedrawCrossfade(4);

  final int value;
  const NSViewLayerContentsRedrawPolicy(this.value);

  static NSViewLayerContentsRedrawPolicy fromValue(int value) => switch (value) {
    0 => NSViewLayerContentsRedrawNever,
    1 => NSViewLayerContentsRedrawOnSetNeedsDisplay,
    2 => NSViewLayerContentsRedrawDuringViewResize,
    3 => NSViewLayerContentsRedrawBeforeViewResize,
    4 => NSViewLayerContentsRedrawCrossfade,
    _ => throw ArgumentError('Unknown value for NSViewLayerContentsRedrawPolicy: $value'),
  };
}

enum NSViewLayerContentsPlacement {
  NSViewLayerContentsPlacementScaleAxesIndependently(0),
  NSViewLayerContentsPlacementScaleProportionallyToFit(1),
  NSViewLayerContentsPlacementScaleProportionallyToFill(2),
  NSViewLayerContentsPlacementCenter(3),
  NSViewLayerContentsPlacementTop(4),
  NSViewLayerContentsPlacementTopRight(5),
  NSViewLayerContentsPlacementRight(6),
  NSViewLayerContentsPlacementBottomRight(7),
  NSViewLayerContentsPlacementBottom(8),
  NSViewLayerContentsPlacementBottomLeft(9),
  NSViewLayerContentsPlacementLeft(10),
  NSViewLayerContentsPlacementTopLeft(11);

  final int value;
  const NSViewLayerContentsPlacement(this.value);

  static NSViewLayerContentsPlacement fromValue(int value) => switch (value) {
    0 => NSViewLayerContentsPlacementScaleAxesIndependently,
    1 => NSViewLayerContentsPlacementScaleProportionallyToFit,
    2 => NSViewLayerContentsPlacementScaleProportionallyToFill,
    3 => NSViewLayerContentsPlacementCenter,
    4 => NSViewLayerContentsPlacementTop,
    5 => NSViewLayerContentsPlacementTopRight,
    6 => NSViewLayerContentsPlacementRight,
    7 => NSViewLayerContentsPlacementBottomRight,
    8 => NSViewLayerContentsPlacementBottom,
    9 => NSViewLayerContentsPlacementBottomLeft,
    10 => NSViewLayerContentsPlacementLeft,
    11 => NSViewLayerContentsPlacementTopLeft,
    _ => throw ArgumentError('Unknown value for NSViewLayerContentsPlacement: $value'),
  };
}

enum NSTextAlignment {
  NSTextAlignmentLeft(0),
  NSTextAlignmentCenter(1),
  NSTextAlignmentRight(2),
  NSTextAlignmentJustified(3),
  NSTextAlignmentNatural(4);

  final int value;
  const NSTextAlignment(this.value);

  static NSTextAlignment fromValue(int value) => switch (value) {
    0 => NSTextAlignmentLeft,
    1 => NSTextAlignmentCenter,
    2 => NSTextAlignmentRight,
    3 => NSTextAlignmentJustified,
    4 => NSTextAlignmentNatural,
    _ => throw ArgumentError('Unknown value for NSTextAlignment: $value'),
  };
}

enum NSLineBreakMode {
  NSLineBreakByWordWrapping(0),
  NSLineBreakByCharWrapping(1),
  NSLineBreakByClipping(2),
  NSLineBreakByTruncatingHead(3),
  NSLineBreakByTruncatingTail(4),
  NSLineBreakByTruncatingMiddle(5);

  final int value;
  const NSLineBreakMode(this.value);

  static NSLineBreakMode fromValue(int value) => switch (value) {
    0 => NSLineBreakByWordWrapping,
    1 => NSLineBreakByCharWrapping,
    2 => NSLineBreakByClipping,
    3 => NSLineBreakByTruncatingHead,
    4 => NSLineBreakByTruncatingTail,
    5 => NSLineBreakByTruncatingMiddle,
    _ => throw ArgumentError('Unknown value for NSLineBreakMode: $value'),
  };
}

enum NSLineBreakStrategy {
  NSLineBreakStrategyNone(0),
  NSLineBreakStrategyPushOut(1),
  NSLineBreakStrategyHangulWordPriority(2),
  NSLineBreakStrategyStandard(65535);

  final int value;
  const NSLineBreakStrategy(this.value);

  static NSLineBreakStrategy fromValue(int value) => switch (value) {
    0 => NSLineBreakStrategyNone,
    1 => NSLineBreakStrategyPushOut,
    2 => NSLineBreakStrategyHangulWordPriority,
    65535 => NSLineBreakStrategyStandard,
    _ => throw ArgumentError('Unknown value for NSLineBreakStrategy: $value'),
  };
}

enum UIBaselineAdjustment {
  UIBaselineAdjustmentAlignBaselines(0),
  UIBaselineAdjustmentAlignCenters(1),
  UIBaselineAdjustmentNone(2);

  final int value;
  const UIBaselineAdjustment(this.value);

  static UIBaselineAdjustment fromValue(int value) => switch (value) {
    0 => UIBaselineAdjustmentAlignBaselines,
    1 => UIBaselineAdjustmentAlignCenters,
    2 => UIBaselineAdjustmentNone,
    _ => throw ArgumentError('Unknown value for UIBaselineAdjustment: $value'),
  };
}

enum UITextAutocapitalizationType {
  UITextAutocapitalizationTypeNone(0),
  UITextAutocapitalizationTypeWords(1),
  UITextAutocapitalizationTypeSentences(2),
  UITextAutocapitalizationTypeAllCharacters(3);

  final int value;
  const UITextAutocapitalizationType(this.value);

  static UITextAutocapitalizationType fromValue(int value) => switch (value) {
    0 => UITextAutocapitalizationTypeNone,
    1 => UITextAutocapitalizationTypeWords,
    2 => UITextAutocapitalizationTypeSentences,
    3 => UITextAutocapitalizationTypeAllCharacters,
    _ => throw ArgumentError('Unknown value for UITextAutocapitalizationType: $value'),
  };
}

enum UITextAutocorrectionType {
  UITextAutocorrectionTypeDefault(0),
  UITextAutocorrectionTypeNo(1),
  UITextAutocorrectionTypeYes(2);

  final int value;
  const UITextAutocorrectionType(this.value);

  static UITextAutocorrectionType fromValue(int value) => switch (value) {
    0 => UITextAutocorrectionTypeDefault,
    1 => UITextAutocorrectionTypeNo,
    2 => UITextAutocorrectionTypeYes,
    _ => throw ArgumentError('Unknown value for UITextAutocorrectionType: $value'),
  };
}

enum UITextSpellCheckingType {
  UITextSpellCheckingTypeDefault(0),
  UITextSpellCheckingTypeNo(1),
  UITextSpellCheckingTypeYes(2);

  final int value;
  const UITextSpellCheckingType(this.value);

  static UITextSpellCheckingType fromValue(int value) => switch (value) {
    0 => UITextSpellCheckingTypeDefault,
    1 => UITextSpellCheckingTypeNo,
    2 => UITextSpellCheckingTypeYes,
    _ => throw ArgumentError('Unknown value for UITextSpellCheckingType: $value'),
  };
}

enum UITextSmartQuotesType {
  UITextSmartQuotesTypeDefault(0),
  UITextSmartQuotesTypeNo(1),
  UITextSmartQuotesTypeYes(2);

  final int value;
  const UITextSmartQuotesType(this.value);

  static UITextSmartQuotesType fromValue(int value) => switch (value) {
    0 => UITextSmartQuotesTypeDefault,
    1 => UITextSmartQuotesTypeNo,
    2 => UITextSmartQuotesTypeYes,
    _ => throw ArgumentError('Unknown value for UITextSmartQuotesType: $value'),
  };
}

enum UITextSmartDashesType {
  UITextSmartDashesTypeDefault(0),
  UITextSmartDashesTypeNo(1),
  UITextSmartDashesTypeYes(2);

  final int value;
  const UITextSmartDashesType(this.value);

  static UITextSmartDashesType fromValue(int value) => switch (value) {
    0 => UITextSmartDashesTypeDefault,
    1 => UITextSmartDashesTypeNo,
    2 => UITextSmartDashesTypeYes,
    _ => throw ArgumentError('Unknown value for UITextSmartDashesType: $value'),
  };
}

enum UITextSmartInsertDeleteType {
  UITextSmartInsertDeleteTypeDefault(0),
  UITextSmartInsertDeleteTypeNo(1),
  UITextSmartInsertDeleteTypeYes(2);

  final int value;
  const UITextSmartInsertDeleteType(this.value);

  static UITextSmartInsertDeleteType fromValue(int value) => switch (value) {
    0 => UITextSmartInsertDeleteTypeDefault,
    1 => UITextSmartInsertDeleteTypeNo,
    2 => UITextSmartInsertDeleteTypeYes,
    _ => throw ArgumentError('Unknown value for UITextSmartInsertDeleteType: $value'),
  };
}

enum UIKeyboardType {
  UIKeyboardTypeDefault(0),
  UIKeyboardTypeASCIICapable(1),
  UIKeyboardTypeNumbersAndPunctuation(2),
  UIKeyboardTypeURL(3),
  UIKeyboardTypeNumberPad(4),
  UIKeyboardTypePhonePad(5),
  UIKeyboardTypeNamePhonePad(6),
  UIKeyboardTypeEmailAddress(7),
  UIKeyboardTypeDecimalPad(8),
  UIKeyboardTypeTwitter(9),
  UIKeyboardTypeWebSearch(10),
  UIKeyboardTypeASCIICapableNumberPad(11);

  static const UIKeyboardTypeAlphabet = UIKeyboardTypeASCIICapable;

  final int value;
  const UIKeyboardType(this.value);

  static UIKeyboardType fromValue(int value) => switch (value) {
    0 => UIKeyboardTypeDefault,
    1 => UIKeyboardTypeASCIICapable,
    2 => UIKeyboardTypeNumbersAndPunctuation,
    3 => UIKeyboardTypeURL,
    4 => UIKeyboardTypeNumberPad,
    5 => UIKeyboardTypePhonePad,
    6 => UIKeyboardTypeNamePhonePad,
    7 => UIKeyboardTypeEmailAddress,
    8 => UIKeyboardTypeDecimalPad,
    9 => UIKeyboardTypeTwitter,
    10 => UIKeyboardTypeWebSearch,
    11 => UIKeyboardTypeASCIICapableNumberPad,
    _ => throw ArgumentError('Unknown value for UIKeyboardType: $value'),
  };

  @override
  String toString() {
    if (this == UIKeyboardTypeASCIICapable)
      return "UIKeyboardType.UIKeyboardTypeASCIICapable, UIKeyboardType.UIKeyboardTypeAlphabet";
    return super.toString();
  }
}

enum UIKeyboardAppearance {
  UIKeyboardAppearanceDefault(0),
  UIKeyboardAppearanceDark(1),
  UIKeyboardAppearanceLight(2);

  static const UIKeyboardAppearanceAlert = UIKeyboardAppearanceDark;

  final int value;
  const UIKeyboardAppearance(this.value);

  static UIKeyboardAppearance fromValue(int value) => switch (value) {
    0 => UIKeyboardAppearanceDefault,
    1 => UIKeyboardAppearanceDark,
    2 => UIKeyboardAppearanceLight,
    _ => throw ArgumentError('Unknown value for UIKeyboardAppearance: $value'),
  };

  @override
  String toString() {
    if (this == UIKeyboardAppearanceDark)
      return "UIKeyboardAppearance.UIKeyboardAppearanceDark, UIKeyboardAppearance.UIKeyboardAppearanceAlert";
    return super.toString();
  }
}

enum UIReturnKeyType {
  UIReturnKeyDefault(0),
  UIReturnKeyGo(1),
  UIReturnKeyGoogle(2),
  UIReturnKeyJoin(3),
  UIReturnKeyNext(4),
  UIReturnKeyRoute(5),
  UIReturnKeySearch(6),
  UIReturnKeySend(7),
  UIReturnKeyYahoo(8),
  UIReturnKeyDone(9),
  UIReturnKeyEmergencyCall(10),
  UIReturnKeyContinue(11);

  final int value;
  const UIReturnKeyType(this.value);

  static UIReturnKeyType fromValue(int value) => switch (value) {
    0 => UIReturnKeyDefault,
    1 => UIReturnKeyGo,
    2 => UIReturnKeyGoogle,
    3 => UIReturnKeyJoin,
    4 => UIReturnKeyNext,
    5 => UIReturnKeyRoute,
    6 => UIReturnKeySearch,
    7 => UIReturnKeySend,
    8 => UIReturnKeyYahoo,
    9 => UIReturnKeyDone,
    10 => UIReturnKeyEmergencyCall,
    11 => UIReturnKeyContinue,
    _ => throw ArgumentError('Unknown value for UIReturnKeyType: $value'),
  };
}

/// WARNING: UITextInputTraits is a stub. To generate bindings for this class, include
/// UITextInputTraits in your config's objc-protocols list.
///
/// UITextInputTraits
interface class UITextInputTraits extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UITextInputTraits._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UITextInputTraits] that points to the same underlying object as [other].
  UITextInputTraits.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITextInputTraits] that wraps the given raw object pointer.
  UITextInputTraits.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: UIKeyInput is a stub. To generate bindings for this class, include
/// UIKeyInput in your config's objc-protocols list.
///
/// UIKeyInput
interface class UIKeyInput extends objc.ObjCProtocolBase implements UITextInputTraits {
  UIKeyInput._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIKeyInput] that points to the same underlying object as [other].
  UIKeyInput.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIKeyInput] that wraps the given raw object pointer.
  UIKeyInput.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

enum UITextStorageDirection {
  UITextStorageDirectionForward(0),
  UITextStorageDirectionBackward(1);

  final int value;
  const UITextStorageDirection(this.value);

  static UITextStorageDirection fromValue(int value) => switch (value) {
    0 => UITextStorageDirectionForward,
    1 => UITextStorageDirectionBackward,
    _ => throw ArgumentError('Unknown value for UITextStorageDirection: $value'),
  };
}

enum UITextLayoutDirection {
  UITextLayoutDirectionRight(2),
  UITextLayoutDirectionLeft(3),
  UITextLayoutDirectionUp(4),
  UITextLayoutDirectionDown(5);

  final int value;
  const UITextLayoutDirection(this.value);

  static UITextLayoutDirection fromValue(int value) => switch (value) {
    2 => UITextLayoutDirectionRight,
    3 => UITextLayoutDirectionLeft,
    4 => UITextLayoutDirectionUp,
    5 => UITextLayoutDirectionDown,
    _ => throw ArgumentError('Unknown value for UITextLayoutDirection: $value'),
  };
}

enum UITextGranularity {
  UITextGranularityCharacter(0),
  UITextGranularityWord(1),
  UITextGranularitySentence(2),
  UITextGranularityParagraph(3),
  UITextGranularityLine(4),
  UITextGranularityDocument(5);

  final int value;
  const UITextGranularity(this.value);

  static UITextGranularity fromValue(int value) => switch (value) {
    0 => UITextGranularityCharacter,
    1 => UITextGranularityWord,
    2 => UITextGranularitySentence,
    3 => UITextGranularityParagraph,
    4 => UITextGranularityLine,
    5 => UITextGranularityDocument,
    _ => throw ArgumentError('Unknown value for UITextGranularity: $value'),
  };
}

enum UITextAlternativeStyle {
  UITextAlternativeStyleNone(0),
  UITextAlternativeStyleLowConfidence(1);

  final int value;
  const UITextAlternativeStyle(this.value);

  static UITextAlternativeStyle fromValue(int value) => switch (value) {
    0 => UITextAlternativeStyleNone,
    1 => UITextAlternativeStyleLowConfidence,
    _ => throw ArgumentError('Unknown value for UITextAlternativeStyle: $value'),
  };
}

/// WARNING: UITextInput is a stub. To generate bindings for this class, include
/// UITextInput in your config's objc-protocols list.
///
/// UITextInput
interface class UITextInput extends objc.ObjCProtocolBase implements UIKeyInput {
  UITextInput._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UITextInput] that points to the same underlying object as [other].
  UITextInput.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITextInput] that wraps the given raw object pointer.
  UITextInput.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: UIContentSizeCategoryAdjusting is a stub. To generate bindings for this class, include
/// UIContentSizeCategoryAdjusting in your config's objc-protocols list.
///
/// UIContentSizeCategoryAdjusting
interface class UIContentSizeCategoryAdjusting extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIContentSizeCategoryAdjusting._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIContentSizeCategoryAdjusting] that points to the same underlying object as [other].
  UIContentSizeCategoryAdjusting.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIContentSizeCategoryAdjusting] that wraps the given raw object pointer.
  UIContentSizeCategoryAdjusting.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

enum UITextBorderStyle {
  UITextBorderStyleNone(0),
  UITextBorderStyleLine(1),
  UITextBorderStyleBezel(2),
  UITextBorderStyleRoundedRect(3);

  final int value;
  const UITextBorderStyle(this.value);

  static UITextBorderStyle fromValue(int value) => switch (value) {
    0 => UITextBorderStyleNone,
    1 => UITextBorderStyleLine,
    2 => UITextBorderStyleBezel,
    3 => UITextBorderStyleRoundedRect,
    _ => throw ArgumentError('Unknown value for UITextBorderStyle: $value'),
  };
}

enum UITextFieldViewMode {
  UITextFieldViewModeNever(0),
  UITextFieldViewModeWhileEditing(1),
  UITextFieldViewModeUnlessEditing(2),
  UITextFieldViewModeAlways(3);

  final int value;
  const UITextFieldViewMode(this.value);

  static UITextFieldViewMode fromValue(int value) => switch (value) {
    0 => UITextFieldViewModeNever,
    1 => UITextFieldViewModeWhileEditing,
    2 => UITextFieldViewModeUnlessEditing,
    3 => UITextFieldViewModeAlways,
    _ => throw ArgumentError('Unknown value for UITextFieldViewMode: $value'),
  };
}

enum UITextFieldDidEndEditingReason {
  UITextFieldDidEndEditingReasonCommitted(0),
  UITextFieldDidEndEditingReasonCancelled(1);

  final int value;
  const UITextFieldDidEndEditingReason(this.value);

  static UITextFieldDidEndEditingReason fromValue(int value) => switch (value) {
    0 => UITextFieldDidEndEditingReasonCommitted,
    1 => UITextFieldDidEndEditingReasonCancelled,
    _ => throw ArgumentError('Unknown value for UITextFieldDidEndEditingReason: $value'),
  };
}

/// WARNING: UITextField$1 is a stub. To generate bindings for this class, include
/// UITextField in your config's objc-interfaces list.
///
/// UITextField
class UITextField$1 extends UIControl implements UITextInput, objc.NSCoding, UIContentSizeCategoryAdjusting {
  UITextField$1._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITextField', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UITextField$1] that points to the same underlying object as [other].
  UITextField$1.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITextField$1] that wraps the given raw object pointer.
  UITextField$1.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

enum UIRemoteNotificationType {
  UIRemoteNotificationTypeNone(0),
  UIRemoteNotificationTypeBadge(1),
  UIRemoteNotificationTypeSound(2),
  UIRemoteNotificationTypeAlert(4),
  UIRemoteNotificationTypeNewsstandContentAvailability(8);

  final int value;
  const UIRemoteNotificationType(this.value);

  static UIRemoteNotificationType fromValue(int value) => switch (value) {
    0 => UIRemoteNotificationTypeNone,
    1 => UIRemoteNotificationTypeBadge,
    2 => UIRemoteNotificationTypeSound,
    4 => UIRemoteNotificationTypeAlert,
    8 => UIRemoteNotificationTypeNewsstandContentAvailability,
    _ => throw ArgumentError('Unknown value for UIRemoteNotificationType: $value'),
  };
}

enum UIBackgroundFetchResult {
  UIBackgroundFetchResultNewData(0),
  UIBackgroundFetchResultNoData(1),
  UIBackgroundFetchResultFailed(2);

  final int value;
  const UIBackgroundFetchResult(this.value);

  static UIBackgroundFetchResult fromValue(int value) => switch (value) {
    0 => UIBackgroundFetchResultNewData,
    1 => UIBackgroundFetchResultNoData,
    2 => UIBackgroundFetchResultFailed,
    _ => throw ArgumentError('Unknown value for UIBackgroundFetchResult: $value'),
  };
}

enum UIBackgroundRefreshStatus {
  UIBackgroundRefreshStatusRestricted(0),
  UIBackgroundRefreshStatusDenied(1),
  UIBackgroundRefreshStatusAvailable(2);

  final int value;
  const UIBackgroundRefreshStatus(this.value);

  static UIBackgroundRefreshStatus fromValue(int value) => switch (value) {
    0 => UIBackgroundRefreshStatusRestricted,
    1 => UIBackgroundRefreshStatusDenied,
    2 => UIBackgroundRefreshStatusAvailable,
    _ => throw ArgumentError('Unknown value for UIBackgroundRefreshStatus: $value'),
  };
}

enum UIApplicationState {
  UIApplicationStateActive(0),
  UIApplicationStateInactive(1),
  UIApplicationStateBackground(2);

  final int value;
  const UIApplicationState(this.value);

  static UIApplicationState fromValue(int value) => switch (value) {
    0 => UIApplicationStateActive,
    1 => UIApplicationStateInactive,
    2 => UIApplicationStateBackground,
    _ => throw ArgumentError('Unknown value for UIApplicationState: $value'),
  };
}

late final _class_UIApplication = objc.getClass("UIApplication");
late final _sel_registerForRemoteNotifications = objc.registerName("registerForRemoteNotifications");
late final _sel_unregisterForRemoteNotifications = objc.registerName("unregisterForRemoteNotifications");
late final _sel_isRegisteredForRemoteNotifications = objc.registerName("isRegisteredForRemoteNotifications");
late final _sel_registerForRemoteNotificationTypes_ = objc.registerName("registerForRemoteNotificationTypes:");
final _objc_msgSend_46qpcw = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_enabledRemoteNotificationTypes = objc.registerName("enabledRemoteNotificationTypes");
final _objc_msgSend_z1zqgm = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// UIRemoteNotifications
extension UIRemoteNotifications on UIApplication {
  /// registerForRemoteNotifications
  void registerForRemoteNotifications() {
    objc.checkOsVersionInternal('UIApplication.registerForRemoteNotifications', iOS: (false, (8, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_registerForRemoteNotifications);
  }

  /// unregisterForRemoteNotifications
  void unregisterForRemoteNotifications() {
    objc.checkOsVersionInternal('UIApplication.unregisterForRemoteNotifications', iOS: (false, (3, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_unregisterForRemoteNotifications);
  }

  /// isRegisteredForRemoteNotifications
  bool get registeredForRemoteNotifications {
    objc.checkOsVersionInternal('UIApplication.isRegisteredForRemoteNotifications', iOS: (false, (8, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isRegisteredForRemoteNotifications);
  }

  /// registerForRemoteNotificationTypes:
  void registerForRemoteNotificationTypes(UIRemoteNotificationType types) {
    objc.checkOsVersionInternal('UIApplication.registerForRemoteNotificationTypes:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_46qpcw(this.ref.pointer, _sel_registerForRemoteNotificationTypes_, types.value);
  }

  /// enabledRemoteNotificationTypes
  UIRemoteNotificationType enabledRemoteNotificationTypes() {
    objc.checkOsVersionInternal('UIApplication.enabledRemoteNotificationTypes', iOS: (false, (3, 0, 0)));
    final _ret = _objc_msgSend_z1zqgm(this.ref.pointer, _sel_enabledRemoteNotificationTypes);
    return UIRemoteNotificationType.fromValue(_ret);
  }
}

/// WARNING: UILocalNotification is a stub. To generate bindings for this class, include
/// UILocalNotification in your config's objc-interfaces list.
///
/// UILocalNotification
class UILocalNotification extends objc.ObjCObjectBase {
  UILocalNotification._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UILocalNotification] that points to the same underlying object as [other].
  UILocalNotification.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UILocalNotification] that wraps the given raw object pointer.
  UILocalNotification.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_presentLocalNotificationNow_ = objc.registerName("presentLocalNotificationNow:");
late final _sel_scheduleLocalNotification_ = objc.registerName("scheduleLocalNotification:");
late final _sel_cancelLocalNotification_ = objc.registerName("cancelLocalNotification:");
late final _sel_cancelAllLocalNotifications = objc.registerName("cancelAllLocalNotifications");
late final _sel_scheduledLocalNotifications = objc.registerName("scheduledLocalNotifications");
late final _sel_setScheduledLocalNotifications_ = objc.registerName("setScheduledLocalNotifications:");

/// UILocalNotifications
extension UILocalNotifications on UIApplication {
  /// presentLocalNotificationNow:
  void presentLocalNotificationNow(UILocalNotification notification) {
    objc.checkOsVersionInternal('UIApplication.presentLocalNotificationNow:', iOS: (false, (4, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_presentLocalNotificationNow_, notification.ref.pointer);
  }

  /// scheduleLocalNotification:
  void scheduleLocalNotification(UILocalNotification notification) {
    objc.checkOsVersionInternal('UIApplication.scheduleLocalNotification:', iOS: (false, (4, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_scheduleLocalNotification_, notification.ref.pointer);
  }

  /// cancelLocalNotification:
  void cancelLocalNotification(UILocalNotification notification) {
    objc.checkOsVersionInternal('UIApplication.cancelLocalNotification:', iOS: (false, (4, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_cancelLocalNotification_, notification.ref.pointer);
  }

  /// cancelAllLocalNotifications
  void cancelAllLocalNotifications() {
    objc.checkOsVersionInternal('UIApplication.cancelAllLocalNotifications', iOS: (false, (4, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_cancelAllLocalNotifications);
  }

  /// scheduledLocalNotifications
  objc.NSArray? get scheduledLocalNotifications {
    objc.checkOsVersionInternal('UIApplication.scheduledLocalNotifications', iOS: (false, (4, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_scheduledLocalNotifications);
    return _ret.address == 0 ? null : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// setScheduledLocalNotifications:
  set scheduledLocalNotifications(objc.NSArray? value) {
    objc.checkOsVersionInternal('UIApplication.setScheduledLocalNotifications:', iOS: (false, (4, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setScheduledLocalNotifications_, value?.ref.pointer ?? ffi.nullptr);
  }
}

/// WARNING: UIUserNotificationSettings is a stub. To generate bindings for this class, include
/// UIUserNotificationSettings in your config's objc-interfaces list.
///
/// UIUserNotificationSettings
class UIUserNotificationSettings extends objc.ObjCObjectBase {
  UIUserNotificationSettings._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIUserNotificationSettings] that points to the same underlying object as [other].
  UIUserNotificationSettings.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIUserNotificationSettings] that wraps the given raw object pointer.
  UIUserNotificationSettings.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_registerUserNotificationSettings_ = objc.registerName("registerUserNotificationSettings:");
late final _sel_currentUserNotificationSettings = objc.registerName("currentUserNotificationSettings");

/// UIUserNotificationSettings
extension UIUserNotificationSettings$1 on UIApplication {
  /// registerUserNotificationSettings:
  void registerUserNotificationSettings(UIUserNotificationSettings notificationSettings) {
    objc.checkOsVersionInternal('UIApplication.registerUserNotificationSettings:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_registerUserNotificationSettings_, notificationSettings.ref.pointer);
  }

  /// currentUserNotificationSettings
  UIUserNotificationSettings? get currentUserNotificationSettings {
    objc.checkOsVersionInternal('UIApplication.currentUserNotificationSettings', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_currentUserNotificationSettings);
    return _ret.address == 0 ? null : UIUserNotificationSettings.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_beginReceivingRemoteControlEvents = objc.registerName("beginReceivingRemoteControlEvents");
late final _sel_endReceivingRemoteControlEvents = objc.registerName("endReceivingRemoteControlEvents");

/// UIRemoteControlEvents
extension UIRemoteControlEvents on UIApplication {
  /// beginReceivingRemoteControlEvents
  void beginReceivingRemoteControlEvents() {
    objc.checkOsVersionInternal('UIApplication.beginReceivingRemoteControlEvents', iOS: (false, (4, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_beginReceivingRemoteControlEvents);
  }

  /// endReceivingRemoteControlEvents
  void endReceivingRemoteControlEvents() {
    objc.checkOsVersionInternal('UIApplication.endReceivingRemoteControlEvents', iOS: (false, (4, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_endReceivingRemoteControlEvents);
  }
}

late final _sel_setNewsstandIconImage_ = objc.registerName("setNewsstandIconImage:");

/// UINewsstand
extension UINewsstand on UIApplication {
  /// setNewsstandIconImage:
  void setNewsstandIconImage(UIImage? image) {
    objc.checkOsVersionInternal('UIApplication.setNewsstandIconImage:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setNewsstandIconImage_, image?.ref.pointer ?? ffi.nullptr);
  }
}

late final _sel_shortcutItems = objc.registerName("shortcutItems");
late final _sel_setShortcutItems_ = objc.registerName("setShortcutItems:");

/// UIShortcutItems
extension UIShortcutItems on UIApplication {
  /// shortcutItems
  objc.NSArray? get shortcutItems {
    objc.checkOsVersionInternal('UIApplication.shortcutItems', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_shortcutItems);
    return _ret.address == 0 ? null : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// setShortcutItems:
  set shortcutItems(objc.NSArray? value) {
    objc.checkOsVersionInternal('UIApplication.setShortcutItems:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setShortcutItems_, value?.ref.pointer ?? ffi.nullptr);
  }
}

late final _sel_supportsAlternateIcons = objc.registerName("supportsAlternateIcons");
void _ObjCBlock_ffiVoid_NSError_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>(
      _ObjCBlock_ffiVoid_NSError_fnPtrTrampoline,
    ).cast();
void _ObjCBlock_ffiVoid_NSError_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSError_closureCallable =
    ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>(
      _ObjCBlock_ffiVoid_NSError_closureTrampoline,
    ).cast();
void _ObjCBlock_ffiVoid_NSError_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
_ObjCBlock_ffiVoid_NSError_listenerCallable =
    ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>.listener(
      _ObjCBlock_ffiVoid_NSError_listenerTrampoline,
    )..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSError_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<objc.ObjCObject> arg0,
) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
>
_ObjCBlock_ffiVoid_NSError_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >.isolateLocal(_ObjCBlock_ffiVoid_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
>
_ObjCBlock_ffiVoid_NSError_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >.listener(_ObjCBlock_ffiVoid_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
    objc.newPointerBlock(_ObjCBlock_ffiVoid_NSError_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromFunction(
    void Function(objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
    objc.newClosureBlock(
      _ObjCBlock_ffiVoid_NSError_closureCallable,
      (ffi.Pointer<objc.ObjCObject> arg0) =>
          fn(arg0.address == 0 ? null : objc.NSError.castFromPointer(arg0, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> listener(
    void Function(objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_NSError_listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) =>
          fn(arg0.address == 0 ? null : objc.NSError.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> blocking(
    void Function(objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_NSError_blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) =>
          fn(arg0.address == 0 ? null : objc.NSError.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_NSError_blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) =>
          fn(arg0.address == 0 ? null : objc.NSError.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_xtuoz7(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSError_CallExtension on objc.ObjCBlock<ffi.Void Function(objc.NSError?)> {
  void call(objc.NSError? arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0)>
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_setAlternateIconName_completionHandler_ = objc.registerName("setAlternateIconName:completionHandler:");
final _objc_msgSend_o762yo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_alternateIconName = objc.registerName("alternateIconName");

/// UIAlternateApplicationIcons
extension UIAlternateApplicationIcons on UIApplication {
  /// supportsAlternateIcons
  bool get supportsAlternateIcons {
    objc.checkOsVersionInternal('UIApplication.supportsAlternateIcons', iOS: (false, (10, 3, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_supportsAlternateIcons);
  }

  /// setAlternateIconName:completionHandler:
  void setAlternateIconName(
    objc.NSString? alternateIconName, {
    objc.ObjCBlock<ffi.Void Function(objc.NSError?)>? completionHandler,
  }) {
    objc.checkOsVersionInternal('UIApplication.setAlternateIconName:completionHandler:', iOS: (false, (10, 3, 0)));
    _objc_msgSend_o762yo(
      this.ref.pointer,
      _sel_setAlternateIconName_completionHandler_,
      alternateIconName?.ref.pointer ?? ffi.nullptr,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// alternateIconName
  objc.NSString? get alternateIconName {
    objc.checkOsVersionInternal('UIApplication.alternateIconName', iOS: (false, (10, 3, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_alternateIconName);
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_extendStateRestoration = objc.registerName("extendStateRestoration");
late final _sel_completeStateRestoration = objc.registerName("completeStateRestoration");
late final _sel_ignoreSnapshotOnNextApplicationLaunch = objc.registerName("ignoreSnapshotOnNextApplicationLaunch");
late final _sel_registerObjectForStateRestoration_restorationIdentifier_ = objc.registerName(
  "registerObjectForStateRestoration:restorationIdentifier:",
);

/// UIStateRestoration
extension UIStateRestoration$2 on UIApplication {
  /// extendStateRestoration
  void extendStateRestoration() {
    objc.checkOsVersionInternal('UIApplication.extendStateRestoration', iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_extendStateRestoration);
  }

  /// completeStateRestoration
  void completeStateRestoration() {
    objc.checkOsVersionInternal('UIApplication.completeStateRestoration', iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_completeStateRestoration);
  }

  /// ignoreSnapshotOnNextApplicationLaunch
  void ignoreSnapshotOnNextApplicationLaunch() {
    objc.checkOsVersionInternal('UIApplication.ignoreSnapshotOnNextApplicationLaunch', iOS: (false, (7, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_ignoreSnapshotOnNextApplicationLaunch);
  }

  /// registerObjectForStateRestoration:restorationIdentifier:
  static void registerObjectForStateRestoration(
    UIStateRestoring object, {
    required objc.NSString restorationIdentifier,
  }) {
    objc.checkOsVersionInternal(
      'UIApplication.registerObjectForStateRestoration:restorationIdentifier:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      _class_UIApplication,
      _sel_registerObjectForStateRestoration_restorationIdentifier_,
      object.ref.pointer,
      restorationIdentifier.ref.pointer,
    );
  }
}

late final _sel_isProximitySensingEnabled = objc.registerName("isProximitySensingEnabled");
late final _sel_setProximitySensingEnabled_ = objc.registerName("setProximitySensingEnabled:");
late final _sel_setStatusBarHidden_animated_ = objc.registerName("setStatusBarHidden:animated:");
late final _sel_statusBarOrientation = objc.registerName("statusBarOrientation");
late final _sel_setStatusBarOrientation_ = objc.registerName("setStatusBarOrientation:");
late final _sel_setStatusBarOrientation_animated_ = objc.registerName("setStatusBarOrientation:animated:");
final _objc_msgSend_anbnk2 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long, ffi.Bool)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int, bool)>();
late final _sel_statusBarStyle = objc.registerName("statusBarStyle");
late final _sel_setStatusBarStyle_ = objc.registerName("setStatusBarStyle:");
final _objc_msgSend_k8qzn7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setStatusBarStyle_animated_ = objc.registerName("setStatusBarStyle:animated:");
final _objc_msgSend_qpqgi7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long, ffi.Bool)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int, bool)>();
late final _sel_isStatusBarHidden = objc.registerName("isStatusBarHidden");
late final _sel_setStatusBarHidden_ = objc.registerName("setStatusBarHidden:");
late final _sel_setStatusBarHidden_withAnimation_ = objc.registerName("setStatusBarHidden:withAnimation:");
final _objc_msgSend_1huazme = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Bool, ffi.Long)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, bool, int)>();
late final _sel_setKeepAliveTimeout_handler_ = objc.registerName("setKeepAliveTimeout:handler:");
final _objc_msgSend_170zngv = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_clearKeepAliveTimeout = objc.registerName("clearKeepAliveTimeout");

/// UIApplicationDeprecated
extension UIApplicationDeprecated on UIApplication {
  /// isProximitySensingEnabled
  bool get proximitySensingEnabled {
    objc.checkOsVersionInternal('UIApplication.isProximitySensingEnabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isProximitySensingEnabled);
  }

  /// setProximitySensingEnabled:
  set proximitySensingEnabled(bool value) {
    objc.checkOsVersionInternal('UIApplication.setProximitySensingEnabled:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setProximitySensingEnabled_, value);
  }

  /// setStatusBarHidden:animated:
  void setStatusBarHidden(bool hidden, {required bool animated}) {
    objc.checkOsVersionInternal('UIApplication.setStatusBarHidden:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_14iqu8t(this.ref.pointer, _sel_setStatusBarHidden_animated_, hidden, animated);
  }

  /// statusBarOrientation
  UIInterfaceOrientation get statusBarOrientation {
    objc.checkOsVersionInternal('UIApplication.statusBarOrientation', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_14s25dk(this.ref.pointer, _sel_statusBarOrientation);
    return UIInterfaceOrientation.fromValue(_ret);
  }

  /// setStatusBarOrientation:
  set statusBarOrientation(UIInterfaceOrientation value) {
    objc.checkOsVersionInternal('UIApplication.setStatusBarOrientation:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_13bsfjm(this.ref.pointer, _sel_setStatusBarOrientation_, value.value);
  }

  /// setStatusBarOrientation:animated:
  void setStatusBarOrientation(UIInterfaceOrientation interfaceOrientation, {required bool animated}) {
    objc.checkOsVersionInternal('UIApplication.setStatusBarOrientation:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_anbnk2(
      this.ref.pointer,
      _sel_setStatusBarOrientation_animated_,
      interfaceOrientation.value,
      animated,
    );
  }

  /// statusBarStyle
  UIStatusBarStyle get statusBarStyle {
    objc.checkOsVersionInternal('UIApplication.statusBarStyle', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_czyja3(this.ref.pointer, _sel_statusBarStyle);
    return UIStatusBarStyle.fromValue(_ret);
  }

  /// setStatusBarStyle:
  set statusBarStyle(UIStatusBarStyle value) {
    objc.checkOsVersionInternal('UIApplication.setStatusBarStyle:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_k8qzn7(this.ref.pointer, _sel_setStatusBarStyle_, value.value);
  }

  /// setStatusBarStyle:animated:
  void setStatusBarStyle(UIStatusBarStyle statusBarStyle$1, {required bool animated}) {
    objc.checkOsVersionInternal('UIApplication.setStatusBarStyle:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_qpqgi7(this.ref.pointer, _sel_setStatusBarStyle_animated_, statusBarStyle$1.value, animated);
  }

  /// isStatusBarHidden
  bool get statusBarHidden {
    objc.checkOsVersionInternal('UIApplication.isStatusBarHidden', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isStatusBarHidden);
  }

  /// setStatusBarHidden:
  set statusBarHidden(bool value) {
    objc.checkOsVersionInternal('UIApplication.setStatusBarHidden:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setStatusBarHidden_, value);
  }

  /// setStatusBarHidden:withAnimation:
  void setStatusBarHidden$1(bool hidden, {required UIStatusBarAnimation withAnimation}) {
    objc.checkOsVersionInternal('UIApplication.setStatusBarHidden:withAnimation:', iOS: (false, (3, 2, 0)));
    _objc_msgSend_1huazme(this.ref.pointer, _sel_setStatusBarHidden_withAnimation_, hidden, withAnimation.value);
  }

  /// setKeepAliveTimeout:handler:
  bool setKeepAliveTimeout(double timeout, {objc.ObjCBlock<ffi.Void Function()>? handler}) {
    objc.checkOsVersionInternal('UIApplication.setKeepAliveTimeout:handler:', iOS: (false, (4, 0, 0)));
    return _objc_msgSend_170zngv(
      this.ref.pointer,
      _sel_setKeepAliveTimeout_handler_,
      timeout,
      handler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// clearKeepAliveTimeout
  void clearKeepAliveTimeout() {
    objc.checkOsVersionInternal('UIApplication.clearKeepAliveTimeout', iOS: (false, (4, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_clearKeepAliveTimeout);
  }
}

late final _sel_sharedApplication = objc.registerName("sharedApplication");

/// WARNING: UIApplicationDelegate is a stub. To generate bindings for this class, include
/// UIApplicationDelegate in your config's objc-protocols list.
///
/// UIApplicationDelegate
interface class UIApplicationDelegate extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIApplicationDelegate._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIApplicationDelegate] that points to the same underlying object as [other].
  UIApplicationDelegate.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIApplicationDelegate] that wraps the given raw object pointer.
  UIApplicationDelegate.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_beginIgnoringInteractionEvents = objc.registerName("beginIgnoringInteractionEvents");
late final _sel_endIgnoringInteractionEvents = objc.registerName("endIgnoringInteractionEvents");
late final _sel_isIgnoringInteractionEvents = objc.registerName("isIgnoringInteractionEvents");
late final _sel_isIdleTimerDisabled = objc.registerName("isIdleTimerDisabled");
late final _sel_setIdleTimerDisabled_ = objc.registerName("setIdleTimerDisabled:");
late final _sel_openURL_ = objc.registerName("openURL:");
late final _sel_canOpenURL_ = objc.registerName("canOpenURL:");
late final _sel_openURL_options_completionHandler_ = objc.registerName("openURL:options:completionHandler:");
final _objc_msgSend_18qun1e = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_keyWindow = objc.registerName("keyWindow");
late final _sel_windows = objc.registerName("windows");
late final _sel_sendAction_to_from_forEvent_ = objc.registerName("sendAction:to:from:forEvent:");
final _objc_msgSend_175fj4e = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_isNetworkActivityIndicatorVisible = objc.registerName("isNetworkActivityIndicatorVisible");
late final _sel_setNetworkActivityIndicatorVisible_ = objc.registerName("setNetworkActivityIndicatorVisible:");
late final _sel_supportedInterfaceOrientationsForWindow_ = objc.registerName(
  "supportedInterfaceOrientationsForWindow:",
);
final _objc_msgSend_1369ey = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)
    >();
late final _sel_statusBarOrientationAnimationDuration = objc.registerName("statusBarOrientationAnimationDuration");
late final _sel_statusBarFrame = objc.registerName("statusBarFrame");
late final _sel_applicationIconBadgeNumber = objc.registerName("applicationIconBadgeNumber");
late final _sel_setApplicationIconBadgeNumber_ = objc.registerName("setApplicationIconBadgeNumber:");
late final _sel_applicationSupportsShakeToEdit = objc.registerName("applicationSupportsShakeToEdit");
late final _sel_setApplicationSupportsShakeToEdit_ = objc.registerName("setApplicationSupportsShakeToEdit:");
late final _sel_applicationState = objc.registerName("applicationState");
final _objc_msgSend_10g89zc = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_backgroundTimeRemaining = objc.registerName("backgroundTimeRemaining");
late final _sel_beginBackgroundTaskWithExpirationHandler_ = objc.registerName(
  "beginBackgroundTaskWithExpirationHandler:",
);
final _objc_msgSend_10mlopr = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCBlockImpl>)
    >();
late final _sel_beginBackgroundTaskWithName_expirationHandler_ = objc.registerName(
  "beginBackgroundTaskWithName:expirationHandler:",
);
final _objc_msgSend_jkkt9d = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_endBackgroundTask_ = objc.registerName("endBackgroundTask:");
final _objc_msgSend_1i9r4xy = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setMinimumBackgroundFetchInterval_ = objc.registerName("setMinimumBackgroundFetchInterval:");
late final _sel_backgroundRefreshStatus = objc.registerName("backgroundRefreshStatus");
final _objc_msgSend_1499xyo = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_isProtectedDataAvailable = objc.registerName("isProtectedDataAvailable");
late final _sel_userInterfaceLayoutDirection = objc.registerName("userInterfaceLayoutDirection");
late final _sel_preferredContentSizeCategory = objc.registerName("preferredContentSizeCategory");
late final _sel_connectedScenes = objc.registerName("connectedScenes");
late final _sel_openSessions = objc.registerName("openSessions");
late final _sel_supportsMultipleScenes = objc.registerName("supportsMultipleScenes");

/// WARNING: UISceneSession is a stub. To generate bindings for this class, include
/// UISceneSession in your config's objc-interfaces list.
///
/// UISceneSession
class UISceneSession extends objc.ObjCObjectBase {
  UISceneSession._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UISceneSession] that points to the same underlying object as [other].
  UISceneSession.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UISceneSession] that wraps the given raw object pointer.
  UISceneSession.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: UISceneActivationRequestOptions is a stub. To generate bindings for this class, include
/// UISceneActivationRequestOptions in your config's objc-interfaces list.
///
/// UISceneActivationRequestOptions
class UISceneActivationRequestOptions extends objc.NSObject {
  UISceneActivationRequestOptions._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UISceneActivationRequestOptions', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UISceneActivationRequestOptions] that points to the same underlying object as [other].
  UISceneActivationRequestOptions.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UISceneActivationRequestOptions] that wraps the given raw object pointer.
  UISceneActivationRequestOptions.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

void _ObjCBlock_ffiVoid_NSError$1_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSError$1_fnPtrCallable =
    ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>(
      _ObjCBlock_ffiVoid_NSError$1_fnPtrTrampoline,
    ).cast();
void _ObjCBlock_ffiVoid_NSError$1_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSError$1_closureCallable =
    ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>(
      _ObjCBlock_ffiVoid_NSError$1_closureTrampoline,
    ).cast();
void _ObjCBlock_ffiVoid_NSError$1_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
_ObjCBlock_ffiVoid_NSError$1_listenerCallable =
    ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>.listener(
      _ObjCBlock_ffiVoid_NSError$1_listenerTrampoline,
    )..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSError$1_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<objc.ObjCObject> arg0,
) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
>
_ObjCBlock_ffiVoid_NSError$1_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >.isolateLocal(_ObjCBlock_ffiVoid_NSError$1_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
>
_ObjCBlock_ffiVoid_NSError$1_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >.listener(_ObjCBlock_ffiVoid_NSError$1_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSError)>`.
abstract final class ObjCBlock_ffiVoid_NSError$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSError)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(objc.NSError)>(
    objc.newPointerBlock(_ObjCBlock_ffiVoid_NSError$1_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError)> fromFunction(
    void Function(objc.NSError) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSError)>(
    objc.newClosureBlock(
      _ObjCBlock_ffiVoid_NSError$1_closureCallable,
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(objc.NSError.castFromPointer(arg0, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError)> listener(
    void Function(objc.NSError) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_NSError$1_listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(objc.NSError.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError)> blocking(
    void Function(objc.NSError) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_NSError$1_blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(objc.NSError.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_NSError$1_blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(objc.NSError.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_xtuoz7(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSError)>`.
extension ObjCBlock_ffiVoid_NSError$1_CallExtension on objc.ObjCBlock<ffi.Void Function(objc.NSError)> {
  void call(objc.NSError arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0)>
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0.ref.pointer);
}

late final _sel_requestSceneSessionActivation_userActivity_options_errorHandler_ = objc.registerName(
  "requestSceneSessionActivation:userActivity:options:errorHandler:",
);
final _objc_msgSend_m7tls4 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// WARNING: UISceneDestructionRequestOptions is a stub. To generate bindings for this class, include
/// UISceneDestructionRequestOptions in your config's objc-interfaces list.
///
/// UISceneDestructionRequestOptions
class UISceneDestructionRequestOptions extends objc.NSObject {
  UISceneDestructionRequestOptions._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UISceneDestructionRequestOptions', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UISceneDestructionRequestOptions] that points to the same underlying object as [other].
  UISceneDestructionRequestOptions.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UISceneDestructionRequestOptions] that wraps the given raw object pointer.
  UISceneDestructionRequestOptions.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_requestSceneSessionDestruction_options_errorHandler_ = objc.registerName(
  "requestSceneSessionDestruction:options:errorHandler:",
);
late final _sel_requestSceneSessionRefresh_ = objc.registerName("requestSceneSessionRefresh:");

/// UIApplication
class UIApplication extends UIResponder {
  UIApplication._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIApplication', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIApplication] that points to the same underlying object as [other].
  UIApplication.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIApplication] that wraps the given raw object pointer.
  UIApplication.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIApplication].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIApplication);
  }

  /// sharedApplication
  static UIApplication getSharedApplication() {
    final _ret = _objc_msgSend_151sglz(_class_UIApplication, _sel_sharedApplication);
    return UIApplication.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static UIApplication new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIApplication, _sel_new);
    return UIApplication.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIApplication allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(_class_UIApplication, _sel_allocWithZone_, zone);
    return UIApplication.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UIApplication alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UIApplication, _sel_alloc);
    return UIApplication.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of UIApplication constructed with the default `new` method.
  factory UIApplication() => new$();
}

extension UIApplication$Methods on UIApplication {
  /// delegate
  UIApplicationDelegate? get delegate {
    objc.checkOsVersionInternal('UIApplication.delegate', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_delegate);
    return _ret.address == 0 ? null : UIApplicationDelegate.castFromPointer(_ret, retain: true, release: true);
  }

  /// setDelegate:
  set delegate(UIApplicationDelegate? value) {
    objc.checkOsVersionInternal('UIApplication.setDelegate:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setDelegate_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// beginIgnoringInteractionEvents
  void beginIgnoringInteractionEvents() {
    objc.checkOsVersionInternal('UIApplication.beginIgnoringInteractionEvents', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_beginIgnoringInteractionEvents);
  }

  /// endIgnoringInteractionEvents
  void endIgnoringInteractionEvents() {
    objc.checkOsVersionInternal('UIApplication.endIgnoringInteractionEvents', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_endIgnoringInteractionEvents);
  }

  /// isIgnoringInteractionEvents
  bool get ignoringInteractionEvents {
    objc.checkOsVersionInternal('UIApplication.isIgnoringInteractionEvents', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isIgnoringInteractionEvents);
  }

  /// isIdleTimerDisabled
  bool get idleTimerDisabled {
    objc.checkOsVersionInternal('UIApplication.isIdleTimerDisabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isIdleTimerDisabled);
  }

  /// setIdleTimerDisabled:
  set idleTimerDisabled(bool value) {
    objc.checkOsVersionInternal('UIApplication.setIdleTimerDisabled:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setIdleTimerDisabled_, value);
  }

  /// openURL:
  bool openURL(objc.NSURL url) {
    objc.checkOsVersionInternal('UIApplication.openURL:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_19nvye5(this.ref.pointer, _sel_openURL_, url.ref.pointer);
  }

  /// canOpenURL:
  bool canOpenURL(objc.NSURL url) {
    objc.checkOsVersionInternal('UIApplication.canOpenURL:', iOS: (false, (3, 0, 0)));
    return _objc_msgSend_19nvye5(this.ref.pointer, _sel_canOpenURL_, url.ref.pointer);
  }

  /// openURL:options:completionHandler:
  void openURL$1(
    objc.NSURL url, {
    required objc.NSDictionary options,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completionHandler,
  }) {
    objc.checkOsVersionInternal('UIApplication.openURL:options:completionHandler:', iOS: (false, (10, 0, 0)));
    _objc_msgSend_18qun1e(
      this.ref.pointer,
      _sel_openURL_options_completionHandler_,
      url.ref.pointer,
      options.ref.pointer,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// sendEvent:
  void sendEvent(UIEvent event) {
    objc.checkOsVersionInternal('UIApplication.sendEvent:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_sendEvent_, event.ref.pointer);
  }

  /// keyWindow
  UIWindow? get keyWindow {
    objc.checkOsVersionInternal('UIApplication.keyWindow', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_keyWindow);
    return _ret.address == 0 ? null : UIWindow.castFromPointer(_ret, retain: true, release: true);
  }

  /// windows
  objc.NSArray get windows {
    objc.checkOsVersionInternal('UIApplication.windows', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_windows);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// sendAction:to:from:forEvent:
  bool sendAction(
    ffi.Pointer<objc.ObjCSelector> action, {
    objc.ObjCObjectBase? to,
    objc.ObjCObjectBase? from,
    UIEvent? forEvent,
  }) {
    objc.checkOsVersionInternal('UIApplication.sendAction:to:from:forEvent:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_175fj4e(
      this.ref.pointer,
      _sel_sendAction_to_from_forEvent_,
      action,
      to?.ref.pointer ?? ffi.nullptr,
      from?.ref.pointer ?? ffi.nullptr,
      forEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// isNetworkActivityIndicatorVisible
  bool get networkActivityIndicatorVisible {
    objc.checkOsVersionInternal('UIApplication.isNetworkActivityIndicatorVisible', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isNetworkActivityIndicatorVisible);
  }

  /// setNetworkActivityIndicatorVisible:
  set networkActivityIndicatorVisible(bool value) {
    objc.checkOsVersionInternal('UIApplication.setNetworkActivityIndicatorVisible:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setNetworkActivityIndicatorVisible_, value);
  }

  /// statusBarStyle
  UIStatusBarStyle get statusBarStyle {
    objc.checkOsVersionInternal('UIApplication.statusBarStyle', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_czyja3(this.ref.pointer, _sel_statusBarStyle);
    return UIStatusBarStyle.fromValue(_ret);
  }

  /// isStatusBarHidden
  bool get statusBarHidden {
    objc.checkOsVersionInternal('UIApplication.isStatusBarHidden', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isStatusBarHidden);
  }

  /// statusBarOrientation
  UIInterfaceOrientation get statusBarOrientation {
    objc.checkOsVersionInternal('UIApplication.statusBarOrientation', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_14s25dk(this.ref.pointer, _sel_statusBarOrientation);
    return UIInterfaceOrientation.fromValue(_ret);
  }

  /// supportedInterfaceOrientationsForWindow:
  UIInterfaceOrientationMask supportedInterfaceOrientationsForWindow(UIWindow? window) {
    objc.checkOsVersionInternal('UIApplication.supportedInterfaceOrientationsForWindow:', iOS: (false, (6, 0, 0)));
    final _ret = _objc_msgSend_1369ey(
      this.ref.pointer,
      _sel_supportedInterfaceOrientationsForWindow_,
      window?.ref.pointer ?? ffi.nullptr,
    );
    return UIInterfaceOrientationMask.fromValue(_ret);
  }

  /// statusBarOrientationAnimationDuration
  double get statusBarOrientationAnimationDuration {
    objc.checkOsVersionInternal('UIApplication.statusBarOrientationAnimationDuration', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_statusBarOrientationAnimationDuration)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_statusBarOrientationAnimationDuration);
  }

  /// statusBarFrame
  objc.CGRect get statusBarFrame {
    objc.checkOsVersionInternal('UIApplication.statusBarFrame', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(_ptr, this.ref.pointer, _sel_statusBarFrame)
        : _ptr.ref = _objc_msgSend_bu1hbw(this.ref.pointer, _sel_statusBarFrame);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// applicationIconBadgeNumber
  int get applicationIconBadgeNumber {
    objc.checkOsVersionInternal('UIApplication.applicationIconBadgeNumber', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_applicationIconBadgeNumber);
  }

  /// setApplicationIconBadgeNumber:
  set applicationIconBadgeNumber(int value) {
    objc.checkOsVersionInternal('UIApplication.setApplicationIconBadgeNumber:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_4sp4xj(this.ref.pointer, _sel_setApplicationIconBadgeNumber_, value);
  }

  /// applicationSupportsShakeToEdit
  bool get applicationSupportsShakeToEdit {
    objc.checkOsVersionInternal('UIApplication.applicationSupportsShakeToEdit', iOS: (false, (3, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_applicationSupportsShakeToEdit);
  }

  /// setApplicationSupportsShakeToEdit:
  set applicationSupportsShakeToEdit(bool value) {
    objc.checkOsVersionInternal('UIApplication.setApplicationSupportsShakeToEdit:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setApplicationSupportsShakeToEdit_, value);
  }

  /// applicationState
  UIApplicationState get applicationState {
    objc.checkOsVersionInternal('UIApplication.applicationState', iOS: (false, (4, 0, 0)));
    final _ret = _objc_msgSend_10g89zc(this.ref.pointer, _sel_applicationState);
    return UIApplicationState.fromValue(_ret);
  }

  /// backgroundTimeRemaining
  double get backgroundTimeRemaining {
    objc.checkOsVersionInternal('UIApplication.backgroundTimeRemaining', iOS: (false, (4, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_backgroundTimeRemaining)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_backgroundTimeRemaining);
  }

  /// beginBackgroundTaskWithExpirationHandler:
  int beginBackgroundTaskWithExpirationHandler(objc.ObjCBlock<ffi.Void Function()>? handler) {
    objc.checkOsVersionInternal('UIApplication.beginBackgroundTaskWithExpirationHandler:', iOS: (false, (4, 0, 0)));
    return _objc_msgSend_10mlopr(
      this.ref.pointer,
      _sel_beginBackgroundTaskWithExpirationHandler_,
      handler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// beginBackgroundTaskWithName:expirationHandler:
  int beginBackgroundTaskWithName(objc.NSString? taskName, {objc.ObjCBlock<ffi.Void Function()>? expirationHandler}) {
    objc.checkOsVersionInternal(
      'UIApplication.beginBackgroundTaskWithName:expirationHandler:',
      iOS: (false, (7, 0, 0)),
    );
    return _objc_msgSend_jkkt9d(
      this.ref.pointer,
      _sel_beginBackgroundTaskWithName_expirationHandler_,
      taskName?.ref.pointer ?? ffi.nullptr,
      expirationHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// endBackgroundTask:
  void endBackgroundTask(int identifier) {
    objc.checkOsVersionInternal('UIApplication.endBackgroundTask:', iOS: (false, (4, 0, 0)));
    _objc_msgSend_1i9r4xy(this.ref.pointer, _sel_endBackgroundTask_, identifier);
  }

  /// ! The system guarantees that it will not wake up your application for a background fetch more
  /// frequently than the interval provided. Set to UIApplicationBackgroundFetchIntervalMinimum to be
  /// woken as frequently as the system desires, or to UIApplicationBackgroundFetchIntervalNever (the
  /// default) to never be woken for a background fetch.
  ///
  /// This setter will have no effect unless your application has the "fetch"
  /// UIBackgroundMode. See the UIApplicationDelegate method
  /// `application:performFetchWithCompletionHandler:` for more.
  void setMinimumBackgroundFetchInterval(double minimumBackgroundFetchInterval) {
    objc.checkOsVersionInternal('UIApplication.setMinimumBackgroundFetchInterval:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setMinimumBackgroundFetchInterval_, minimumBackgroundFetchInterval);
  }

  /// ! When background refresh is available for an application, it may launched or resumed in the background to handle significant
  /// location changes, remote notifications, background fetches, etc. Observe UIApplicationBackgroundRefreshStatusDidChangeNotification to
  /// be notified of changes.
  UIBackgroundRefreshStatus get backgroundRefreshStatus {
    objc.checkOsVersionInternal('UIApplication.backgroundRefreshStatus', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_1499xyo(this.ref.pointer, _sel_backgroundRefreshStatus);
    return UIBackgroundRefreshStatus.fromValue(_ret);
  }

  /// isProtectedDataAvailable
  bool get protectedDataAvailable {
    objc.checkOsVersionInternal('UIApplication.isProtectedDataAvailable', iOS: (false, (4, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isProtectedDataAvailable);
  }

  /// userInterfaceLayoutDirection
  UIUserInterfaceLayoutDirection get userInterfaceLayoutDirection {
    objc.checkOsVersionInternal('UIApplication.userInterfaceLayoutDirection', iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_qj4fey(this.ref.pointer, _sel_userInterfaceLayoutDirection);
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// preferredContentSizeCategory
  objc.NSString get preferredContentSizeCategory {
    objc.checkOsVersionInternal('UIApplication.preferredContentSizeCategory', iOS: (false, (7, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_preferredContentSizeCategory);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// connectedScenes
  objc.NSSet get connectedScenes {
    objc.checkOsVersionInternal('UIApplication.connectedScenes', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_connectedScenes);
    return objc.NSSet.castFromPointer(_ret, retain: true, release: true);
  }

  /// openSessions
  objc.NSSet get openSessions {
    objc.checkOsVersionInternal('UIApplication.openSessions', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_openSessions);
    return objc.NSSet.castFromPointer(_ret, retain: true, release: true);
  }

  /// supportsMultipleScenes
  bool get supportsMultipleScenes {
    objc.checkOsVersionInternal('UIApplication.supportsMultipleScenes', iOS: (false, (13, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_supportsMultipleScenes);
  }

  /// requestSceneSessionActivation:userActivity:options:errorHandler:
  void requestSceneSessionActivation(
    UISceneSession? sceneSession, {
    NSUserActivity? userActivity,
    UISceneActivationRequestOptions? options,
    objc.ObjCBlock<ffi.Void Function(objc.NSError)>? errorHandler,
  }) {
    objc.checkOsVersionInternal(
      'UIApplication.requestSceneSessionActivation:userActivity:options:errorHandler:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_m7tls4(
      this.ref.pointer,
      _sel_requestSceneSessionActivation_userActivity_options_errorHandler_,
      sceneSession?.ref.pointer ?? ffi.nullptr,
      userActivity?.ref.pointer ?? ffi.nullptr,
      options?.ref.pointer ?? ffi.nullptr,
      errorHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// requestSceneSessionDestruction:options:errorHandler:
  void requestSceneSessionDestruction(
    UISceneSession sceneSession, {
    UISceneDestructionRequestOptions? options,
    objc.ObjCBlock<ffi.Void Function(objc.NSError)>? errorHandler,
  }) {
    objc.checkOsVersionInternal(
      'UIApplication.requestSceneSessionDestruction:options:errorHandler:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      this.ref.pointer,
      _sel_requestSceneSessionDestruction_options_errorHandler_,
      sceneSession.ref.pointer,
      options?.ref.pointer ?? ffi.nullptr,
      errorHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// requestSceneSessionRefresh:
  void requestSceneSessionRefresh(UISceneSession sceneSession) {
    objc.checkOsVersionInternal('UIApplication.requestSceneSessionRefresh:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_requestSceneSessionRefresh_, sceneSession.ref.pointer);
  }

  /// init
  UIApplication init() {
    objc.checkOsVersionInternal('UIApplication.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIApplication.castFromPointer(_ret, retain: false, release: true);
  }
}

enum UISceneCollectionJoinBehavior {
  UISceneCollectionJoinBehaviorAutomatic(0),
  UISceneCollectionJoinBehaviorPreferred(1),
  UISceneCollectionJoinBehaviorDisallowed(2),
  UISceneCollectionJoinBehaviorPreferredWithoutActivating(3);

  final int value;
  const UISceneCollectionJoinBehavior(this.value);

  static UISceneCollectionJoinBehavior fromValue(int value) => switch (value) {
    0 => UISceneCollectionJoinBehaviorAutomatic,
    1 => UISceneCollectionJoinBehaviorPreferred,
    2 => UISceneCollectionJoinBehaviorDisallowed,
    3 => UISceneCollectionJoinBehaviorPreferredWithoutActivating,
    _ => throw ArgumentError('Unknown value for UISceneCollectionJoinBehavior: $value'),
  };
}

enum NSMenuPresentationStyle {
  NSMenuPresentationStyleRegular(0),
  NSMenuPresentationStylePalette(1);

  final int value;
  const NSMenuPresentationStyle(this.value);

  static NSMenuPresentationStyle fromValue(int value) => switch (value) {
    0 => NSMenuPresentationStyleRegular,
    1 => NSMenuPresentationStylePalette,
    _ => throw ArgumentError('Unknown value for NSMenuPresentationStyle: $value'),
  };
}

enum NSMenuSelectionMode {
  NSMenuSelectionModeAutomatic(0),
  NSMenuSelectionModeSelectOne(1),
  NSMenuSelectionModeSelectAny(2);

  final int value;
  const NSMenuSelectionMode(this.value);

  static NSMenuSelectionMode fromValue(int value) => switch (value) {
    0 => NSMenuSelectionModeAutomatic,
    1 => NSMenuSelectionModeSelectOne,
    2 => NSMenuSelectionModeSelectAny,
    _ => throw ArgumentError('Unknown value for NSMenuSelectionMode: $value'),
  };
}

enum NSMenuProperties {
  NSMenuPropertyItemTitle(1),
  NSMenuPropertyItemAttributedTitle(2),
  NSMenuPropertyItemKeyEquivalent(4),
  NSMenuPropertyItemImage(8),
  NSMenuPropertyItemEnabled(16),
  NSMenuPropertyItemAccessibilityDescription(32);

  final int value;
  const NSMenuProperties(this.value);

  static NSMenuProperties fromValue(int value) => switch (value) {
    1 => NSMenuPropertyItemTitle,
    2 => NSMenuPropertyItemAttributedTitle,
    4 => NSMenuPropertyItemKeyEquivalent,
    8 => NSMenuPropertyItemImage,
    16 => NSMenuPropertyItemEnabled,
    32 => NSMenuPropertyItemAccessibilityDescription,
    _ => throw ArgumentError('Unknown value for NSMenuProperties: $value'),
  };
}

enum NSToolbarDisplayMode {
  NSToolbarDisplayModeDefault(0),
  NSToolbarDisplayModeIconAndLabel(1),
  NSToolbarDisplayModeIconOnly(2),
  NSToolbarDisplayModeLabelOnly(3);

  final int value;
  const NSToolbarDisplayMode(this.value);

  static NSToolbarDisplayMode fromValue(int value) => switch (value) {
    0 => NSToolbarDisplayModeDefault,
    1 => NSToolbarDisplayModeIconAndLabel,
    2 => NSToolbarDisplayModeIconOnly,
    3 => NSToolbarDisplayModeLabelOnly,
    _ => throw ArgumentError('Unknown value for NSToolbarDisplayMode: $value'),
  };
}

enum NSToolbarSizeMode {
  NSToolbarSizeModeDefault(0),
  NSToolbarSizeModeRegular(1),
  NSToolbarSizeModeSmall(2);

  final int value;
  const NSToolbarSizeMode(this.value);

  static NSToolbarSizeMode fromValue(int value) => switch (value) {
    0 => NSToolbarSizeModeDefault,
    1 => NSToolbarSizeModeRegular,
    2 => NSToolbarSizeModeSmall,
    _ => throw ArgumentError('Unknown value for NSToolbarSizeMode: $value'),
  };
}

/// WARNING: NSToolbar is a stub. To generate bindings for this class, include
/// NSToolbar in your config's objc-interfaces list.
///
/// NSToolbar
class NSToolbar extends objc.NSObject {
  NSToolbar._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSToolbar', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [NSToolbar] that points to the same underlying object as [other].
  NSToolbar.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSToolbar] that wraps the given raw object pointer.
  NSToolbar.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

enum NSToolbarItemStyle {
  NSToolbarItemStylePlain(0),
  NSToolbarItemStyleProminent(1);

  final int value;
  const NSToolbarItemStyle(this.value);

  static NSToolbarItemStyle fromValue(int value) => switch (value) {
    0 => NSToolbarItemStylePlain,
    1 => NSToolbarItemStyleProminent,
    _ => throw ArgumentError('Unknown value for NSToolbarItemStyle: $value'),
  };
}

enum UITitlebarSeparatorStyle {
  UITitlebarSeparatorStyleAutomatic(0),
  UITitlebarSeparatorStyleNone(1),
  UITitlebarSeparatorStyleLine(2),
  UITitlebarSeparatorStyleShadow(3);

  final int value;
  const UITitlebarSeparatorStyle(this.value);

  static UITitlebarSeparatorStyle fromValue(int value) => switch (value) {
    0 => UITitlebarSeparatorStyleAutomatic,
    1 => UITitlebarSeparatorStyleNone,
    2 => UITitlebarSeparatorStyleLine,
    3 => UITitlebarSeparatorStyleShadow,
    _ => throw ArgumentError('Unknown value for UITitlebarSeparatorStyle: $value'),
  };
}

enum UITitlebarTitleVisibility {
  UITitlebarTitleVisibilityVisible(0),
  UITitlebarTitleVisibilityHidden(1);

  final int value;
  const UITitlebarTitleVisibility(this.value);

  static UITitlebarTitleVisibility fromValue(int value) => switch (value) {
    0 => UITitlebarTitleVisibilityVisible,
    1 => UITitlebarTitleVisibilityHidden,
    _ => throw ArgumentError('Unknown value for UITitlebarTitleVisibility: $value'),
  };
}

enum UITitlebarToolbarStyle {
  UITitlebarToolbarStyleAutomatic(0),
  UITitlebarToolbarStyleExpanded(1),
  UITitlebarToolbarStylePreference(2),
  UITitlebarToolbarStyleUnified(3),
  UITitlebarToolbarStyleUnifiedCompact(4);

  final int value;
  const UITitlebarToolbarStyle(this.value);

  static UITitlebarToolbarStyle fromValue(int value) => switch (value) {
    0 => UITitlebarToolbarStyleAutomatic,
    1 => UITitlebarToolbarStyleExpanded,
    2 => UITitlebarToolbarStylePreference,
    3 => UITitlebarToolbarStyleUnified,
    4 => UITitlebarToolbarStyleUnifiedCompact,
    _ => throw ArgumentError('Unknown value for UITitlebarToolbarStyle: $value'),
  };
}

late final _class_UITitlebar = objc.getClass("UITitlebar");
late final _sel_titleVisibility = objc.registerName("titleVisibility");
final _objc_msgSend_1w8h4wm = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTitleVisibility_ = objc.registerName("setTitleVisibility:");
final _objc_msgSend_91112w = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_toolbarStyle = objc.registerName("toolbarStyle");
final _objc_msgSend_1p2m5do = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setToolbarStyle_ = objc.registerName("setToolbarStyle:");
final _objc_msgSend_jgznzi = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_separatorStyle = objc.registerName("separatorStyle");
final _objc_msgSend_15x21aw = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setSeparatorStyle_ = objc.registerName("setSeparatorStyle:");
final _objc_msgSend_rbhdpu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setToolbar_ = objc.registerName("setToolbar:");
late final _sel_autoHidesToolbarInFullScreen = objc.registerName("autoHidesToolbarInFullScreen");
late final _sel_setAutoHidesToolbarInFullScreen_ = objc.registerName("setAutoHidesToolbarInFullScreen:");
late final _sel_representedURL = objc.registerName("representedURL");
late final _sel_setRepresentedURL_ = objc.registerName("setRepresentedURL:");

/// UITitlebar
class UITitlebar extends objc.NSObject {
  UITitlebar._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [UITitlebar] that points to the same underlying object as [other].
  UITitlebar.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITitlebar] that wraps the given raw object pointer.
  UITitlebar.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UITitlebar].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UITitlebar);
  }

  /// new
  static UITitlebar new$() {
    final _ret = _objc_msgSend_151sglz(_class_UITitlebar, _sel_new);
    return UITitlebar.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UITitlebar allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(_class_UITitlebar, _sel_allocWithZone_, zone);
    return UITitlebar.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UITitlebar alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UITitlebar, _sel_alloc);
    return UITitlebar.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of UITitlebar constructed with the default `new` method.
  factory UITitlebar() => new$();
}

extension UITitlebar$Methods on UITitlebar {
  /// titleVisibility
  UITitlebarTitleVisibility get titleVisibility {
    final _ret = _objc_msgSend_1w8h4wm(this.ref.pointer, _sel_titleVisibility);
    return UITitlebarTitleVisibility.fromValue(_ret);
  }

  /// setTitleVisibility:
  set titleVisibility(UITitlebarTitleVisibility value) {
    _objc_msgSend_91112w(this.ref.pointer, _sel_setTitleVisibility_, value.value);
  }

  /// toolbarStyle
  UITitlebarToolbarStyle get toolbarStyle {
    final _ret = _objc_msgSend_1p2m5do(this.ref.pointer, _sel_toolbarStyle);
    return UITitlebarToolbarStyle.fromValue(_ret);
  }

  /// setToolbarStyle:
  set toolbarStyle(UITitlebarToolbarStyle value) {
    _objc_msgSend_jgznzi(this.ref.pointer, _sel_setToolbarStyle_, value.value);
  }

  /// separatorStyle
  UITitlebarSeparatorStyle get separatorStyle {
    final _ret = _objc_msgSend_15x21aw(this.ref.pointer, _sel_separatorStyle);
    return UITitlebarSeparatorStyle.fromValue(_ret);
  }

  /// setSeparatorStyle:
  set separatorStyle(UITitlebarSeparatorStyle value) {
    _objc_msgSend_rbhdpu(this.ref.pointer, _sel_setSeparatorStyle_, value.value);
  }

  /// toolbar
  NSToolbar? get toolbar {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_toolbar);
    return _ret.address == 0 ? null : NSToolbar.castFromPointer(_ret, retain: true, release: true);
  }

  /// setToolbar:
  set toolbar(NSToolbar? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setToolbar_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// autoHidesToolbarInFullScreen
  bool get autoHidesToolbarInFullScreen {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_autoHidesToolbarInFullScreen);
  }

  /// setAutoHidesToolbarInFullScreen:
  set autoHidesToolbarInFullScreen(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setAutoHidesToolbarInFullScreen_, value);
  }

  /// representedURL
  objc.NSURL? get representedURL {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_representedURL);
    return _ret.address == 0 ? null : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// setRepresentedURL:
  set representedURL(objc.NSURL? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setRepresentedURL_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// init
  UITitlebar init() {
    objc.checkOsVersionInternal('UITitlebar.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UITitlebar.castFromPointer(_ret, retain: false, release: true);
  }
}

enum UIAlertActionStyle {
  UIAlertActionStyleDefault(0),
  UIAlertActionStyleCancel(1),
  UIAlertActionStyleDestructive(2);

  final int value;
  const UIAlertActionStyle(this.value);

  static UIAlertActionStyle fromValue(int value) => switch (value) {
    0 => UIAlertActionStyleDefault,
    1 => UIAlertActionStyleCancel,
    2 => UIAlertActionStyleDestructive,
    _ => throw ArgumentError('Unknown value for UIAlertActionStyle: $value'),
  };
}

enum UIAlertControllerStyle {
  UIAlertControllerStyleActionSheet(0),
  UIAlertControllerStyleAlert(1);

  final int value;
  const UIAlertControllerStyle(this.value);

  static UIAlertControllerStyle fromValue(int value) => switch (value) {
    0 => UIAlertControllerStyleActionSheet,
    1 => UIAlertControllerStyleAlert,
    _ => throw ArgumentError('Unknown value for UIAlertControllerStyle: $value'),
  };
}

late final _class_UIAlertAction = objc.getClass("UIAlertAction");
void _ObjCBlock_ffiVoid_UIAlertAction_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_UIAlertAction_fnPtrCallable =
    ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>(
      _ObjCBlock_ffiVoid_UIAlertAction_fnPtrTrampoline,
    ).cast();
void _ObjCBlock_ffiVoid_UIAlertAction_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_UIAlertAction_closureCallable =
    ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>(
      _ObjCBlock_ffiVoid_UIAlertAction_closureTrampoline,
    ).cast();
void _ObjCBlock_ffiVoid_UIAlertAction_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
_ObjCBlock_ffiVoid_UIAlertAction_listenerCallable =
    ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>.listener(
      _ObjCBlock_ffiVoid_UIAlertAction_listenerTrampoline,
    )..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_UIAlertAction_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<objc.ObjCObject> arg0,
) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
>
_ObjCBlock_ffiVoid_UIAlertAction_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >.isolateLocal(_ObjCBlock_ffiVoid_UIAlertAction_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
>
_ObjCBlock_ffiVoid_UIAlertAction_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >.listener(_ObjCBlock_ffiVoid_UIAlertAction_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(UIAlertAction)>`.
abstract final class ObjCBlock_ffiVoid_UIAlertAction {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(UIAlertAction)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(UIAlertAction)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(UIAlertAction)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(UIAlertAction)>(
    objc.newPointerBlock(_ObjCBlock_ffiVoid_UIAlertAction_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UIAlertAction)> fromFunction(
    void Function(UIAlertAction) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(UIAlertAction)>(
    objc.newClosureBlock(
      _ObjCBlock_ffiVoid_UIAlertAction_closureCallable,
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(UIAlertAction.castFromPointer(arg0, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UIAlertAction)> listener(
    void Function(UIAlertAction) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_UIAlertAction_listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(UIAlertAction.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(UIAlertAction)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(UIAlertAction)> blocking(
    void Function(UIAlertAction) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_UIAlertAction_blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(UIAlertAction.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_UIAlertAction_blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(UIAlertAction.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_xtuoz7(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(UIAlertAction)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(UIAlertAction)>`.
extension ObjCBlock_ffiVoid_UIAlertAction_CallExtension on objc.ObjCBlock<ffi.Void Function(UIAlertAction)> {
  void call(UIAlertAction arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0)>
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0.ref.pointer);
}

late final _sel_actionWithTitle_style_handler_ = objc.registerName("actionWithTitle:style:handler:");
final _objc_msgSend_cb5j6t = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Long,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_11gy616 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// UIAlertAction
class UIAlertAction extends objc.NSObject implements objc.NSCopying {
  UIAlertAction._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIAlertAction', iOS: (false, (8, 0, 0)));
  }

  /// Constructs a [UIAlertAction] that points to the same underlying object as [other].
  UIAlertAction.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIAlertAction] that wraps the given raw object pointer.
  UIAlertAction.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIAlertAction].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIAlertAction);
  }

  /// actionWithTitle:style:handler:
  static UIAlertAction actionWithTitle(
    objc.NSString? title, {
    required UIAlertActionStyle style,
    objc.ObjCBlock<ffi.Void Function(UIAlertAction)>? handler,
  }) {
    objc.checkOsVersionInternal('UIAlertAction.actionWithTitle:style:handler:', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_cb5j6t(
      _class_UIAlertAction,
      _sel_actionWithTitle_style_handler_,
      title?.ref.pointer ?? ffi.nullptr,
      style.value,
      handler?.ref.pointer ?? ffi.nullptr,
    );
    return UIAlertAction.castFromPointer(_ret, retain: true, release: true);
  }

  /// new
  static UIAlertAction new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIAlertAction, _sel_new);
    return UIAlertAction.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIAlertAction allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(_class_UIAlertAction, _sel_allocWithZone_, zone);
    return UIAlertAction.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UIAlertAction alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UIAlertAction, _sel_alloc);
    return UIAlertAction.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of UIAlertAction constructed with the default `new` method.
  factory UIAlertAction() => new$();
}

extension UIAlertAction$Methods on UIAlertAction {
  /// title
  objc.NSString? get title {
    objc.checkOsVersionInternal('UIAlertAction.title', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// style
  UIAlertActionStyle get style {
    objc.checkOsVersionInternal('UIAlertAction.style', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_11gy616(this.ref.pointer, _sel_style);
    return UIAlertActionStyle.fromValue(_ret);
  }

  /// isEnabled
  bool get enabled {
    objc.checkOsVersionInternal('UIAlertAction.isEnabled', iOS: (false, (8, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isEnabled);
  }

  /// setEnabled:
  set enabled(bool value) {
    objc.checkOsVersionInternal('UIAlertAction.setEnabled:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setEnabled_, value);
  }

  /// init
  UIAlertAction init() {
    objc.checkOsVersionInternal('UIAlertAction.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIAlertAction.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  UIAlertAction self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return UIAlertAction.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  UIAlertAction retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return UIAlertAction.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  UIAlertAction autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return UIAlertAction.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _class_UIAlertController = objc.getClass("UIAlertController");
late final _sel_alertControllerWithTitle_message_preferredStyle_ = objc.registerName(
  "alertControllerWithTitle:message:preferredStyle:",
);
final _objc_msgSend_1od9gyu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        int,
      )
    >();
late final _sel_addAction_ = objc.registerName("addAction:");
late final _sel_actions = objc.registerName("actions");
late final _sel_preferredAction = objc.registerName("preferredAction");
late final _sel_setPreferredAction_ = objc.registerName("setPreferredAction:");
void _ObjCBlock_ffiVoid_UITextField_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_UITextField_fnPtrCallable =
    ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>(
      _ObjCBlock_ffiVoid_UITextField_fnPtrTrampoline,
    ).cast();
void _ObjCBlock_ffiVoid_UITextField_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_UITextField_closureCallable =
    ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>(
      _ObjCBlock_ffiVoid_UITextField_closureTrampoline,
    ).cast();
void _ObjCBlock_ffiVoid_UITextField_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
_ObjCBlock_ffiVoid_UITextField_listenerCallable =
    ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>.listener(
      _ObjCBlock_ffiVoid_UITextField_listenerTrampoline,
    )..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_UITextField_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<objc.ObjCObject> arg0,
) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
>
_ObjCBlock_ffiVoid_UITextField_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >.isolateLocal(_ObjCBlock_ffiVoid_UITextField_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
>
_ObjCBlock_ffiVoid_UITextField_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >.listener(_ObjCBlock_ffiVoid_UITextField_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(UITextField$1)>`.
abstract final class ObjCBlock_ffiVoid_UITextField {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(UITextField$1)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(UITextField$1)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(UITextField$1)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(UITextField$1)>(
    objc.newPointerBlock(_ObjCBlock_ffiVoid_UITextField_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UITextField$1)> fromFunction(
    void Function(UITextField$1) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(UITextField$1)>(
    objc.newClosureBlock(
      _ObjCBlock_ffiVoid_UITextField_closureCallable,
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(UITextField$1.castFromPointer(arg0, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UITextField$1)> listener(
    void Function(UITextField$1) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_UITextField_listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(UITextField$1.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(UITextField$1)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(UITextField$1)> blocking(
    void Function(UITextField$1) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_UITextField_blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(UITextField$1.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_UITextField_blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(UITextField$1.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_xtuoz7(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(UITextField$1)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(UITextField$1)>`.
extension ObjCBlock_ffiVoid_UITextField_CallExtension on objc.ObjCBlock<ffi.Void Function(UITextField$1)> {
  void call(UITextField$1 arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0)>
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0.ref.pointer);
}

late final _sel_addTextFieldWithConfigurationHandler_ = objc.registerName("addTextFieldWithConfigurationHandler:");
late final _sel_textFields = objc.registerName("textFields");
late final _sel_message = objc.registerName("message");
late final _sel_setMessage_ = objc.registerName("setMessage:");
late final _sel_preferredStyle = objc.registerName("preferredStyle");
final _objc_msgSend_sx15g0 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// UIAlertController
class UIAlertController extends UIViewController {
  UIAlertController._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIAlertController', iOS: (false, (8, 0, 0)));
  }

  /// Constructs a [UIAlertController] that points to the same underlying object as [other].
  UIAlertController.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIAlertController] that wraps the given raw object pointer.
  UIAlertController.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIAlertController].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIAlertController);
  }

  /// alertControllerWithTitle:message:preferredStyle:
  static UIAlertController alertControllerWithTitle(
    objc.NSString? title, {
    objc.NSString? message,
    required UIAlertControllerStyle preferredStyle,
  }) {
    objc.checkOsVersionInternal(
      'UIAlertController.alertControllerWithTitle:message:preferredStyle:',
      iOS: (false, (8, 0, 0)),
    );
    final _ret = _objc_msgSend_1od9gyu(
      _class_UIAlertController,
      _sel_alertControllerWithTitle_message_preferredStyle_,
      title?.ref.pointer ?? ffi.nullptr,
      message?.ref.pointer ?? ffi.nullptr,
      preferredStyle.value,
    );
    return UIAlertController.castFromPointer(_ret, retain: true, release: true);
  }
}

extension UIAlertController$Methods on UIAlertController {
  /// addAction:
  void addAction(UIAlertAction action) {
    objc.checkOsVersionInternal('UIAlertController.addAction:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addAction_, action.ref.pointer);
  }

  /// actions
  objc.NSArray get actions {
    objc.checkOsVersionInternal('UIAlertController.actions', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_actions);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// preferredAction
  UIAlertAction? get preferredAction {
    objc.checkOsVersionInternal('UIAlertController.preferredAction', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_preferredAction);
    return _ret.address == 0 ? null : UIAlertAction.castFromPointer(_ret, retain: true, release: true);
  }

  /// setPreferredAction:
  set preferredAction(UIAlertAction? value) {
    objc.checkOsVersionInternal('UIAlertController.setPreferredAction:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setPreferredAction_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// addTextFieldWithConfigurationHandler:
  void addTextFieldWithConfigurationHandler(objc.ObjCBlock<ffi.Void Function(UITextField$1)>? configurationHandler) {
    objc.checkOsVersionInternal('UIAlertController.addTextFieldWithConfigurationHandler:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_f167m6(
      this.ref.pointer,
      _sel_addTextFieldWithConfigurationHandler_,
      configurationHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// textFields
  objc.NSArray? get textFields {
    objc.checkOsVersionInternal('UIAlertController.textFields', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textFields);
    return _ret.address == 0 ? null : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// title
  objc.NSString? get title {
    objc.checkOsVersionInternal('UIAlertController.title', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTitle:
  set title(objc.NSString? value) {
    objc.checkOsVersionInternal('UIAlertController.setTitle:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTitle_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// message
  objc.NSString? get message {
    objc.checkOsVersionInternal('UIAlertController.message', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_message);
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setMessage:
  set message(objc.NSString? value) {
    objc.checkOsVersionInternal('UIAlertController.setMessage:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setMessage_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// preferredStyle
  UIAlertControllerStyle get preferredStyle {
    objc.checkOsVersionInternal('UIAlertController.preferredStyle', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_sx15g0(this.ref.pointer, _sel_preferredStyle);
    return UIAlertControllerStyle.fromValue(_ret);
  }

  /// initWithNibName:bundle:
  UIAlertController initWithNibName(objc.NSString? nibNameOrNil, {NSBundle? bundle}) {
    objc.checkOsVersionInternal('UIAlertController.initWithNibName:bundle:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_15qeuct(
      this.ref.retainAndReturnPointer(),
      _sel_initWithNibName_bundle_,
      nibNameOrNil?.ref.pointer ?? ffi.nullptr,
      bundle?.ref.pointer ?? ffi.nullptr,
    );
    return UIAlertController.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIAlertController? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0 ? null : UIAlertController.castFromPointer(_ret, retain: false, release: true);
  }
}

/// WARNING: UIBarButtonItemStateAppearance is a stub. To generate bindings for this class, include
/// UIBarButtonItemStateAppearance in your config's objc-interfaces list.
///
/// UIBarButtonItemStateAppearance
class UIBarButtonItemStateAppearance extends objc.NSObject {
  UIBarButtonItemStateAppearance._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIBarButtonItemStateAppearance', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIBarButtonItemStateAppearance] that points to the same underlying object as [other].
  UIBarButtonItemStateAppearance.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIBarButtonItemStateAppearance] that wraps the given raw object pointer.
  UIBarButtonItemStateAppearance.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _class_UIBarButtonItemAppearance = objc.getClass("UIBarButtonItemAppearance");
late final _sel_initWithStyle_ = objc.registerName("initWithStyle:");
final _objc_msgSend_1f28exy = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)
    >();
late final _sel_copy = objc.registerName("copy");
late final _sel_configureWithDefaultForStyle_ = objc.registerName("configureWithDefaultForStyle:");
late final _sel_normal = objc.registerName("normal");
late final _sel_highlighted = objc.registerName("highlighted");
late final _sel_disabled = objc.registerName("disabled");
late final _sel_focused = objc.registerName("focused");

/// UIBarButtonItemAppearance
class UIBarButtonItemAppearance extends objc.NSObject implements objc.NSCopying, objc.NSSecureCoding {
  UIBarButtonItemAppearance._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIBarButtonItemAppearance', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIBarButtonItemAppearance] that points to the same underlying object as [other].
  UIBarButtonItemAppearance.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIBarButtonItemAppearance] that wraps the given raw object pointer.
  UIBarButtonItemAppearance.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIBarButtonItemAppearance].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIBarButtonItemAppearance);
  }

  /// new
  static UIBarButtonItemAppearance new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIBarButtonItemAppearance, _sel_new);
    return UIBarButtonItemAppearance.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIBarButtonItemAppearance allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(_class_UIBarButtonItemAppearance, _sel_allocWithZone_, zone);
    return UIBarButtonItemAppearance.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UIBarButtonItemAppearance alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UIBarButtonItemAppearance, _sel_alloc);
    return UIBarButtonItemAppearance.castFromPointer(_ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UIBarButtonItemAppearance, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of UIBarButtonItemAppearance constructed with the default `new` method.
  factory UIBarButtonItemAppearance() => new$();
}

extension UIBarButtonItemAppearance$Methods on UIBarButtonItemAppearance {
  /// init
  UIBarButtonItemAppearance init() {
    objc.checkOsVersionInternal('UIBarButtonItemAppearance.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIBarButtonItemAppearance.castFromPointer(_ret, retain: false, release: true);
  }

  /// Construct an appearance with default values for the given style.
  UIBarButtonItemAppearance initWithStyle(UIBarButtonItemStyle style) {
    objc.checkOsVersionInternal('UIBarButtonItemAppearance.initWithStyle:', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_1f28exy(this.ref.retainAndReturnPointer(), _sel_initWithStyle_, style.value);
    return UIBarButtonItemAppearance.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIBarButtonItemAppearance? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0 ? null : UIBarButtonItemAppearance.castFromPointer(_ret, retain: false, release: true);
  }

  /// copy
  UIBarButtonItemAppearance copy() {
    objc.checkOsVersionInternal('UIBarButtonItemAppearance.copy', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_copy);
    return UIBarButtonItemAppearance.castFromPointer(_ret, retain: false, release: true);
  }

  /// Reset this appearance to that of a given style.
  void configureWithDefaultForStyle(UIBarButtonItemStyle style) {
    objc.checkOsVersionInternal('UIBarButtonItemAppearance.configureWithDefaultForStyle:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_11ist7u(this.ref.pointer, _sel_configureWithDefaultForStyle_, style.value);
  }

  /// The appearance when the bar button item is in the normal control state.
  UIBarButtonItemStateAppearance get normal {
    objc.checkOsVersionInternal('UIBarButtonItemAppearance.normal', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_normal);
    return UIBarButtonItemStateAppearance.castFromPointer(_ret, retain: true, release: true);
  }

  /// The appearance when the bar button item is in the highlighted control state. If unspecified, then synthesized from the normal state.
  UIBarButtonItemStateAppearance get highlighted {
    objc.checkOsVersionInternal('UIBarButtonItemAppearance.highlighted', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_highlighted);
    return UIBarButtonItemStateAppearance.castFromPointer(_ret, retain: true, release: true);
  }

  /// The appearance when the bar button item is in the disabled control state. If unspecified, then synthesized from the normal state.
  UIBarButtonItemStateAppearance get disabled {
    objc.checkOsVersionInternal('UIBarButtonItemAppearance.disabled', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_disabled);
    return UIBarButtonItemStateAppearance.castFromPointer(_ret, retain: true, release: true);
  }

  /// The appearance when the bar button item is in the focused control state. If unspecified, then synthesized from the highlighted state.
  UIBarButtonItemStateAppearance get focused {
    objc.checkOsVersionInternal('UIBarButtonItemAppearance.focused', iOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_focused);
    return UIBarButtonItemStateAppearance.castFromPointer(_ret, retain: true, release: true);
  }

  /// self
  UIBarButtonItemAppearance self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return UIBarButtonItemAppearance.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  UIBarButtonItemAppearance retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return UIBarButtonItemAppearance.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  UIBarButtonItemAppearance autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return UIBarButtonItemAppearance.castFromPointer(_ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }
}

late final _class_UILabel = objc.getClass("UILabel");
late final _sel_text = objc.registerName("text");
late final _sel_setText_ = objc.registerName("setText:");
late final _sel_font = objc.registerName("font");
late final _sel_setFont_ = objc.registerName("setFont:");
late final _sel_textColor = objc.registerName("textColor");
late final _sel_setTextColor_ = objc.registerName("setTextColor:");
late final _sel_shadowColor = objc.registerName("shadowColor");
late final _sel_setShadowColor_ = objc.registerName("setShadowColor:");
late final _sel_shadowOffset = objc.registerName("shadowOffset");
late final _sel_setShadowOffset_ = objc.registerName("setShadowOffset:");
late final _sel_textAlignment = objc.registerName("textAlignment");
final _objc_msgSend_buxwfm = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTextAlignment_ = objc.registerName("setTextAlignment:");
final _objc_msgSend_12huos = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_lineBreakMode = objc.registerName("lineBreakMode");
final _objc_msgSend_ybsdio = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setLineBreakMode_ = objc.registerName("setLineBreakMode:");
final _objc_msgSend_1kdet46 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_attributedText = objc.registerName("attributedText");
late final _sel_setAttributedText_ = objc.registerName("setAttributedText:");
late final _sel_highlightedTextColor = objc.registerName("highlightedTextColor");
late final _sel_setHighlightedTextColor_ = objc.registerName("setHighlightedTextColor:");
late final _sel_numberOfLines = objc.registerName("numberOfLines");
late final _sel_setNumberOfLines_ = objc.registerName("setNumberOfLines:");
late final _sel_adjustsFontSizeToFitWidth = objc.registerName("adjustsFontSizeToFitWidth");
late final _sel_setAdjustsFontSizeToFitWidth_ = objc.registerName("setAdjustsFontSizeToFitWidth:");
late final _sel_baselineAdjustment = objc.registerName("baselineAdjustment");
final _objc_msgSend_1fz8ybf = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setBaselineAdjustment_ = objc.registerName("setBaselineAdjustment:");
final _objc_msgSend_1j9etgn = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_minimumScaleFactor = objc.registerName("minimumScaleFactor");
late final _sel_setMinimumScaleFactor_ = objc.registerName("setMinimumScaleFactor:");
late final _sel_allowsDefaultTighteningForTruncation = objc.registerName("allowsDefaultTighteningForTruncation");
late final _sel_setAllowsDefaultTighteningForTruncation_ = objc.registerName(
  "setAllowsDefaultTighteningForTruncation:",
);
late final _sel_lineBreakStrategy = objc.registerName("lineBreakStrategy");
final _objc_msgSend_fcsyxu = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setLineBreakStrategy_ = objc.registerName("setLineBreakStrategy:");
final _objc_msgSend_1eahgd8 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_textRectForBounds_limitedToNumberOfLines_ = objc.registerName(
  "textRectForBounds:limitedToNumberOfLines:",
);
final _objc_msgSend_o8h5mj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect, ffi.Long)
      >
    >()
    .asFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect, int)>();
final _objc_msgSend_o8h5mjStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        int,
      )
    >();
late final _sel_drawTextInRect_ = objc.registerName("drawTextInRect:");
late final _sel_preferredMaxLayoutWidth = objc.registerName("preferredMaxLayoutWidth");
late final _sel_setPreferredMaxLayoutWidth_ = objc.registerName("setPreferredMaxLayoutWidth:");
late final _sel_enablesMarqueeWhenAncestorFocused = objc.registerName("enablesMarqueeWhenAncestorFocused");
late final _sel_setEnablesMarqueeWhenAncestorFocused_ = objc.registerName("setEnablesMarqueeWhenAncestorFocused:");
late final _sel_showsExpansionTextWhenTruncated = objc.registerName("showsExpansionTextWhenTruncated");
late final _sel_setShowsExpansionTextWhenTruncated_ = objc.registerName("setShowsExpansionTextWhenTruncated:");
late final _sel_minimumFontSize = objc.registerName("minimumFontSize");
late final _sel_setMinimumFontSize_ = objc.registerName("setMinimumFontSize:");
late final _sel_adjustsLetterSpacingToFitWidth = objc.registerName("adjustsLetterSpacingToFitWidth");
late final _sel_setAdjustsLetterSpacingToFitWidth_ = objc.registerName("setAdjustsLetterSpacingToFitWidth:");
late final _sel_adjustsFontForContentSizeCategory = objc.registerName("adjustsFontForContentSizeCategory");
late final _sel_setAdjustsFontForContentSizeCategory_ = objc.registerName("setAdjustsFontForContentSizeCategory:");
void _ObjCBlock_ffiVoid_ffiVoid_bool_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  bool arg1,
) => block.ref.target
    .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Bool arg1)>>()
    .asFunction<void Function(ffi.Pointer<ffi.Void>, bool)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_bool_fnPtrCallable =
    ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)>(
      _ObjCBlock_ffiVoid_ffiVoid_bool_fnPtrTrampoline,
    ).cast();
void _ObjCBlock_ffiVoid_ffiVoid_bool_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  bool arg1,
) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, bool))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_bool_closureCallable =
    ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)>(
      _ObjCBlock_ffiVoid_ffiVoid_bool_closureTrampoline,
    ).cast();
void _ObjCBlock_ffiVoid_ffiVoid_bool_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  bool arg1,
) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, bool))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)>
_ObjCBlock_ffiVoid_ffiVoid_bool_listenerCallable =
    ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)>.listener(
      _ObjCBlock_ffiVoid_ffiVoid_bool_listenerTrampoline,
    )..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_bool_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  bool arg1,
) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, bool))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Bool)
>
_ObjCBlock_ffiVoid_ffiVoid_bool_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Bool)
      >.isolateLocal(_ObjCBlock_ffiVoid_ffiVoid_bool_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Bool)
>
_ObjCBlock_ffiVoid_ffiVoid_bool_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Bool)
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_bool_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Bool arg1)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(
    objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_bool_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, bool) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(
    objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_bool_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, bool arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)> listener(
    void Function(ffi.Pointer<ffi.Void>, bool) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_bool_listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, bool arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapListenerBlock_10lndml(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)> blocking(
    void Function(ffi.Pointer<ffi.Void>, bool) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_bool_blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, bool arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_bool_blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, bool arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _UIKit_wrapBlockingBlock_10lndml(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>`.
extension ObjCBlock_ffiVoid_ffiVoid_bool_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)> {
  void call(ffi.Pointer<ffi.Void> arg0, bool arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Bool arg1)
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, bool)>()(
        ref.pointer,
        arg0,
        arg1,
      );
}

/// UILabel
class UILabel extends UIView implements objc.NSCoding, UIContentSizeCategoryAdjusting {
  UILabel._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UILabel', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UILabel] that points to the same underlying object as [other].
  UILabel.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UILabel] that wraps the given raw object pointer.
  UILabel.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UILabel].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UILabel);
  }

  /// layerClass
  static objc.ObjCObjectBase getLayerClass() {
    objc.checkOsVersionInternal('UILabel.layerClass', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UILabel, _sel_layerClass);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute(
    UISemanticContentAttribute attribute,
  ) {
    objc.checkOsVersionInternal(
      'UILabel.userInterfaceLayoutDirectionForSemanticContentAttribute:',
      iOS: (false, (9, 0, 0)),
    );
    final _ret = _objc_msgSend_racczx(
      _class_UILabel,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
      attribute.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute$1(
    UISemanticContentAttribute semanticContentAttribute, {
    required UIUserInterfaceLayoutDirection relativeToLayoutDirection,
  }) {
    objc.checkOsVersionInternal(
      'UILabel.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
      iOS: (false, (10, 0, 0)),
    );
    final _ret = _objc_msgSend_tz4p54(
      _class_UILabel,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
      semanticContentAttribute.value,
      relativeToLayoutDirection.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// new
  static UILabel new$() {
    final _ret = _objc_msgSend_151sglz(_class_UILabel, _sel_new);
    return UILabel.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UILabel allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(_class_UILabel, _sel_allocWithZone_, zone);
    return UILabel.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static UILabel alloc() {
    final _ret = _objc_msgSend_151sglz(_class_UILabel, _sel_alloc);
    return UILabel.castFromPointer(_ret, retain: false, release: true);
  }

  /// appearance
  static UILabel appearance() {
    final _ret = _objc_msgSend_151sglz(_class_UILabel, _sel_appearance);
    return UILabel.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceWhenContainedIn:
  static UILabel appearanceWhenContainedIn(UIAppearanceContainer? ContainerClass) {
    objc.checkOsVersionInternal('UILabel.appearanceWhenContainedIn:', iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
      _class_UILabel,
      _sel_appearanceWhenContainedIn_,
      ContainerClass?.ref.pointer ?? ffi.nullptr,
    );
    return UILabel.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceWhenContainedInInstancesOfClasses:
  static UILabel appearanceWhenContainedInInstancesOfClasses(objc.NSArray containerTypes) {
    objc.checkOsVersionInternal('UILabel.appearanceWhenContainedInInstancesOfClasses:', iOS: (false, (9, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
      _class_UILabel,
      _sel_appearanceWhenContainedInInstancesOfClasses_,
      containerTypes.ref.pointer,
    );
    return UILabel.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:
  static UILabel appearanceForTraitCollection(UITraitCollection trait) {
    objc.checkOsVersionInternal('UILabel.appearanceForTraitCollection:', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_UILabel, _sel_appearanceForTraitCollection_, trait.ref.pointer);
    return UILabel.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedIn:
  static UILabel appearanceForTraitCollection$1(UITraitCollection trait, {UIAppearanceContainer? whenContainedIn}) {
    objc.checkOsVersionInternal('UILabel.appearanceForTraitCollection:whenContainedIn:', iOS: (false, (8, 0, 0)));
    final _ret = _objc_msgSend_15qeuct(
      _class_UILabel,
      _sel_appearanceForTraitCollection_whenContainedIn_,
      trait.ref.pointer,
      whenContainedIn?.ref.pointer ?? ffi.nullptr,
    );
    return UILabel.castFromPointer(_ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedInInstancesOfClasses:
  static UILabel appearanceForTraitCollection$2(
    UITraitCollection trait, {
    required objc.NSArray whenContainedInInstancesOfClasses,
  }) {
    objc.checkOsVersionInternal(
      'UILabel.appearanceForTraitCollection:whenContainedInInstancesOfClasses:',
      iOS: (false, (9, 0, 0)),
    );
    final _ret = _objc_msgSend_15qeuct(
      _class_UILabel,
      _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_,
      trait.ref.pointer,
      whenContainedInInstancesOfClasses.ref.pointer,
    );
    return UILabel.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of UILabel constructed with the default `new` method.
  factory UILabel() => new$();
}

extension UILabel$Methods on UILabel {
  /// text
  objc.NSString? get text {
    objc.checkOsVersionInternal('UILabel.text', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_text);
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setText:
  set text(objc.NSString? value) {
    objc.checkOsVersionInternal('UILabel.setText:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setText_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// font
  UIFont get font {
    objc.checkOsVersionInternal('UILabel.font', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_font);
    return UIFont.castFromPointer(_ret, retain: true, release: true);
  }

  /// setFont:
  set font(UIFont value) {
    objc.checkOsVersionInternal('UILabel.setFont:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setFont_, value.ref.pointer);
  }

  /// textColor
  UIColor get textColor {
    objc.checkOsVersionInternal('UILabel.textColor', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textColor);
    return UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// setTextColor:
  set textColor(UIColor value) {
    objc.checkOsVersionInternal('UILabel.setTextColor:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTextColor_, value.ref.pointer);
  }

  /// shadowColor
  UIColor? get shadowColor {
    objc.checkOsVersionInternal('UILabel.shadowColor', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_shadowColor);
    return _ret.address == 0 ? null : UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// setShadowColor:
  set shadowColor(UIColor? value) {
    objc.checkOsVersionInternal('UILabel.setShadowColor:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setShadowColor_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// shadowOffset
  objc.CGSize get shadowOffset {
    objc.checkOsVersionInternal('UILabel.shadowOffset', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1vdfkenStret(_ptr, this.ref.pointer, _sel_shadowOffset)
        : _ptr.ref = _objc_msgSend_1vdfken(this.ref.pointer, _sel_shadowOffset);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>(_finalizable);
  }

  /// setShadowOffset:
  set shadowOffset(objc.CGSize value) {
    objc.checkOsVersionInternal('UILabel.setShadowOffset:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_13lgpwz(this.ref.pointer, _sel_setShadowOffset_, value);
  }

  /// textAlignment
  NSTextAlignment get textAlignment {
    objc.checkOsVersionInternal('UILabel.textAlignment', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_buxwfm(this.ref.pointer, _sel_textAlignment);
    return NSTextAlignment.fromValue(_ret);
  }

  /// setTextAlignment:
  set textAlignment(NSTextAlignment value) {
    objc.checkOsVersionInternal('UILabel.setTextAlignment:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_12huos(this.ref.pointer, _sel_setTextAlignment_, value.value);
  }

  /// lineBreakMode
  NSLineBreakMode get lineBreakMode {
    objc.checkOsVersionInternal('UILabel.lineBreakMode', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_ybsdio(this.ref.pointer, _sel_lineBreakMode);
    return NSLineBreakMode.fromValue(_ret);
  }

  /// setLineBreakMode:
  set lineBreakMode(NSLineBreakMode value) {
    objc.checkOsVersionInternal('UILabel.setLineBreakMode:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1kdet46(this.ref.pointer, _sel_setLineBreakMode_, value.value);
  }

  /// attributedText
  NSAttributedString? get attributedText {
    objc.checkOsVersionInternal('UILabel.attributedText', iOS: (false, (6, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_attributedText);
    return _ret.address == 0 ? null : NSAttributedString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setAttributedText:
  set attributedText(NSAttributedString? value) {
    objc.checkOsVersionInternal('UILabel.setAttributedText:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setAttributedText_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// highlightedTextColor
  UIColor? get highlightedTextColor {
    objc.checkOsVersionInternal('UILabel.highlightedTextColor', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_highlightedTextColor);
    return _ret.address == 0 ? null : UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// setHighlightedTextColor:
  set highlightedTextColor(UIColor? value) {
    objc.checkOsVersionInternal('UILabel.setHighlightedTextColor:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setHighlightedTextColor_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// isHighlighted
  bool get highlighted {
    objc.checkOsVersionInternal('UILabel.isHighlighted', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isHighlighted);
  }

  /// setHighlighted:
  set highlighted(bool value) {
    objc.checkOsVersionInternal('UILabel.setHighlighted:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHighlighted_, value);
  }

  /// isUserInteractionEnabled
  bool get userInteractionEnabled {
    objc.checkOsVersionInternal('UILabel.isUserInteractionEnabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isUserInteractionEnabled);
  }

  /// setUserInteractionEnabled:
  set userInteractionEnabled(bool value) {
    objc.checkOsVersionInternal('UILabel.setUserInteractionEnabled:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setUserInteractionEnabled_, value);
  }

  /// isEnabled
  bool get enabled {
    objc.checkOsVersionInternal('UILabel.isEnabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isEnabled);
  }

  /// setEnabled:
  set enabled(bool value) {
    objc.checkOsVersionInternal('UILabel.setEnabled:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setEnabled_, value);
  }

  /// numberOfLines
  int get numberOfLines {
    objc.checkOsVersionInternal('UILabel.numberOfLines', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_numberOfLines);
  }

  /// setNumberOfLines:
  set numberOfLines(int value) {
    objc.checkOsVersionInternal('UILabel.setNumberOfLines:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_4sp4xj(this.ref.pointer, _sel_setNumberOfLines_, value);
  }

  /// adjustsFontSizeToFitWidth
  bool get adjustsFontSizeToFitWidth {
    objc.checkOsVersionInternal('UILabel.adjustsFontSizeToFitWidth', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_adjustsFontSizeToFitWidth);
  }

  /// setAdjustsFontSizeToFitWidth:
  set adjustsFontSizeToFitWidth(bool value) {
    objc.checkOsVersionInternal('UILabel.setAdjustsFontSizeToFitWidth:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setAdjustsFontSizeToFitWidth_, value);
  }

  /// baselineAdjustment
  UIBaselineAdjustment get baselineAdjustment {
    objc.checkOsVersionInternal('UILabel.baselineAdjustment', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_1fz8ybf(this.ref.pointer, _sel_baselineAdjustment);
    return UIBaselineAdjustment.fromValue(_ret);
  }

  /// setBaselineAdjustment:
  set baselineAdjustment(UIBaselineAdjustment value) {
    objc.checkOsVersionInternal('UILabel.setBaselineAdjustment:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1j9etgn(this.ref.pointer, _sel_setBaselineAdjustment_, value.value);
  }

  /// minimumScaleFactor
  double get minimumScaleFactor {
    objc.checkOsVersionInternal('UILabel.minimumScaleFactor', iOS: (false, (6, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_minimumScaleFactor)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_minimumScaleFactor);
  }

  /// setMinimumScaleFactor:
  set minimumScaleFactor(double value) {
    objc.checkOsVersionInternal('UILabel.setMinimumScaleFactor:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setMinimumScaleFactor_, value);
  }

  /// allowsDefaultTighteningForTruncation
  bool get allowsDefaultTighteningForTruncation {
    objc.checkOsVersionInternal('UILabel.allowsDefaultTighteningForTruncation', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_allowsDefaultTighteningForTruncation);
  }

  /// setAllowsDefaultTighteningForTruncation:
  set allowsDefaultTighteningForTruncation(bool value) {
    objc.checkOsVersionInternal('UILabel.setAllowsDefaultTighteningForTruncation:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setAllowsDefaultTighteningForTruncation_, value);
  }

  /// lineBreakStrategy
  NSLineBreakStrategy get lineBreakStrategy {
    objc.checkOsVersionInternal('UILabel.lineBreakStrategy', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_fcsyxu(this.ref.pointer, _sel_lineBreakStrategy);
    return NSLineBreakStrategy.fromValue(_ret);
  }

  /// setLineBreakStrategy:
  set lineBreakStrategy(NSLineBreakStrategy value) {
    objc.checkOsVersionInternal('UILabel.setLineBreakStrategy:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1eahgd8(this.ref.pointer, _sel_setLineBreakStrategy_, value.value);
  }

  /// textRectForBounds:limitedToNumberOfLines:
  objc.CGRect textRectForBounds(objc.CGRect bounds, {required int limitedToNumberOfLines}) {
    objc.checkOsVersionInternal('UILabel.textRectForBounds:limitedToNumberOfLines:', iOS: (false, (2, 0, 0)));
    final _ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_o8h5mjStret(
            _ptr,
            this.ref.pointer,
            _sel_textRectForBounds_limitedToNumberOfLines_,
            bounds,
            limitedToNumberOfLines,
          )
        : _ptr.ref = _objc_msgSend_o8h5mj(
            this.ref.pointer,
            _sel_textRectForBounds_limitedToNumberOfLines_,
            bounds,
            limitedToNumberOfLines,
          );
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>(_finalizable);
  }

  /// drawTextInRect:
  void drawTextInRect(objc.CGRect rect) {
    objc.checkOsVersionInternal('UILabel.drawTextInRect:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1okkq16(this.ref.pointer, _sel_drawTextInRect_, rect);
  }

  /// preferredMaxLayoutWidth
  double get preferredMaxLayoutWidth {
    objc.checkOsVersionInternal('UILabel.preferredMaxLayoutWidth', iOS: (false, (6, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_preferredMaxLayoutWidth)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_preferredMaxLayoutWidth);
  }

  /// setPreferredMaxLayoutWidth:
  set preferredMaxLayoutWidth(double value) {
    objc.checkOsVersionInternal('UILabel.setPreferredMaxLayoutWidth:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setPreferredMaxLayoutWidth_, value);
  }

  /// enablesMarqueeWhenAncestorFocused
  bool get enablesMarqueeWhenAncestorFocused {
    objc.checkOsVersionInternal('UILabel.enablesMarqueeWhenAncestorFocused', iOS: (true, null));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_enablesMarqueeWhenAncestorFocused);
  }

  /// setEnablesMarqueeWhenAncestorFocused:
  set enablesMarqueeWhenAncestorFocused(bool value) {
    objc.checkOsVersionInternal('UILabel.setEnablesMarqueeWhenAncestorFocused:', iOS: (true, null));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setEnablesMarqueeWhenAncestorFocused_, value);
  }

  /// Indicates whether expansion text will be shown when the view is too small to show all the contents. Defaults to NO.
  bool get showsExpansionTextWhenTruncated {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_showsExpansionTextWhenTruncated);
  }

  /// Indicates whether expansion text will be shown when the view is too small to show all the contents. Defaults to NO.
  set showsExpansionTextWhenTruncated(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setShowsExpansionTextWhenTruncated_, value);
  }

  /// minimumFontSize
  double get minimumFontSize {
    objc.checkOsVersionInternal('UILabel.minimumFontSize', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_minimumFontSize)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_minimumFontSize);
  }

  /// setMinimumFontSize:
  set minimumFontSize(double value) {
    objc.checkOsVersionInternal('UILabel.setMinimumFontSize:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setMinimumFontSize_, value);
  }

  /// adjustsLetterSpacingToFitWidth
  bool get adjustsLetterSpacingToFitWidth {
    objc.checkOsVersionInternal('UILabel.adjustsLetterSpacingToFitWidth', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_adjustsLetterSpacingToFitWidth);
  }

  /// setAdjustsLetterSpacingToFitWidth:
  set adjustsLetterSpacingToFitWidth(bool value) {
    objc.checkOsVersionInternal('UILabel.setAdjustsLetterSpacingToFitWidth:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setAdjustsLetterSpacingToFitWidth_, value);
  }

  /// initWithFrame:
  UILabel initWithFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal('UILabel.initWithFrame:', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_15yz4e6(this.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return UILabel.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCoder:
  UILabel? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0 ? null : UILabel.castFromPointer(_ret, retain: false, release: true);
  }

  /// init
  UILabel init() {
    objc.checkOsVersionInternal('UILabel.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UILabel.castFromPointer(_ret, retain: false, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// adjustsFontForContentSizeCategory
  bool get adjustsFontForContentSizeCategory {
    objc.checkOsVersionInternal('UILabel.adjustsFontForContentSizeCategory', iOS: (false, (10, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_adjustsFontForContentSizeCategory);
  }

  /// setAdjustsFontForContentSizeCategory:
  set adjustsFontForContentSizeCategory(bool value) {
    objc.checkOsVersionInternal('UILabel.setAdjustsFontForContentSizeCategory:', iOS: (false, (10, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setAdjustsFontForContentSizeCategory_, value);
  }
}

enum UIGestureRecognizerState {
  UIGestureRecognizerStatePossible(0),
  UIGestureRecognizerStateBegan(1),
  UIGestureRecognizerStateChanged(2),
  UIGestureRecognizerStateEnded(3),
  UIGestureRecognizerStateCancelled(4),
  UIGestureRecognizerStateFailed(5);

  static const UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded;

  final int value;
  const UIGestureRecognizerState(this.value);

  static UIGestureRecognizerState fromValue(int value) => switch (value) {
    0 => UIGestureRecognizerStatePossible,
    1 => UIGestureRecognizerStateBegan,
    2 => UIGestureRecognizerStateChanged,
    3 => UIGestureRecognizerStateEnded,
    4 => UIGestureRecognizerStateCancelled,
    5 => UIGestureRecognizerStateFailed,
    _ => throw ArgumentError('Unknown value for UIGestureRecognizerState: $value'),
  };

  @override
  String toString() {
    if (this == UIGestureRecognizerStateEnded)
      return "UIGestureRecognizerState.UIGestureRecognizerStateEnded, UIGestureRecognizerState.UIGestureRecognizerStateRecognized";
    return super.toString();
  }
}

enum UIScrollTypeMask {
  UIScrollTypeMaskDiscrete(1),
  UIScrollTypeMaskContinuous(2),
  UIScrollTypeMaskAll(3);

  final int value;
  const UIScrollTypeMask(this.value);

  static UIScrollTypeMask fromValue(int value) => switch (value) {
    1 => UIScrollTypeMaskDiscrete,
    2 => UIScrollTypeMaskContinuous,
    3 => UIScrollTypeMaskAll,
    _ => throw ArgumentError('Unknown value for UIScrollTypeMask: $value'),
  };
}

/// !
/// UINavigationController manages a stack of view controllers and a navigation bar.
/// It performs horizontal view transitions for pushed and popped views while keeping the navigation bar in sync.
///
/// Most clients will not need to subclass UINavigationController.
///
/// If a navigation controller is nested in a tab bar controller, it uses the title and toolbar attributes of the bottom view controller on the stack.
///
/// UINavigationController is rotatable if its top view controller is rotatable.
/// Navigation between controllers with non-uniform rotatability is currently not supported.
enum UINavigationControllerOperation {
  UINavigationControllerOperationNone(0),
  UINavigationControllerOperationPush(1),
  UINavigationControllerOperationPop(2);

  final int value;
  const UINavigationControllerOperation(this.value);

  static UINavigationControllerOperation fromValue(int value) => switch (value) {
    0 => UINavigationControllerOperationNone,
    1 => UINavigationControllerOperationPush,
    2 => UINavigationControllerOperationPop,
    _ => throw ArgumentError('Unknown value for UINavigationControllerOperation: $value'),
  };
}

enum UISwitchStyle {
  UISwitchStyleAutomatic(0),
  UISwitchStyleCheckbox(1),
  UISwitchStyleSliding(2);

  final int value;
  const UISwitchStyle(this.value);

  static UISwitchStyle fromValue(int value) => switch (value) {
    0 => UISwitchStyleAutomatic,
    1 => UISwitchStyleCheckbox,
    2 => UISwitchStyleSliding,
    _ => throw ArgumentError('Unknown value for UISwitchStyle: $value'),
  };
}

late final _class_UISwitch = objc.getClass("UISwitch");
late final _sel_onTintColor = objc.registerName("onTintColor");
late final _sel_setOnTintColor_ = objc.registerName("setOnTintColor:");
late final _sel_thumbTintColor = objc.registerName("thumbTintColor");
late final _sel_setThumbTintColor_ = objc.registerName("setThumbTintColor:");
late final _sel_onImage = objc.registerName("onImage");
late final _sel_setOnImage_ = objc.registerName("setOnImage:");
late final _sel_offImage = objc.registerName("offImage");
late final _sel_setOffImage_ = objc.registerName("setOffImage:");
final _objc_msgSend_ums1js = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setPreferredStyle_ = objc.registerName("setPreferredStyle:");
final _objc_msgSend_1bkwtnu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_isOn = objc.registerName("isOn");
late final _sel_setOn_ = objc.registerName("setOn:");
late final _sel_setOn_animated_ = objc.registerName("setOn:animated:");

/// UISwitch
class UISwitch extends UIControl implements objc.NSCoding {
  UISwitch._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UISwitch', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UISwitch] that points to the same underlying object as [other].
  UISwitch.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UISwitch] that wraps the given raw object pointer.
  UISwitch.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UISwitch].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UISwitch);
  }

      static UISwitch new$() {
    final _ret = _objc_msgSend_151sglz(_class_UISwitch, _sel_new);
    return UISwitch.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of UISwitch constructed with the default `new` method.
  factory UISwitch() => new$();

  /// layerClass
  static objc.ObjCObjectBase getLayerClass() {
    objc.checkOsVersionInternal('UISwitch.layerClass', iOS: (false, (2, 0, 0)));
    final _ret = _objc_msgSend_151sglz(_class_UISwitch, _sel_layerClass);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute(
    UISemanticContentAttribute attribute,
  ) {
    objc.checkOsVersionInternal(
      'UISwitch.userInterfaceLayoutDirectionForSemanticContentAttribute:',
      iOS: (false, (9, 0, 0)),
    );
    final _ret = _objc_msgSend_racczx(
      _class_UISwitch,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
      attribute.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute$1(
    UISemanticContentAttribute semanticContentAttribute, {
    required UIUserInterfaceLayoutDirection relativeToLayoutDirection,
  }) {
    objc.checkOsVersionInternal(
      'UISwitch.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
      iOS: (false, (10, 0, 0)),
    );
    final _ret = _objc_msgSend_tz4p54(
      _class_UISwitch,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
      semanticContentAttribute.value,
      relativeToLayoutDirection.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue(_ret);
  }
}

extension UISwitch$Methods on UISwitch {
  /// onTintColor
  UIColor? get onTintColor {
    objc.checkOsVersionInternal('UISwitch.onTintColor', iOS: (false, (5, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_onTintColor);
    return _ret.address == 0 ? null : UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// setOnTintColor:
  set onTintColor(UIColor? value) {
    objc.checkOsVersionInternal('UISwitch.setOnTintColor:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setOnTintColor_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// thumbTintColor
  UIColor? get thumbTintColor {
    objc.checkOsVersionInternal('UISwitch.thumbTintColor', iOS: (false, (6, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_thumbTintColor);
    return _ret.address == 0 ? null : UIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// setThumbTintColor:
  set thumbTintColor(UIColor? value) {
    objc.checkOsVersionInternal('UISwitch.setThumbTintColor:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setThumbTintColor_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// onImage
  UIImage? get onImage {
    objc.checkOsVersionInternal('UISwitch.onImage', iOS: (false, (6, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_onImage);
    return _ret.address == 0 ? null : UIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// setOnImage:
  set onImage(UIImage? value) {
    objc.checkOsVersionInternal('UISwitch.setOnImage:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setOnImage_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// offImage
  UIImage? get offImage {
    objc.checkOsVersionInternal('UISwitch.offImage', iOS: (false, (6, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_offImage);
    return _ret.address == 0 ? null : UIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// setOffImage:
  set offImage(UIImage? value) {
    objc.checkOsVersionInternal('UISwitch.setOffImage:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setOffImage_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The title displayed alongside the switch, positioned appropriately for the @c UIUserInterfaceIdiom.
  /// @note This property is only supported for Catalyst in the Mac idiom.
  objc.NSString? get title {
    objc.checkOsVersionInternal('UISwitch.title', iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return _ret.address == 0 ? null : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The title displayed alongside the switch, positioned appropriately for the @c UIUserInterfaceIdiom.
  /// @note This property is only supported for Catalyst in the Mac idiom.
  set title(objc.NSString? value) {
    objc.checkOsVersionInternal('UISwitch.setTitle:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTitle_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The switch's display style. This property always returns a concrete, resolved style (never UISwitchStyleAutomatic).
  UISwitchStyle get style {
    objc.checkOsVersionInternal('UISwitch.style', iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_ums1js(this.ref.pointer, _sel_style);
    return UISwitchStyle.fromValue(_ret);
  }

  /// Request a style for the switch. If the style changed, then the switch may resize.
  UISwitchStyle get preferredStyle {
    objc.checkOsVersionInternal('UISwitch.preferredStyle', iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_ums1js(this.ref.pointer, _sel_preferredStyle);
    return UISwitchStyle.fromValue(_ret);
  }

  /// Request a style for the switch. If the style changed, then the switch may resize.
  set preferredStyle(UISwitchStyle value) {
    objc.checkOsVersionInternal('UISwitch.setPreferredStyle:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_1bkwtnu(this.ref.pointer, _sel_setPreferredStyle_, value.value);
  }

  /// isOn
  bool get on$ {
    objc.checkOsVersionInternal('UISwitch.isOn', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isOn);
  }

  /// setOn:
  set on$(bool value) {
    objc.checkOsVersionInternal('UISwitch.setOn:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setOn_, value);
  }

  /// initWithFrame:
  // UISwitch initWithFrame(objc.CGRect frame) {
  //   objc.checkOsVersionInternal('UISwitch.initWithFrame:', iOS: (false, (2, 0, 0)));
  //   final _ret = _objc_msgSend_15yz4e6(this.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
  //   return UISwitch.castFromPointer(_ret, retain: false, release: true);
  // }

  /// initWithCoder:
  UISwitch? initWithCoder(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0 ? null : UISwitch.castFromPointer(_ret, retain: false, release: true);
  }

  /// setOn:animated:
  void setOn(bool on$1, {required bool animated}) {
    objc.checkOsVersionInternal('UISwitch.setOn:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_14iqu8t(this.ref.pointer, _sel_setOn_animated_, on$1, animated);
  }

  /// Initializes the control and adds primaryAction for the UIControlEventPrimaryActionTriggered control event. Subclasses of UIControl may alter or add behaviors around the usage of primaryAction, see subclass documentation of this initializer for additional information.
  UISwitch initWithFrame(objc.CGRect frame, {UIAction? primaryAction}) {
    objc.checkOsVersionInternal('UISwitch.initWithFrame:primaryAction:', iOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_gxusyk(
      this.ref.retainAndReturnPointer(),
      _sel_initWithFrame_primaryAction_,
      frame,
      primaryAction?.ref.pointer ?? ffi.nullptr,
    );
    return UISwitch.castFromPointer(_ret, retain: false, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }
}
